{
  "language": "fsharp",
  "patterns": {
    "active_pattern": {
      "description": "Active patterns allow you to define custom patterns for use in pattern matching expressions, providing a way to partition input data in more expressive ways than standard patterns",
      "whenToUse": "Use when you need to provide multiple ways to view the same data, create domain-specific pattern matching, or decompose complex data structures in pattern matching",
      "example": "// Partial active pattern for parsing integers\nlet (|Integer|_|) (str: string) =\n    match System.Int32.TryParse(str) with\n    | (true, value) -> Some value\n    | _ -> None\n\n// Complete active pattern for categorizing numbers\nlet (|Positive|Zero|Negative|) n =\n    if n > 0 then Positive\n    elif n = 0 then Zero\n    else Negative\n\n// Usage in pattern matching\nlet describeNumber input =\n    match input with\n    | Integer n -> \n        match n with\n        | Positive -> sprintf \"%d is positive\" n\n        | Zero -> \"Zero\"\n        | Negative -> sprintf \"%d is negative\" n\n    | _ -> \"Not a valid integer\"\n\n// Parameterized active pattern\nlet (|DivisibleBy|_|) divisor n =\n    if n % divisor = 0 then Some(n / divisor)\n    else None\n\nlet fizzbuzz n =\n    match n with\n    | DivisibleBy 15 _ -> \"FizzBuzz\"\n    | DivisibleBy 5 _ -> \"Buzz\"\n    | DivisibleBy 3 _ -> \"Fizz\"\n    | _ -> string n"
    },
    "computation_expression": {
      "description": "Computation expressions (CE) provide a convenient syntax for writing computations that can be sequenced and combined using control flow constructs and bindings, similar to monads in other languages",
      "whenToUse": "Use when building domain-specific languages, handling asynchronous operations, managing state, or creating custom control flow for effects like error handling, async, or sequences",
      "example": "// Option computation expression\ntype MaybeBuilder() =\n    member _.Bind(x, f) = Option.bind f x\n    member _.Return(x) = Some x\n    member _.ReturnFrom(x) = x\n    member _.Zero() = None\n\nlet maybe = MaybeBuilder()\n\n// Using the computation expression\nlet divideBy bottom top =\n    if bottom = 0 then None\n    else Some(top / bottom)\n\nlet calculate x y z =\n    maybe {\n        let! a = divideBy x 100\n        let! b = divideBy y a\n        let! c = divideBy z b\n        return c\n    }\n\n// Async computation expression (built-in)\nlet fetchDataAsync url =\n    async {\n        use client = new System.Net.Http.HttpClient()\n        let! response = client.GetAsync(url) |> Async.AwaitTask\n        let! content = response.Content.ReadAsStringAsync() |> Async.AwaitTask\n        return content\n    }\n\n// Custom state computation expression\ntype StateBuilder() =\n    member _.Bind(m, f) = fun s -> let (a, s') = m s in f a s'\n    member _.Return(x) = fun s -> (x, s)\n    member _.ReturnFrom(m) = m\n\nlet state = StateBuilder()\n\nlet increment = fun s -> ((), s + 1)\nlet get = fun s -> (s, s)\n\nlet computation =\n    state {\n        do! increment\n        do! increment\n        let! current = get\n        return current\n    }"
    },
    "railway_oriented": {
      "description": "Railway-oriented programming treats the flow of data through functions like a railway track with two rails - success and failure - making error handling explicit and composable",
      "whenToUse": "Use when you need robust error handling in a pipeline of operations, want to make failure cases explicit, or need to compose operations that might fail",
      "example": "// Define a Result type (or use built-in Result<'T,'TError>)\ntype Result<'Success, 'Failure> =\n    | Ok of 'Success\n    | Error of 'Failure\n\n// Basic railway functions\nlet bind f = function\n    | Ok x -> f x\n    | Error e -> Error e\n\nlet map f = function\n    | Ok x -> Ok (f x)\n    | Error e -> Error e\n\n// Railway operator\nlet (>>=) x f = bind f x\nlet (<!>) = map\n\n// Domain types\ntype Email = Email of string\ntype ValidationError = \n    | InvalidEmail of string\n    | EmptyName\n    | InvalidAge of int\n\n// Validation functions that return Result\nlet validateEmail (input: string) =\n    if input.Contains(\"@\") then \n        Ok (Email input)\n    else \n        Error (InvalidEmail input)\n\nlet validateName (name: string) =\n    if String.IsNullOrWhiteSpace(name) then\n        Error EmptyName\n    else\n        Ok name\n\nlet validateAge (age: int) =\n    if age >= 0 && age <= 120 then\n        Ok age\n    else\n        Error (InvalidAge age)\n\n// Compose validations using railway-oriented programming\ntype Person = { Name: string; Email: Email; Age: int }\n\nlet createPerson name email age =\n    let validatedName = validateName name\n    let validatedEmail = validateEmail email\n    let validatedAge = validateAge age\n    \n    // Using computation expression for Result\n    result {\n        let! name = validatedName\n        let! email = validatedEmail\n        let! age = validatedAge\n        return { Name = name; Email = email; Age = age }\n    }\n\n// Or using operators\nlet createPersonRailway name email age =\n    validateName name\n    >>= fun validName ->\n        validateEmail email\n        >>= fun validEmail ->\n            validateAge age\n            <!> fun validAge -> \n                { Name = validName; Email = validEmail; Age = validAge }"
    },
    "type_provider": {
      "description": "Type providers are components that provide types, properties, and methods for use in your program based on external data sources, offering compile-time type safety for external data",
      "whenToUse": "Use when working with external data sources like databases, web services, or file formats where you want compile-time type safety and IntelliSense support",
      "example": "// Using JSON Type Provider\n#r \"nuget: FSharp.Data\"\nopen FSharp.Data\n\n// Define a type from sample JSON\ntype Person = JsonProvider<\"\"\"{ \"name\": \"John\", \"age\": 30, \"emails\": [\"john@example.com\"] }\"\"\">\n\n// Now you have strongly-typed access\nlet person = Person.Parse(\"\"\"{ \"name\": \"Jane\", \"age\": 25, \"emails\": [\"jane@test.com\", \"jane@work.com\"] }\"\"\")\nlet name = person.Name  // string\nlet age = person.Age    // int\nlet firstEmail = person.Emails.[0]  // string\n\n// SQL Type Provider example\n#r \"nuget: FSharp.Data.SqlClient\"\nopen FSharp.Data\n\n[<Literal>]\nlet connectionString = \"Data Source=.;Initial Catalog=MyDB;Integrated Security=true\"\n\ntype GetCustomers = SqlCommandProvider<\"\n    SELECT CustomerID, CompanyName, ContactName \n    FROM Customers \n    WHERE Country = @country\", connectionString>\n\n// Use with compile-time checking\nlet customers = \n    use cmd = new GetCustomers(connectionString)\n    cmd.Execute(country = \"USA\") |> Seq.toList\n\n// CSV Type Provider\ntype Stock = CsvProvider<\"\"\"Date,Open,High,Low,Close,Volume\n2023-01-01,100.0,105.0,99.0,104.0,1000000\"\"\">\n\nlet stocks = Stock.Load(\"stock_data.csv\")\nfor row in stocks.Rows do\n    printfn \"On %A: Close = %f\" row.Date row.Close\n\n// Creating a simple custom type provider\nopen Microsoft.FSharp.Core.CompilerServices\nopen System.Reflection\n\n[<TypeProvider>]\ntype SimpleProvider(config: TypeProviderConfig) as this =\n    inherit TypeProviderForNamespaces(config)\n    \n    let ns = \"MyNamespace\"\n    let asm = Assembly.GetExecutingAssembly()\n    \n    let createType name =\n        let t = ProvidedTypeDefinition(asm, ns, name, Some typeof<obj>)\n        let prop = ProvidedProperty(\"Message\", typeof<string>, \n                                  getterCode = fun _ -> <@@ \"Hello from type provider!\" @@>)\n        t.AddMember(prop)\n        t\n    \n    do\n        let providedType = createType \"MyType\"\n        this.AddNamespace(ns, [providedType])"
    },
    "discriminated_union": {
      "description": "Discriminated unions provide a way to define a type that can be one of several named cases, each potentially with different values and types, enabling type-safe modeling of choice",
      "whenToUse": "Use when modeling data that can be one of several distinct options, implementing state machines, representing abstract syntax trees, or replacing class hierarchies with a more functional approach",
      "example": "// Basic discriminated union for shapes\ntype Shape =\n    | Circle of radius: float\n    | Rectangle of width: float * height: float\n    | Triangle of base: float * height: float\n\n// Pattern matching on discriminated unions\nlet area shape =\n    match shape with\n    | Circle radius -> Math.PI * radius * radius\n    | Rectangle (width, height) -> width * height\n    | Triangle (base, height) -> 0.5 * base * height\n\n// Recursive discriminated union for expression trees\ntype Expression =\n    | Number of float\n    | Add of Expression * Expression\n    | Multiply of Expression * Expression\n    | Variable of string\n\nlet rec evaluate (vars: Map<string, float>) expr =\n    match expr with\n    | Number n -> n\n    | Add (left, right) -> evaluate vars left + evaluate vars right\n    | Multiply (left, right) -> evaluate vars left * evaluate vars right\n    | Variable name -> vars.[name]\n\n// State machine using discriminated unions\ntype ConnectionState =\n    | Disconnected\n    | Connecting of attempt: int\n    | Connected of sessionId: string\n    | Disconnecting\n    | Failed of error: string\n\ntype ConnectionEvent =\n    | Connect\n    | ConnectionEstablished of string\n    | Disconnect\n    | Error of string\n    | Retry\n\nlet transition state event =\n    match state, event with\n    | Disconnected, Connect -> Connecting 1\n    | Connecting attempt, ConnectionEstablished sessionId -> Connected sessionId\n    | Connecting attempt, Error msg when attempt < 3 -> Connecting (attempt + 1)\n    | Connecting _, Error msg -> Failed msg\n    | Connected _, Disconnect -> Disconnecting\n    | Disconnecting, _ -> Disconnected\n    | Failed _, Retry -> Connecting 1\n    | _ -> state  // No transition\n\n// Option type is a built-in discriminated union\n// type Option<'T> = None | Some of 'T\n\n// Using DUs for domain modeling\ntype PaymentMethod =\n    | Cash\n    | CreditCard of number: string * cvv: string * expiry: DateTime\n    | BankTransfer of accountNumber: string * routingNumber: string\n    | PayPal of email: string"
    },
    "type_safe_format": {
      "description": "F# provides type-safe formatting through printf-style functions that check format specifiers at compile time, preventing runtime formatting errors",
      "whenToUse": "Use when you need string formatting with compile-time safety, building templated strings, or creating domain-specific formatting functions",
      "example": "// Basic type-safe formatting\nlet name = \"Alice\"\nlet age = 30\nlet formatted = sprintf \"Name: %s, Age: %d\" name age\n// Compile error if types don't match: sprintf \"Name: %d\" name\n\n// Custom formatting functions\nlet logInfo format = Printf.kprintf (fun s -> printfn \"[INFO] %s\" s) format\nlet logError format = Printf.kprintf (fun s -> eprintfn \"[ERROR] %s\" s) format\n\nlogInfo \"User %s logged in at %O\" \"Bob\" DateTime.Now\nlogError \"Failed to process order %d: %s\" 12345 \"Invalid payment\"\n\n// Building SQL queries safely\ntype SqlFormat<'T> = Printf.StringFormat<'T, string>\n\nlet sqlFormat (fmt: SqlFormat<'T>) : 'T = \n    Printf.kprintf (fun s -> s.Replace(\"'\", \"''\")) fmt\n\nlet buildQuery tableName id name =\n    sqlFormat \"SELECT * FROM %s WHERE id = %d AND name = '%s'\" tableName id name\n\n// Type-safe HTML templating\ntype HtmlFormat<'T> = Printf.StringFormat<'T, string>\n\nlet html (fmt: HtmlFormat<'T>) : 'T =\n    Printf.kprintf (fun s -> s) fmt\n\nlet htmlEscape (s: string) =\n    s.Replace(\"&\", \"&amp;\")\n     .Replace(\"<\", \"&lt;\")\n     .Replace(\">\", \"&gt;\")\n     .Replace(\"\\\"\", \"&quot;\")\n\nlet div content = html \"<div>%s</div>\" (htmlEscape content)\nlet link url text = html \"\"\"<a href=\"%s\">%s</a>\"\"\" url (htmlEscape text)\n\n// Custom format specifiers\ntype Money = Money of decimal\n\nlet moneyFormat (Money amount) = sprintf \"$%.2f\" (decimal amount)\n\n// Using with StringBuilder for performance\nopen System.Text\n\ntype StringBuilderFormat<'T> = Printf.StringFormat<'T, StringBuilder -> unit>\n\nlet bprintf (sb: StringBuilder) (fmt: StringBuilderFormat<'T>) : 'T =\n    Printf.kbprintf (fun () -> ()) sb fmt\n\nlet buildLargeString () =\n    let sb = StringBuilder()\n    for i in 1..1000 do\n        bprintf sb \"Line %d: %s\\n\" i \"data\"\n    sb.ToString()"
    },
    "memoization": {
      "description": "Memoization is a technique for caching function results to avoid redundant computations, particularly useful for pure functions with expensive calculations",
      "whenToUse": "Use when you have pure functions with expensive computations that are called repeatedly with the same arguments, especially in recursive algorithms like dynamic programming",
      "example": "// Basic memoization using a dictionary\nlet memoize f =\n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x ->\n        match cache.TryGetValue(x) with\n        | true, v -> v\n        | false, _ ->\n            let v = f x\n            cache.[x] <- v\n            v\n\n// Fibonacci with memoization\nlet rec fib = memoize (fun n ->\n    if n <= 1 then n\n    else fib (n - 1) + fib (n - 2))\n\n// Generic memoization for functions with multiple parameters\nlet memoize2 f =\n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x y ->\n        let key = (x, y)\n        match cache.TryGetValue(key) with\n        | true, v -> v\n        | false, _ ->\n            let v = f x y\n            cache.[key] <- v\n            v\n\n// Thread-safe memoization\nlet memoizeThreadSafe f =\n    let cache = System.Collections.Concurrent.ConcurrentDictionary<_, _>()\n    fun x -> cache.GetOrAdd(x, f)\n\n// Memoization with custom key function\nlet memoizeBy keyFunc f =\n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    fun x ->\n        let key = keyFunc x\n        match cache.TryGetValue(key) with\n        | true, v -> v\n        | false, _ ->\n            let v = f x\n            cache.[key] <- v\n            v\n\n// LRU (Least Recently Used) memoization\ntype LruCache<'Key, 'Value when 'Key : equality>(capacity: int) =\n    let cache = System.Collections.Generic.Dictionary<'Key, 'Value>()\n    let order = System.Collections.Generic.LinkedList<'Key>()\n    let nodes = System.Collections.Generic.Dictionary<'Key, LinkedListNode<'Key>>()\n    \n    member _.Get(key: 'Key, factory: 'Key -> 'Value) =\n        match cache.TryGetValue(key) with\n        | true, value ->\n            // Move to front\n            let node = nodes.[key]\n            order.Remove(node)\n            order.AddFirst(node) |> ignore\n            value\n        | false, _ ->\n            let value = factory key\n            \n            // Add to cache\n            if cache.Count >= capacity then\n                // Remove least recently used\n                let lru = order.Last.Value\n                order.RemoveLast()\n                cache.Remove(lru) |> ignore\n                nodes.Remove(lru) |> ignore\n            \n            cache.[key] <- value\n            let node = order.AddFirst(key)\n            nodes.[key] <- node\n            value\n\nlet lruMemoize capacity f =\n    let cache = LruCache<_, _>(capacity)\n    fun x -> cache.Get(x, f)\n\n// Recursive memoization using Y combinator\nlet rec Y f x = f (Y f) x\n\nlet memoY f =\n    let cache = System.Collections.Generic.Dictionary<_, _>()\n    let rec memoized x =\n        match cache.TryGetValue(x) with\n        | true, v -> v\n        | false, _ ->\n            let v = f memoized x\n            cache.[x] <- v\n            v\n    memoized"
    },
    "parser_combinator": {
      "description": "Parser combinators are higher-order functions that combine simple parsers to build more complex parsers in a composable and declarative way",
      "whenToUse": "Use when building parsers for domain-specific languages, configuration files, or any structured text format where you want a maintainable and composable parsing solution",
      "example": "// Basic parser type and combinators\ntype Parser<'T> = Parser of (string -> Result<'T * string, string>)\n\n// Run a parser\nlet run (Parser p) input = p input\n\n// Basic combinators\nlet succeed x = Parser (fun input -> Ok (x, input))\nlet fail msg = Parser (fun _ -> Error msg)\n\n// Parse a single character\nlet pchar c = \n    Parser (fun input ->\n        if String.IsNullOrEmpty(input) then\n            Error (sprintf \"No more input\")\n        elif input.[0] = c then\n            Ok (c, input.[1..])\n        else\n            Error (sprintf \"Expected '%c' but got '%c'\" c input.[0]))\n\n// Bind combinator (monadic bind)\nlet bind f (Parser p) =\n    Parser (fun input ->\n        match p input with\n        | Ok (value, remaining) -> \n            let (Parser p2) = f value\n            p2 remaining\n        | Error e -> Error e)\n\n// Map combinator\nlet map f parser =\n    bind (f >> succeed) parser\n\n// Apply combinator\nlet apply fParser xParser =\n    bind (fun f -> \n        bind (fun x -> \n            succeed (f x)) xParser) fParser\n\n// Operators for convenience\nlet (>>=) = bind\nlet (<!>) = map\nlet (<*>) = apply\n\n// Choice combinator\nlet (<|>) (Parser p1) (Parser p2) =\n    Parser (fun input ->\n        match p1 input with\n        | Ok result -> Ok result\n        | Error _ -> p2 input)\n\n// Many combinator (zero or more)\nlet rec many parser =\n    (parser >>= fun head ->\n     many parser >>= fun tail ->\n     succeed (head :: tail))\n    <|> succeed []\n\n// Many1 combinator (one or more)\nlet many1 parser =\n    parser >>= fun head ->\n    many parser >>= fun tail ->\n    succeed (head :: tail)\n\n// Computation expression for parsers\ntype ParserBuilder() =\n    member _.Bind(p, f) = bind f p\n    member _.Return(x) = succeed x\n    member _.ReturnFrom(p) = p\n\nlet parse = ParserBuilder()\n\n// Example: JSON parser\nlet pstring s =\n    s |> Seq.map pchar |> Seq.reduce (fun p1 p2 ->\n        p1 >>= fun c1 ->\n        p2 >>= fun c2 ->\n        succeed (string c1 + string c2))\n\nlet spaces = many (pchar ' ' <|> pchar '\\t' <|> pchar '\\n' <|> pchar '\\r')\nlet ws p = spaces >>= fun _ -> p >>= fun x -> spaces >>= fun _ -> succeed x\n\nlet pbool =\n    (pstring \"true\" <!> fun _ -> true)\n    <|> (pstring \"false\" <!> fun _ -> false)\n\nlet pnumber =\n    let digit = pchar '0' <|> pchar '1' <|> pchar '2' <|> pchar '3' <|> pchar '4' \n             <|> pchar '5' <|> pchar '6' <|> pchar '7' <|> pchar '8' <|> pchar '9'\n    many1 digit <!> fun digits -> \n        digits |> List.map string |> String.concat \"\" |> int\n\n// Using FParsec library (more practical)\n#r \"nuget: FParsec\"\nopen FParsec\n\n// Define AST\ntype Expr =\n    | Number of float\n    | BinOp of Expr * char * Expr\n\n// Parser using FParsec\nlet pnumberFP = pfloat |>> Number\n\nlet opp = OperatorPrecedenceParser<Expr, unit, unit>()\nlet expr = opp.ExpressionParser\n\nopp.TermParser <- pnumberFP <|> between (pchar '(') (pchar ')') expr\n\nopp.AddOperator(InfixOperator(\"+\", spaces, 1, Associativity.Left, \n                              fun l r -> BinOp(l, '+', r)))\nopp.AddOperator(InfixOperator(\"*\", spaces, 2, Associativity.Left, \n                              fun l r -> BinOp(l, '*', r)))\n\nlet parseExpression = run expr"
    }
  }
}