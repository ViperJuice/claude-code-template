{
  "language": "csharp",
  "patterns": {
    "async_repository": {
      "description": "Implements data access layer with async/await for non-blocking database operations.",
      "whenToUse": "When building scalable applications that need efficient data access without blocking threads.",
      "example": "public interface IAsyncRepository<T> where T : BaseEntity\n{\n    Task<T> GetByIdAsync(int id);\n    Task<T> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate);\n    Task<IEnumerable<T>> GetAllAsync();\n    Task<IEnumerable<T>> GetWhereAsync(Expression<Func<T, bool>> predicate);\n    Task AddAsync(T entity);\n    Task UpdateAsync(T entity);\n    Task DeleteAsync(T entity);\n    Task<int> CountAsync(Expression<Func<T, bool>> predicate = null);\n}\n\npublic class AsyncRepository<T> : IAsyncRepository<T> where T : BaseEntity\n{\n    protected readonly DbContext _context;\n    protected readonly DbSet<T> _dbSet;\n    \n    public AsyncRepository(DbContext context)\n    {\n        _context = context;\n        _dbSet = context.Set<T>();\n    }\n    \n    public async Task<T> GetByIdAsync(int id)\n    {\n        return await _dbSet.FindAsync(id);\n    }\n    \n    public async Task<T> FirstOrDefaultAsync(Expression<Func<T, bool>> predicate)\n    {\n        return await _dbSet.FirstOrDefaultAsync(predicate);\n    }\n    \n    public async Task<IEnumerable<T>> GetAllAsync()\n    {\n        return await _dbSet.ToListAsync();\n    }\n    \n    public async Task<IEnumerable<T>> GetWhereAsync(Expression<Func<T, bool>> predicate)\n    {\n        return await _dbSet.Where(predicate).ToListAsync();\n    }\n    \n    public async Task AddAsync(T entity)\n    {\n        await _dbSet.AddAsync(entity);\n    }\n    \n    public async Task UpdateAsync(T entity)\n    {\n        _dbSet.Update(entity);\n        await Task.CompletedTask;\n    }\n    \n    public async Task DeleteAsync(T entity)\n    {\n        _dbSet.Remove(entity);\n        await Task.CompletedTask;\n    }\n    \n    public async Task<int> CountAsync(Expression<Func<T, bool>> predicate = null)\n    {\n        return predicate == null \n            ? await _dbSet.CountAsync()\n            : await _dbSet.CountAsync(predicate);\n    }\n}"
    },
    "unit_of_work": {
      "description": "Maintains a list of objects affected by a business transaction and coordinates writing out changes.",
      "whenToUse": "When you need to ensure all operations within a business transaction are committed or rolled back as one.",
      "example": "public interface IUnitOfWork : IDisposable\n{\n    IUserRepository Users { get; }\n    IOrderRepository Orders { get; }\n    IProductRepository Products { get; }\n    Task<int> CompleteAsync();\n    Task<int> CompleteAsync(CancellationToken cancellationToken);\n    void BeginTransaction();\n    void Commit();\n    void Rollback();\n}\n\npublic class UnitOfWork : IUnitOfWork\n{\n    private readonly ApplicationDbContext _context;\n    private readonly IServiceProvider _serviceProvider;\n    private IDbContextTransaction _transaction;\n    \n    // Lazy-loaded repositories\n    private IUserRepository _users;\n    private IOrderRepository _orders;\n    private IProductRepository _products;\n    \n    public UnitOfWork(ApplicationDbContext context, IServiceProvider serviceProvider)\n    {\n        _context = context;\n        _serviceProvider = serviceProvider;\n    }\n    \n    public IUserRepository Users => \n        _users ??= _serviceProvider.GetService<IUserRepository>();\n        \n    public IOrderRepository Orders => \n        _orders ??= _serviceProvider.GetService<IOrderRepository>();\n        \n    public IProductRepository Products => \n        _products ??= _serviceProvider.GetService<IProductRepository>();\n    \n    public async Task<int> CompleteAsync()\n    {\n        return await _context.SaveChangesAsync();\n    }\n    \n    public async Task<int> CompleteAsync(CancellationToken cancellationToken)\n    {\n        return await _context.SaveChangesAsync(cancellationToken);\n    }\n    \n    public void BeginTransaction()\n    {\n        _transaction = _context.Database.BeginTransaction();\n    }\n    \n    public void Commit()\n    {\n        try\n        {\n            _context.SaveChanges();\n            _transaction?.Commit();\n        }\n        catch\n        {\n            _transaction?.Rollback();\n            throw;\n        }\n        finally\n        {\n            _transaction?.Dispose();\n            _transaction = null;\n        }\n    }\n    \n    public void Rollback()\n    {\n        _transaction?.Rollback();\n        _transaction?.Dispose();\n        _transaction = null;\n    }\n    \n    public void Dispose()\n    {\n        _transaction?.Dispose();\n        _context.Dispose();\n    }\n}"
    },
    "dependency_injection": {
      "description": "Provides dependencies to an object rather than having it create them.",
      "whenToUse": "For loose coupling, better testability, and following SOLID principles.",
      "example": "// Service registration in Program.cs or Startup.cs\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        var builder = WebApplication.CreateBuilder(args);\n        \n        // Register services\n        builder.Services.AddDbContext<ApplicationDbContext>(options =>\n            options.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\")));\n        \n        // Register repositories\n        builder.Services.AddScoped<IUserRepository, UserRepository>();\n        builder.Services.AddScoped<IOrderRepository, OrderRepository>();\n        \n        // Register Unit of Work\n        builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();\n        \n        // Register services\n        builder.Services.AddScoped<IUserService, UserService>();\n        builder.Services.AddSingleton<IEmailService, EmailService>();\n        builder.Services.AddTransient<INotificationService, NotificationService>();\n        \n        var app = builder.Build();\n        app.Run();\n    }\n}\n\n// Service with constructor injection\npublic interface IUserService\n{\n    Task<User> GetUserAsync(int id);\n    Task<User> CreateUserAsync(CreateUserDto dto);\n}\n\npublic class UserService : IUserService\n{\n    private readonly IUnitOfWork _unitOfWork;\n    private readonly IEmailService _emailService;\n    private readonly ILogger<UserService> _logger;\n    \n    public UserService(\n        IUnitOfWork unitOfWork,\n        IEmailService emailService,\n        ILogger<UserService> logger)\n    {\n        _unitOfWork = unitOfWork;\n        _emailService = emailService;\n        _logger = logger;\n    }\n    \n    public async Task<User> GetUserAsync(int id)\n    {\n        return await _unitOfWork.Users.GetByIdAsync(id);\n    }\n    \n    public async Task<User> CreateUserAsync(CreateUserDto dto)\n    {\n        var user = new User\n        {\n            Name = dto.Name,\n            Email = dto.Email,\n            CreatedAt = DateTime.UtcNow\n        };\n        \n        await _unitOfWork.Users.AddAsync(user);\n        await _unitOfWork.CompleteAsync();\n        \n        await _emailService.SendWelcomeEmailAsync(user.Email, user.Name);\n        \n        _logger.LogInformation(\"User {UserId} created successfully\", user.Id);\n        \n        return user;\n    }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step with method chaining.",
      "whenToUse": "When creating objects with many parameters or complex initialization logic.",
      "example": "public class EmailMessage\n{\n    public string From { get; init; }\n    public List<string> To { get; init; }\n    public List<string> Cc { get; init; }\n    public List<string> Bcc { get; init; }\n    public string Subject { get; init; }\n    public string Body { get; init; }\n    public bool IsHtml { get; init; }\n    public List<Attachment> Attachments { get; init; }\n    public Priority Priority { get; init; }\n}\n\npublic class EmailMessageBuilder\n{\n    private string _from;\n    private readonly List<string> _to = new();\n    private readonly List<string> _cc = new();\n    private readonly List<string> _bcc = new();\n    private string _subject;\n    private string _body;\n    private bool _isHtml;\n    private readonly List<Attachment> _attachments = new();\n    private Priority _priority = Priority.Normal;\n    \n    public EmailMessageBuilder From(string from)\n    {\n        _from = from;\n        return this;\n    }\n    \n    public EmailMessageBuilder To(params string[] recipients)\n    {\n        _to.AddRange(recipients);\n        return this;\n    }\n    \n    public EmailMessageBuilder Cc(params string[] recipients)\n    {\n        _cc.AddRange(recipients);\n        return this;\n    }\n    \n    public EmailMessageBuilder Bcc(params string[] recipients)\n    {\n        _bcc.AddRange(recipients);\n        return this;\n    }\n    \n    public EmailMessageBuilder WithSubject(string subject)\n    {\n        _subject = subject;\n        return this;\n    }\n    \n    public EmailMessageBuilder WithBody(string body, bool isHtml = false)\n    {\n        _body = body;\n        _isHtml = isHtml;\n        return this;\n    }\n    \n    public EmailMessageBuilder AttachFile(string fileName, byte[] content)\n    {\n        _attachments.Add(new Attachment { FileName = fileName, Content = content });\n        return this;\n    }\n    \n    public EmailMessageBuilder WithPriority(Priority priority)\n    {\n        _priority = priority;\n        return this;\n    }\n    \n    public EmailMessage Build()\n    {\n        if (string.IsNullOrEmpty(_from))\n            throw new InvalidOperationException(\"From address is required\");\n            \n        if (!_to.Any())\n            throw new InvalidOperationException(\"At least one recipient is required\");\n            \n        return new EmailMessage\n        {\n            From = _from,\n            To = _to,\n            Cc = _cc,\n            Bcc = _bcc,\n            Subject = _subject ?? string.Empty,\n            Body = _body ?? string.Empty,\n            IsHtml = _isHtml,\n            Attachments = _attachments,\n            Priority = _priority\n        };\n    }\n}\n\n// Usage\nvar email = new EmailMessageBuilder()\n    .From(\"sender@example.com\")\n    .To(\"recipient1@example.com\", \"recipient2@example.com\")\n    .WithSubject(\"Important Message\")\n    .WithBody(\"<h1>Hello World</h1>\", isHtml: true)\n    .WithPriority(Priority.High)\n    .Build();"
    },
    "singleton": {
      "description": "Ensures a class has only one instance with thread-safe implementation.",
      "whenToUse": "When exactly one instance is needed (configuration, caching, logging).",
      "example": "// Thread-safe singleton with lazy initialization\npublic sealed class ConfigurationManager\n{\n    private static readonly Lazy<ConfigurationManager> _lazy =\n        new Lazy<ConfigurationManager>(() => new ConfigurationManager());\n        \n    private readonly Dictionary<string, object> _settings;\n    \n    public static ConfigurationManager Instance => _lazy.Value;\n    \n    private ConfigurationManager()\n    {\n        _settings = new Dictionary<string, object>();\n        LoadConfiguration();\n    }\n    \n    private void LoadConfiguration()\n    {\n        // Load settings from file or database\n    }\n    \n    public T GetValue<T>(string key, T defaultValue = default)\n    {\n        if (_settings.TryGetValue(key, out var value) && value is T typedValue)\n        {\n            return typedValue;\n        }\n        return defaultValue;\n    }\n    \n    public void SetValue(string key, object value)\n    {\n        lock (_settings)\n        {\n            _settings[key] = value;\n        }\n    }\n}\n\n// Singleton using DI container (preferred approach)\npublic interface ICacheService\n{\n    Task<T> GetAsync<T>(string key);\n    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null);\n    Task RemoveAsync(string key);\n}\n\npublic class MemoryCacheService : ICacheService\n{\n    private readonly IMemoryCache _cache;\n    \n    public MemoryCacheService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n    \n    public Task<T> GetAsync<T>(string key)\n    {\n        var value = _cache.Get<T>(key);\n        return Task.FromResult(value);\n    }\n    \n    public Task SetAsync<T>(string key, T value, TimeSpan? expiration = null)\n    {\n        var options = new MemoryCacheEntryOptions();\n        if (expiration.HasValue)\n        {\n            options.SetAbsoluteExpiration(expiration.Value);\n        }\n        \n        _cache.Set(key, value, options);\n        return Task.CompletedTask;\n    }\n    \n    public Task RemoveAsync(string key)\n    {\n        _cache.Remove(key);\n        return Task.CompletedTask;\n    }\n}\n\n// Register as singleton in DI\n// services.AddSingleton<ICacheService, MemoryCacheService>();"
    },
    "factory": {
      "description": "Creates objects without specifying their exact types using interfaces.",
      "whenToUse": "When object creation logic is complex or needs to be determined at runtime.",
      "example": "// Abstract factory pattern\npublic interface IPaymentProcessorFactory\n{\n    IPaymentProcessor CreateProcessor(PaymentMethod method);\n}\n\npublic interface IPaymentProcessor\n{\n    Task<PaymentResult> ProcessPaymentAsync(decimal amount, PaymentDetails details);\n    bool ValidateDetails(PaymentDetails details);\n}\n\npublic class PaymentProcessorFactory : IPaymentProcessorFactory\n{\n    private readonly IServiceProvider _serviceProvider;\n    \n    public PaymentProcessorFactory(IServiceProvider serviceProvider)\n    {\n        _serviceProvider = serviceProvider;\n    }\n    \n    public IPaymentProcessor CreateProcessor(PaymentMethod method)\n    {\n        return method switch\n        {\n            PaymentMethod.CreditCard => _serviceProvider.GetService<CreditCardProcessor>(),\n            PaymentMethod.PayPal => _serviceProvider.GetService<PayPalProcessor>(),\n            PaymentMethod.BankTransfer => _serviceProvider.GetService<BankTransferProcessor>(),\n            _ => throw new NotSupportedException($\"Payment method {method} is not supported\")\n        };\n    }\n}\n\npublic class CreditCardProcessor : IPaymentProcessor\n{\n    private readonly ILogger<CreditCardProcessor> _logger;\n    \n    public CreditCardProcessor(ILogger<CreditCardProcessor> logger)\n    {\n        _logger = logger;\n    }\n    \n    public async Task<PaymentResult> ProcessPaymentAsync(decimal amount, PaymentDetails details)\n    {\n        if (!ValidateDetails(details))\n        {\n            return new PaymentResult { Success = false, Error = \"Invalid payment details\" };\n        }\n        \n        _logger.LogInformation(\"Processing credit card payment of {Amount}\", amount);\n        \n        // Simulate payment processing\n        await Task.Delay(1000);\n        \n        return new PaymentResult\n        {\n            Success = true,\n            TransactionId = Guid.NewGuid().ToString(),\n            ProcessedAt = DateTime.UtcNow\n        };\n    }\n    \n    public bool ValidateDetails(PaymentDetails details)\n    {\n        return details is CreditCardDetails cc &&\n               !string.IsNullOrEmpty(cc.CardNumber) &&\n               !string.IsNullOrEmpty(cc.CVV) &&\n               cc.ExpiryDate > DateTime.Now;\n    }\n}\n\n// Generic factory pattern\npublic interface IFactory<T>\n{\n    T Create();\n}\n\npublic interface IFactory<TParam, T>\n{\n    T Create(TParam parameter);\n}\n\npublic class RepositoryFactory<T> : IFactory<DbContext, IAsyncRepository<T>> \n    where T : BaseEntity\n{\n    public IAsyncRepository<T> Create(DbContext context)\n    {\n        return new AsyncRepository<T>(context);\n    }\n}"
    },
    "strategy": {
      "description": "Encapsulates algorithms and makes them interchangeable at runtime.",
      "whenToUse": "When you have multiple algorithms for a task and want to switch between them.",
      "example": "// Strategy interface\npublic interface IDiscountStrategy\n{\n    decimal CalculateDiscount(decimal originalPrice, Customer customer);\n    string GetDescription();\n}\n\n// Concrete strategies\npublic class NoDiscountStrategy : IDiscountStrategy\n{\n    public decimal CalculateDiscount(decimal originalPrice, Customer customer)\n    {\n        return 0;\n    }\n    \n    public string GetDescription() => \"No discount\";\n}\n\npublic class PercentageDiscountStrategy : IDiscountStrategy\n{\n    private readonly decimal _percentage;\n    \n    public PercentageDiscountStrategy(decimal percentage)\n    {\n        _percentage = percentage;\n    }\n    \n    public decimal CalculateDiscount(decimal originalPrice, Customer customer)\n    {\n        return originalPrice * (_percentage / 100);\n    }\n    \n    public string GetDescription() => $\"{_percentage}% off\";\n}\n\npublic class LoyaltyDiscountStrategy : IDiscountStrategy\n{\n    public decimal CalculateDiscount(decimal originalPrice, Customer customer)\n    {\n        return customer.LoyaltyLevel switch\n        {\n            LoyaltyLevel.Silver => originalPrice * 0.05m,\n            LoyaltyLevel.Gold => originalPrice * 0.10m,\n            LoyaltyLevel.Platinum => originalPrice * 0.15m,\n            _ => 0\n        };\n    }\n    \n    public string GetDescription() => \"Loyalty discount\";\n}\n\npublic class TieredDiscountStrategy : IDiscountStrategy\n{\n    private readonly List<(decimal threshold, decimal discount)> _tiers;\n    \n    public TieredDiscountStrategy()\n    {\n        _tiers = new List<(decimal, decimal)>\n        {\n            (1000, 0.05m),\n            (5000, 0.10m),\n            (10000, 0.15m)\n        };\n    }\n    \n    public decimal CalculateDiscount(decimal originalPrice, Customer customer)\n    {\n        var tier = _tiers.LastOrDefault(t => originalPrice >= t.threshold);\n        return originalPrice * tier.discount;\n    }\n    \n    public string GetDescription() => \"Tiered discount based on purchase amount\";\n}\n\n// Context\npublic class PricingService\n{\n    private readonly Dictionary<string, IDiscountStrategy> _strategies;\n    \n    public PricingService()\n    {\n        _strategies = new Dictionary<string, IDiscountStrategy>\n        {\n            [\"none\"] = new NoDiscountStrategy(),\n            [\"loyalty\"] = new LoyaltyDiscountStrategy(),\n            [\"summer_sale\"] = new PercentageDiscountStrategy(20),\n            [\"bulk\"] = new TieredDiscountStrategy()\n        };\n    }\n    \n    public decimal CalculateFinalPrice(decimal originalPrice, Customer customer, string discountCode)\n    {\n        var strategy = _strategies.GetValueOrDefault(discountCode, _strategies[\"none\"]);\n        var discount = strategy.CalculateDiscount(originalPrice, customer);\n        return originalPrice - discount;\n    }\n}"
    },
    "observer": {
      "description": "Implements event-driven architecture with IObservable and IObserver interfaces.",
      "whenToUse": "When you need to notify multiple objects about state changes.",
      "example": "// Using built-in events\npublic class StockPrice\n{\n    private decimal _price;\n    public string Symbol { get; }\n    \n    public decimal Price\n    {\n        get => _price;\n        set\n        {\n            if (_price != value)\n            {\n                var oldPrice = _price;\n                _price = value;\n                OnPriceChanged(new PriceChangedEventArgs(Symbol, oldPrice, value));\n            }\n        }\n    }\n    \n    public event EventHandler<PriceChangedEventArgs> PriceChanged;\n    \n    public StockPrice(string symbol, decimal initialPrice)\n    {\n        Symbol = symbol;\n        _price = initialPrice;\n    }\n    \n    protected virtual void OnPriceChanged(PriceChangedEventArgs e)\n    {\n        PriceChanged?.Invoke(this, e);\n    }\n}\n\npublic class PriceChangedEventArgs : EventArgs\n{\n    public string Symbol { get; }\n    public decimal OldPrice { get; }\n    public decimal NewPrice { get; }\n    public decimal Change => NewPrice - OldPrice;\n    public decimal ChangePercent => (Change / OldPrice) * 100;\n    \n    public PriceChangedEventArgs(string symbol, decimal oldPrice, decimal newPrice)\n    {\n        Symbol = symbol;\n        OldPrice = oldPrice;\n        NewPrice = newPrice;\n    }\n}\n\n// Using IObservable/IObserver\npublic class TemperatureSensor : IObservable<Temperature>\n{\n    private readonly List<IObserver<Temperature>> _observers = new();\n    private Temperature _currentTemperature;\n    \n    public IDisposable Subscribe(IObserver<Temperature> observer)\n    {\n        if (!_observers.Contains(observer))\n        {\n            _observers.Add(observer);\n            \n            // Send current temperature to new observer\n            if (_currentTemperature != null)\n            {\n                observer.OnNext(_currentTemperature);\n            }\n        }\n        \n        return new Unsubscriber(_observers, observer);\n    }\n    \n    public void UpdateTemperature(double value, string location)\n    {\n        _currentTemperature = new Temperature { Value = value, Location = location, Time = DateTime.Now };\n        \n        foreach (var observer in _observers)\n        {\n            observer.OnNext(_currentTemperature);\n        }\n    }\n    \n    public void EndTransmission()\n    {\n        foreach (var observer in _observers.ToList())\n        {\n            observer.OnCompleted();\n        }\n        _observers.Clear();\n    }\n    \n    private class Unsubscriber : IDisposable\n    {\n        private readonly List<IObserver<Temperature>> _observers;\n        private readonly IObserver<Temperature> _observer;\n        \n        public Unsubscriber(List<IObserver<Temperature>> observers, IObserver<Temperature> observer)\n        {\n            _observers = observers;\n            _observer = observer;\n        }\n        \n        public void Dispose()\n        {\n            if (_observers.Contains(_observer))\n            {\n                _observers.Remove(_observer);\n            }\n        }\n    }\n}\n\npublic class TemperatureDisplay : IObserver<Temperature>\n{\n    private readonly string _name;\n    \n    public TemperatureDisplay(string name)\n    {\n        _name = name;\n    }\n    \n    public void OnNext(Temperature value)\n    {\n        Console.WriteLine($\"{_name}: Temperature at {value.Location} is {value.Value}Â°C at {value.Time}\");\n    }\n    \n    public void OnError(Exception error)\n    {\n        Console.WriteLine($\"{_name}: Error - {error.Message}\");\n    }\n    \n    public void OnCompleted()\n    {\n        Console.WriteLine($\"{_name}: Temperature monitoring completed\");\n    }\n}"
    }
  }
}