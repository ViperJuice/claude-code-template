{
  "language": "clojure",
  "patterns": {
    "protocol": {
      "description": "Defines a set of functions that different types can implement.",
      "whenToUse": "For polymorphism and extending functionality to existing types.",
      "example": ";; Define a protocol\n(defprotocol Drawable\n  \"Protocol for things that can be drawn\"\n  (draw [this] \"Draw the object\")\n  (get-bounds [this] \"Get bounding box\"))\n\n;; Implement for different types\n(defrecord Circle [x y radius]\n  Drawable\n  (draw [this]\n    (println (str \"Drawing circle at (\" x \",\" y \") with radius \" radius)))\n  (get-bounds [this]\n    {:x (- x radius)\n     :y (- y radius)\n     :width (* 2 radius)\n     :height (* 2 radius)}))\n\n(defrecord Rectangle [x y width height]\n  Drawable\n  (draw [this]\n    (println (str \"Drawing rectangle at (\" x \",\" y \") \"\n                  \"with size \" width \"x\" height)))\n  (get-bounds [this]\n    {:x x :y y :width width :height height}))\n\n;; Extend protocol to existing types\n(extend-protocol Drawable\n  String\n  (draw [s] (println (str \"Drawing text: \" s)))\n  (get-bounds [s] {:x 0 :y 0 :width (* 10 (count s)) :height 20})\n  \n  nil\n  (draw [_] (println \"Nothing to draw\"))\n  (get-bounds [_] {:x 0 :y 0 :width 0 :height 0}))\n\n;; Usage\n(def shapes [(->Circle 10 10 5)\n             (->Rectangle 20 20 30 40)\n             \"Hello World\"\n             nil])\n\n(doseq [shape shapes]\n  (draw shape))\n\n;; Protocol with multiple dispatch\n(defprotocol Collision\n  (collides? [this other]))\n\n(extend-protocol Collision\n  Circle\n  (collides? [this other]\n    (cond\n      (instance? Circle other)\n      (let [dx (- (:x this) (:x other))\n            dy (- (:y this) (:y other))\n            distance (Math/sqrt (+ (* dx dx) (* dy dy)))\n            min-distance (+ (:radius this) (:radius other))]\n        (<= distance min-distance))\n      \n      (instance? Rectangle other)\n      ;; Circle-Rectangle collision\n      true ;; Simplified\n      \n      :else false)))\n\n;; Protocol composition\n(defprotocol Moveable\n  (move [this dx dy]))\n\n(defrecord MovingCircle [x y radius]\n  Drawable\n  (draw [this]\n    (println (str \"Drawing moving circle at (\" x \",\" y \")\")))\n  (get-bounds [this]\n    {:x (- x radius) :y (- y radius)\n     :width (* 2 radius) :height (* 2 radius)})\n  \n  Moveable\n  (move [this dx dy]\n    (->MovingCircle (+ x dx) (+ y dy) radius)))"
    },
    "multimethod": {
      "description": "Polymorphic dispatch based on arbitrary dispatch function.",
      "whenToUse": "When you need dispatch based on multiple arguments or complex logic.",
      "example": ";; Simple multimethod\n(defmulti area :shape)\n\n(defmethod area :circle [{:keys [radius]}]\n  (* Math/PI radius radius))\n\n(defmethod area :rectangle [{:keys [width height]}]\n  (* width height))\n\n(defmethod area :triangle [{:keys [base height]}]\n  (/ (* base height) 2))\n\n(defmethod area :default [shape]\n  (throw (ex-info \"Unknown shape\" {:shape shape})))\n\n;; Usage\n(area {:shape :circle :radius 5})\n(area {:shape :rectangle :width 10 :height 20})\n\n;; Multiple dispatch\n(defmulti encounter (fn [x y] [(:species x) (:species y)]))\n\n(defmethod encounter [:bunny :lion] [_ _]\n  :run-away)\n\n(defmethod encounter [:lion :bunny] [_ _]\n  :eat)\n\n(defmethod encounter [:lion :lion] [_ _]\n  :fight)\n\n(defmethod encounter [:bunny :bunny] [_ _]\n  :mate)\n\n(defmethod encounter :default [_ _]\n  :ignore)\n\n;; Hierarchical dispatch\n(derive ::dog ::animal)\n(derive ::cat ::animal)\n(derive ::lion ::cat)\n(derive ::tiger ::cat)\n\n(defmulti sound type)\n\n(defmethod sound ::dog [_] \"Woof!\")\n(defmethod sound ::cat [_] \"Meow!\")\n(defmethod sound ::animal [_] \"Some animal sound\")\n(defmethod sound :default [_] \"Unknown sound\")\n\n;; Complex dispatch function\n(defmulti process-event\n  (fn [event]\n    [(::event-type event)\n     (boolean (::urgent event))\n     (> (::priority event 0) 5)]))\n\n(defmethod process-event [:order true true] [event]\n  (println \"Processing urgent high-priority order:\" event))\n\n(defmethod process-event [:order true false] [event]\n  (println \"Processing urgent low-priority order:\" event))\n\n(defmethod process-event [:order false true] [event]\n  (println \"Processing non-urgent high-priority order:\" event))\n\n(defmethod process-event :default [event]\n  (println \"Processing standard event:\" event))\n\n;; Preference resolution\n(defmulti combine (fn [x y] [(type x) (type y)]))\n\n(defmethod combine [String String] [x y]\n  (str x y))\n\n(defmethod combine [Long Long] [x y]\n  (+ x y))\n\n(defmethod combine [String Long] [x y]\n  (str x y))\n\n(defmethod combine [Long String] [x y]\n  (str x y))\n\n;; Can specify preferences when there's ambiguity\n(prefer-method combine [String Long] [Long String])"
    },
    "atom": {
      "description": "Manages synchronous, uncoordinated state changes.",
      "whenToUse": "For independent state that doesn't need coordination with other state.",
      "example": ";; Basic atom usage\n(def counter (atom 0))\n\n;; Read value\n@counter ; => 0\n(deref counter) ; => 0\n\n;; Update operations\n(swap! counter inc) ; => 1\n(swap! counter + 10) ; => 11\n(reset! counter 0) ; => 0\n\n;; Complex state in atom\n(def app-state (atom {:users {}\n                      :sessions {}\n                      :config {:debug true}}))\n\n;; Update nested state\n(swap! app-state assoc-in [:users 1] {:id 1 :name \"Alice\"})\n(swap! app-state update-in [:users] assoc 2 {:id 2 :name \"Bob\"})\n\n;; Conditional updates\n(def inventory (atom {:items {:apple 10 :orange 5}}))\n\n(defn sell-item [item quantity]\n  (swap! inventory\n         (fn [state]\n           (let [current (get-in state [:items item] 0)]\n             (if (>= current quantity)\n               (update-in state [:items item] - quantity)\n               (throw (ex-info \"Insufficient inventory\"\n                               {:item item\n                                :requested quantity\n                                :available current})))))))\n\n;; Watchers\n(def watched-atom (atom 0))\n\n(add-watch watched-atom :logger\n  (fn [key atom old-state new-state]\n    (println (str \"Atom \" key \" changed from \" old-state \" to \" new-state))))\n\n(swap! watched-atom inc) ; Prints: Atom :logger changed from 0 to 1\n\n;; Remove watcher\n(remove-watch watched-atom :logger)\n\n;; Validators\n(def positive-only (atom 1\n                        :validator pos?))\n\n(swap! positive-only inc) ; => 2\n; (swap! positive-only - 10) ; Throws exception\n\n;; Custom validator\n(def user-atom\n  (atom {:name \"John\" :age 30}\n        :validator (fn [state]\n                    (and (string? (:name state))\n                         (integer? (:age state))\n                         (>= (:age state) 0)))))\n\n;; Atom with metadata\n(def config-atom (atom {:debug true}\n                      :meta {:description \"Application configuration\"}))\n\n;; Compare and swap\n(def cas-atom (atom 0))\n\n(defn increment-if-even [atom]\n  (loop []\n    (let [current @atom]\n      (if (even? current)\n        (if (compare-and-set! atom current (inc current))\n          (inc current)\n          (recur))\n        current))))\n\n;; Derived atoms pattern\n(def source-atom (atom {:x 10 :y 20}))\n(def derived-atom (atom 0))\n\n(add-watch source-atom :update-derived\n  (fn [_ _ _ new-state]\n    (reset! derived-atom (+ (:x new-state) (:y new-state)))))\n\n;; Atom pools for performance\n(def connection-pool\n  (atom {:available [] :in-use #{}}))\n\n(defn acquire-connection []\n  (let [conn (atom nil)]\n    (swap! connection-pool\n           (fn [pool]\n             (if-let [available (first (:available pool))]\n               (do\n                 (reset! conn available)\n                 (-> pool\n                     (update :available rest)\n                     (update :in-use conj available)))\n               pool)))\n    @conn))\n\n(defn release-connection [conn]\n  (swap! connection-pool\n         (fn [pool]\n           (-> pool\n               (update :available conj conn)\n               (update :in-use disj conn)))))"
    },
    "ref": {
      "description": "Manages coordinated, synchronous state changes with STM.",
      "whenToUse": "When multiple pieces of state need to change together transactionally.",
      "example": ";; Bank account example with refs\n(def account1 (ref 1000))\n(def account2 (ref 2000))\n(def transaction-log (ref []))\n\n;; Transfer money transactionally\n(defn transfer [from to amount]\n  (dosync\n    (when (< @from amount)\n      (throw (Exception. \"Insufficient funds\")))\n    (alter from - amount)\n    (alter to + amount)\n    (alter transaction-log conj\n           {:from from :to to :amount amount :time (System/currentTimeMillis)})))\n\n;; Usage\n(transfer account1 account2 300)\n\n;; Commute for commutative operations\n(def counter (ref 0))\n\n(defn increment-counter []\n  (dosync\n    (commute counter inc)))\n\n;; Multiple threads incrementing\n(dorun (pmap (fn [_] (increment-counter)) (range 1000)))\n\n;; Ensure for read consistency\n(defn get-total-balance []\n  (dosync\n    (+ (ensure account1) (ensure account2))))\n\n;; Complex transactional updates\n(def inventory (ref {:apples 100 :oranges 50}))\n(def orders (ref []))\n(def revenue (ref 0.0))\n\n(defn place-order [item quantity price]\n  (dosync\n    (let [current (get @inventory item 0)]\n      (when (< current quantity)\n        (throw (Exception. (str \"Insufficient \" item))))\n      (alter inventory update item - quantity)\n      (alter orders conj {:item item :quantity quantity :price price})\n      (alter revenue + (* quantity price)))))\n\n;; Retry and backoff\n(defn transfer-with-retry [from to amount max-retries]\n  (loop [attempt 1]\n    (try\n      (dosync\n        (Thread/sleep (rand-int 10)) ; Simulate work\n        (alter from - amount)\n        (alter to + amount))\n      (catch Exception e\n        (if (< attempt max-retries)\n          (do\n            (Thread/sleep (* attempt 100)) ; Backoff\n            (recur (inc attempt)))\n          (throw e))))))\n\n;; Ref validators\n(def positive-balance\n  (ref 1000 :validator #(>= % 0)))\n\n;; Nested transactions\n(defn outer-transaction []\n  (dosync\n    (alter account1 + 100)\n    (inner-transaction)))\n\n(defn inner-transaction []\n  (dosync\n    (alter account2 + 200)))\n\n;; Ref history\n(def historical-ref (ref 0 :min-history 10 :max-history 20))\n\n;; Watch refs for changes\n(add-watch account1 :balance-monitor\n  (fn [key ref old new]\n    (println (str \"Account balance changed from \" old \" to \" new))))\n\n;; Coordinated data structures\n(def game-state\n  {:players (ref {})\n   :board (ref [[nil nil nil]\n                [nil nil nil]\n                [nil nil nil]])\n   :current-player (ref :x)})\n\n(defn make-move [player row col]\n  (dosync\n    (let [current @(:current-player game-state)\n          board @(:board game-state)]\n      (when (not= current player)\n        (throw (Exception. \"Not your turn\")))\n      (when (get-in board [row col])\n        (throw (Exception. \"Position occupied\")))\n      (alter (:board game-state) assoc-in [row col] player)\n      (alter (:current-player game-state)\n             #(if (= % :x) :o :x)))))"
    },
    "agent": {
      "description": "Manages asynchronous, uncoordinated state changes.",
      "whenToUse": "For state that changes asynchronously without blocking.",
      "example": ";; Basic agent usage\n(def counter (agent 0))\n\n;; Send actions to agent\n(send counter inc)\n(send counter + 10)\n\n;; Actions are processed asynchronously\n@counter ; May not reflect all changes immediately\n\n;; Await completion\n(await counter) ; Block until all actions complete\n@counter ; => 11\n\n;; Agent for logging\n(def logger (agent []))\n\n(defn log-message [log-entries message]\n  (conj log-entries\n        {:timestamp (System/currentTimeMillis)\n         :message message}))\n\n(send logger log-message \"Application started\")\n(send logger log-message \"User logged in\")\n\n;; Error handling\n(def safe-agent (agent 0))\n\n(defn risky-operation [state value]\n  (if (> value 100)\n    (throw (Exception. \"Value too large\"))\n    (+ state value)))\n\n(send safe-agent risky-operation 50) ; Works\n(send safe-agent risky-operation 200) ; Agent enters error state\n\n;; Check agent errors\n(agent-error safe-agent) ; Returns the exception\n\n;; Clear error and restart\n(restart-agent safe-agent 0)\n\n;; Error handler\n(def resilient-agent\n  (agent 0\n         :error-handler (fn [agent exception]\n                         (println \"Error in agent:\" (.getMessage exception))\n                         (restart-agent agent 0))))\n\n;; Send-off for blocking operations\n(def file-writer (agent nil))\n\n(defn write-to-file [_ data]\n  (spit \"output.txt\" (str data \"\\n\") :append true)\n  :done)\n\n(send-off file-writer write-to-file \"Line 1\")\n(send-off file-writer write-to-file \"Line 2\")\n\n;; Coordinating agents\n(def task-queue (agent []))\n(def results (agent {}))\n\n(defn process-task [queue]\n  (if-let [task (first queue)]\n    (do\n      (send results assoc (:id task) ((:fn task)))\n      (rest queue))\n    queue))\n\n(defn add-task [queue task]\n  (send task-queue process-task)\n  (conj queue task))\n\n;; Agent pools\n(def worker-pool\n  (vec (repeatedly 4 #(agent {:id (gensym) :status :idle}))))\n\n(defn assign-work [worker work]\n  (assoc worker :status :working :task work))\n\n(defn complete-work [worker]\n  (assoc worker :status :idle :task nil))\n\n;; Agent with validation\n(def validated-agent\n  (agent {:balance 1000}\n         :validator #(>= (:balance %) 0)))\n\n;; Watchers on agents\n(def watched-agent (agent {:count 0}))\n\n(add-watch watched-agent :counter-watch\n  (fn [key agent old new]\n    (when (> (:count new) (:count old))\n      (println \"Count increased to\" (:count new)))))\n\n;; Agent-based actor system\n(defn actor [initial-state message-handler]\n  (agent {:state initial-state\n          :handler message-handler}))\n\n(defn send-message [actor message]\n  (send actor\n        (fn [{:keys [state handler] :as actor}]\n          (assoc actor :state (handler state message)))))\n\n;; Example actor\n(def counter-actor\n  (actor 0\n         (fn [state message]\n           (case (:type message)\n             :inc (+ state (:value message 1))\n             :dec (- state (:value message 1))\n             :get state\n             state))))\n\n(send-message counter-actor {:type :inc :value 5})\n(send-message counter-actor {:type :dec :value 2})"
    },
    "transducer": {
      "description": "Composable transformations independent of collection type.",
      "whenToUse": "For efficient, reusable transformations across different contexts.",
      "example": ";; Basic transducers\n(def xf-pipeline\n  (comp\n    (filter even?)\n    (map inc)\n    (take 5)))\n\n;; Apply to different contexts\n(into [] xf-pipeline (range 20)) ; => [1 3 5 7 9]\n(sequence xf-pipeline (range 20)) ; => (1 3 5 7 9)\n(transduce xf-pipeline + (range 20)) ; => 25\n\n;; Custom transducer\n(defn take-while-increasing\n  ([] (take-while-increasing identity))\n  ([keyfn]\n   (fn [rf]\n     (let [prev (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n          (let [k (keyfn input)]\n            (if (or (= @prev ::none)\n                    (> k @prev))\n              (do\n                (vreset! prev k)\n                (rf result input))\n              (reduced result)))))))))\n\n;; Usage\n(sequence (take-while-increasing) [1 2 3 2 4 5]) ; => (1 2 3)\n\n;; Stateful transducers\n(defn distinct-by [keyfn]\n  (fn [rf]\n    (let [seen (volatile! #{})]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n         (let [k (keyfn input)]\n           (if (contains? @seen k)\n             result\n             (do\n               (vswap! seen conj k)\n               (rf result input)))))))))\n\n;; Parallel transducers with core.async\n(require '[clojure.core.async :as async])\n\n(defn parallel-transduce [xform f init coll]\n  (let [c (async/chan 1024 xform)]\n    (async/onto-chan! c coll)\n    (async/<!! (async/reduce f init c))))\n\n;; Transducer with multiple outputs\n(defn split-by [pred]\n  (fn [rf-true rf-false]\n    (fn\n      ([] [(rf-true) (rf-false)])\n      ([[result-true result-false]]\n       [(rf-true result-true) (rf-false result-false)])\n      ([[result-true result-false] input]\n       (if (pred input)\n         [(rf-true result-true input) result-false]\n         [result-true (rf-false result-false input)])))))\n\n;; Early termination\n(defn take-until [pred]\n  (fn [rf]\n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n       (if (pred input)\n         (reduced result)\n         (rf result input))))))\n\n;; Transducer composition\n(def process-numbers\n  (comp\n    (filter number?)\n    (remove zero?)\n    (map #(/ 100 %))\n    (filter #(> % 10))))\n\n;; Efficient string processing\n(def process-lines\n  (comp\n    (map clojure.string/trim)\n    (remove empty?)\n    (map clojure.string/lower-case)\n    (filter #(re-matches #\"^[a-z]+$\" %))\n    (map #(hash-map :word % :length (count %)))))\n\n;; Transducers with context\n(defn running-average []\n  (fn [rf]\n    (let [sum (volatile! 0)\n          count (volatile! 0)]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n         (vswap! sum + input)\n         (vswap! count inc)\n         (rf result (/ @sum @count)))))))\n\n;; Complex pipeline\n(def analytics-pipeline\n  (comp\n    (filter :active)\n    (map :score)\n    (filter pos?)\n    (take 100)\n    (map #(Math/log %))\n    (running-average)))\n\n;; Into with transducers\n(into {}\n      (comp\n        (filter (fn [[k v]] (even? v)))\n        (map (fn [[k v]] [k (* v 2)])))\n      {:a 1 :b 2 :c 3 :d 4})"
    },
    "middleware": {
      "description": "Wraps functions to add cross-cutting concerns.",
      "whenToUse": "For adding logging, validation, caching, etc. to functions.",
      "example": ";; Basic middleware pattern\n(defn wrap-logging [handler]\n  (fn [& args]\n    (println \"Calling with args:\" args)\n    (let [result (apply handler args)]\n      (println \"Result:\" result)\n      result)))\n\n(def logged-+ (wrap-logging +))\n(logged-+ 1 2 3) ; Prints logs and returns 6\n\n;; Ring-style middleware\n(defn wrap-authentication [handler]\n  (fn [request]\n    (if-let [user (get-in request [:session :user])]\n      (handler (assoc request :user user))\n      {:status 401\n       :body \"Unauthorized\"})))\n\n(defn wrap-json-response [handler]\n  (fn [request]\n    (let [response (handler request)]\n      (if (map? (:body response))\n        (-> response\n            (assoc-in [:headers \"Content-Type\"] \"application/json\")\n            (update :body json/write-str))\n        response))))\n\n(defn wrap-exception-handling [handler]\n  (fn [request]\n    (try\n      (handler request)\n      (catch Exception e\n        {:status 500\n         :body {:error (.getMessage e)}}))))\n\n;; Composing middleware\n(def app\n  (-> handler\n      wrap-json-response\n      wrap-authentication\n      wrap-exception-handling))\n\n;; Parameterized middleware\n(defn wrap-rate-limit [handler limit window-ms]\n  (let [requests (atom {})]\n    (fn [request]\n      (let [ip (:remote-addr request)\n            now (System/currentTimeMillis)\n            clean-cutoff (- now window-ms)]\n        ;; Clean old entries\n        (swap! requests\n               (fn [reqs]\n                 (into {}\n                       (filter (fn [[_ timestamps]]\n                                (some #(> % clean-cutoff) timestamps))\n                               reqs))))\n        ;; Check rate limit\n        (let [timestamps (get @requests ip [])\n              recent (filter #(> % clean-cutoff) timestamps)]\n          (if (>= (count recent) limit)\n            {:status 429\n             :body \"Rate limit exceeded\"}\n            (do\n              (swap! requests update ip conj now)\n              (handler request))))))))\n\n;; Timing middleware\n(defn wrap-timing [handler]\n  (fn [& args]\n    (let [start (System/nanoTime)\n          result (apply handler args)\n          duration (/ (- (System/nanoTime) start) 1e6)]\n      (with-meta result\n                 {:duration-ms duration}))))\n\n;; Caching middleware\n(defn wrap-cache [handler ttl-ms]\n  (let [cache (atom {})]\n    (fn [& args]\n      (let [key args\n            now (System/currentTimeMillis)\n            cached (get @cache key)]\n        (if (and cached\n                 (< (- now (:timestamp cached)) ttl-ms))\n          (:value cached)\n          (let [result (apply handler args)]\n            (swap! cache assoc key {:value result\n                                   :timestamp now})\n            result))))))\n\n;; Validation middleware\n(defn wrap-validation [handler schema]\n  (fn [data]\n    (if-let [errors (validate schema data)]\n      (throw (ex-info \"Validation failed\" {:errors errors}))\n      (handler data))))\n\n;; Async middleware\n(defn wrap-async [handler]\n  (fn [& args]\n    (future (apply handler args))))\n\n;; Retry middleware\n(defn wrap-retry [handler max-attempts delay-ms]\n  (fn [& args]\n    (loop [attempt 1]\n      (try\n        (apply handler args)\n        (catch Exception e\n          (if (< attempt max-attempts)\n            (do\n              (Thread/sleep delay-ms)\n              (recur (inc attempt)))\n            (throw e)))))))\n\n;; Context middleware\n(def ^:dynamic *request-context* {})\n\n(defn wrap-context [handler]\n  (fn [request]\n    (binding [*request-context* {:request-id (java.util.UUID/randomUUID)\n                                 :timestamp (System/currentTimeMillis)\n                                 :user (:user request)}]\n      (handler request))))"
    },
    "core_async": {
      "description": "CSP-style concurrent programming with channels.",
      "whenToUse": "For managing concurrent operations and communication between processes.",
      "example": "(require '[clojure.core.async :as async :refer [go go-loop chan <! >! <!! >!! put! take! close! alts!]])\n\n;; Basic channel usage\n(def ch (chan))\n\n;; Put and take\n(go (>! ch \"Hello\"))\n(go (println \"Received:\" (<! ch)))\n\n;; Buffered channels\n(def buffered-ch (chan 10))\n\n;; Dropping buffer\n(def dropping-ch (chan (async/dropping-buffer 10)))\n\n;; Sliding buffer\n(def sliding-ch (chan (async/sliding-buffer 10)))\n\n;; Go blocks and loops\n(defn worker [in out]\n  (go-loop []\n    (when-let [value (<! in)]\n      (>! out (* value 2))\n      (recur))))\n\n;; Pipeline\n(defn pipeline-example []\n  (let [in (chan)\n        out (chan)]\n    (async/pipeline 4 out (map #(* % %)) in)\n    in))\n\n;; Pub/Sub\n(def pub-ch (chan))\n(def publication (async/pub pub-ch :topic))\n\n(def subscriber-1 (chan))\n(def subscriber-2 (chan))\n\n(async/sub publication :news subscriber-1)\n(async/sub publication :sports subscriber-2)\n\n(put! pub-ch {:topic :news :content \"Breaking news!\"})\n(put! pub-ch {:topic :sports :content \"Game results\"})\n\n;; Timeout channels\n(go\n  (let [result (alts! [(async/timeout 1000)\n                      (go (<! (async/timeout 2000)) :completed)])]\n    (println \"First to complete:\" result)))\n\n;; Channel operations with alts!\n(defn non-blocking-take [ch]\n  (let [[value channel] (alts! [ch (async/timeout 100)])]\n    (if (= channel ch)\n      value\n      :timeout)))\n\n;; Merge channels\n(def merged (async/merge [(chan) (chan) (chan)]))\n\n;; Split channel\n(def split-ch (chan))\n(def [even-ch odd-ch] (async/split even? split-ch))\n\n;; Complex async coordination\n(defn fetch-urls [urls]\n  (let [results-ch (chan)]\n    (doseq [url urls]\n      (go\n        (let [result (<! (async/thread\n                          ;; Simulate HTTP request\n                          (Thread/sleep (rand-int 1000))\n                          {:url url :data (str \"Data from \" url)}))]\n          (>! results-ch result))))\n    results-ch))\n\n(defn collect-results [ch n]\n  (go-loop [results []]\n    (if (= (count results) n)\n      results\n      (recur (conj results (<! ch))))))\n\n;; Rate limiting with channels\n(defn rate-limiter [rate-per-second]\n  (let [ch (chan)]\n    (go-loop []\n      (<! (async/timeout (/ 1000 rate-per-second)))\n      (>! ch :token)\n      (recur))\n    ch))\n\n(defn rate-limited-process [rate-limiter work-fn items]\n  (go-loop [items items]\n    (when-let [item (first items)]\n      (<! rate-limiter)\n      (work-fn item)\n      (recur (rest items)))))\n\n;; Error handling in channels\n(defn safe-process [in-ch out-ch process-fn]\n  (go-loop []\n    (when-let [value (<! in-ch)]\n      (try\n        (>! out-ch (process-fn value))\n        (catch Exception e\n          (>! out-ch {:error (.getMessage e) :value value})))\n      (recur))))\n\n;; Channel transformations\n(def xform-ch (chan 10 (comp (filter even?)\n                             (map #(* % 2))\n                             (take 5))))\n\n;; Async coordination patterns\n(defn fan-out [in-ch out-chs]\n  (go-loop []\n    (when-let [value (<! in-ch)]\n      (doseq [out out-chs]\n        (>! out value))\n      (recur))))\n\n(defn fan-in [in-chs out-ch]\n  (async/merge in-chs out-ch))"
    }
  }
}