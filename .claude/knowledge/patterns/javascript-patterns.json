{
  "language": "javascript",
  "patterns": {
    "module": {
      "description": "Encapsulates code and creates private/public members using closures.",
      "whenToUse": "When you need to organize code with private state and public API.",
      "example": "// IIFE Module Pattern\nconst UserModule = (function() {\n  // Private variables\n  let users = [];\n  \n  // Private function\n  function validateEmail(email) {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n  \n  // Public API\n  return {\n    addUser: function(user) {\n      if (validateEmail(user.email)) {\n        users.push(user);\n        return true;\n      }\n      return false;\n    },\n    \n    getUser: function(id) {\n      return users.find(u => u.id === id);\n    },\n    \n    getAllUsers: function() {\n      return [...users]; // Return copy to prevent external modification\n    }\n  };\n})();\n\n// ES6 Module Pattern\nexport const ApiModule = (() => {\n  const BASE_URL = 'https://api.example.com';\n  let authToken = null;\n  \n  const setToken = (token) => {\n    authToken = token;\n  };\n  \n  const get = async (endpoint) => {\n    const response = await fetch(`${BASE_URL}${endpoint}`, {\n      headers: authToken ? { Authorization: `Bearer ${authToken}` } : {}\n    });\n    return response.json();\n  };\n  \n  const post = async (endpoint, data) => {\n    const response = await fetch(`${BASE_URL}${endpoint}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        ...(authToken && { Authorization: `Bearer ${authToken}` })\n      },\n      body: JSON.stringify(data)\n    });\n    return response.json();\n  };\n  \n  return { setToken, get, post };\n})();"
    },
    "revealing_module": {
      "description": "Variation of module pattern that clearly defines public interface at the end.",
      "whenToUse": "When you want cleaner syntax and clear separation of public/private members.",
      "example": "const Calculator = (function() {\n  let result = 0;\n  let history = [];\n  \n  function add(x) {\n    result += x;\n    logOperation('add', x);\n  }\n  \n  function subtract(x) {\n    result -= x;\n    logOperation('subtract', x);\n  }\n  \n  function multiply(x) {\n    result *= x;\n    logOperation('multiply', x);\n  }\n  \n  function divide(x) {\n    if (x !== 0) {\n      result /= x;\n      logOperation('divide', x);\n    } else {\n      throw new Error('Division by zero');\n    }\n  }\n  \n  function logOperation(operation, value) {\n    history.push({\n      operation,\n      value,\n      result,\n      timestamp: new Date()\n    });\n  }\n  \n  function getResult() {\n    return result;\n  }\n  \n  function getHistory() {\n    return [...history];\n  }\n  \n  function reset() {\n    result = 0;\n    history = [];\n  }\n  \n  // Reveal public interface\n  return {\n    add: add,\n    subtract: subtract,\n    multiply: multiply,\n    divide: divide,\n    getResult: getResult,\n    getHistory: getHistory,\n    reset: reset\n  };\n})();"
    },
    "singleton": {
      "description": "Ensures only one instance of an object exists throughout the application.",
      "whenToUse": "When you need a single point of access to shared resources or configuration.",
      "example": "// Class-based Singleton\nclass Database {\n  constructor() {\n    if (Database.instance) {\n      return Database.instance;\n    }\n    \n    this.connection = null;\n    Database.instance = this;\n  }\n  \n  connect(connectionString) {\n    if (!this.connection) {\n      console.log('Creating new database connection...');\n      this.connection = { connectionString, connected: true };\n    }\n    return this.connection;\n  }\n  \n  disconnect() {\n    if (this.connection) {\n      this.connection.connected = false;\n      this.connection = null;\n    }\n  }\n}\n\n// Closure-based Singleton\nconst ConfigManager = (function() {\n  let instance;\n  \n  function createInstance() {\n    const config = new Map();\n    \n    return {\n      set(key, value) {\n        config.set(key, value);\n      },\n      \n      get(key) {\n        return config.get(key);\n      },\n      \n      has(key) {\n        return config.has(key);\n      },\n      \n      remove(key) {\n        return config.delete(key);\n      },\n      \n      clear() {\n        config.clear();\n      }\n    };\n  }\n  \n  return {\n    getInstance() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// ES6 Module Singleton (modules are singletons by default)\nlet instance = null;\n\nclass Logger {\n  constructor() {\n    if (instance) {\n      return instance;\n    }\n    \n    this.logs = [];\n    instance = this;\n  }\n  \n  log(message, level = 'info') {\n    const entry = {\n      message,\n      level,\n      timestamp: new Date().toISOString()\n    };\n    this.logs.push(entry);\n    console.log(`[${entry.level.toUpperCase()}] ${entry.timestamp}: ${message}`);\n  }\n  \n  getLogs() {\n    return [...this.logs];\n  }\n}\n\nexport default new Logger();"
    },
    "factory": {
      "description": "Creates objects without specifying their exact type.",
      "whenToUse": "When object creation is complex or needs to be decided at runtime.",
      "example": "// Simple Factory\nclass Car {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n    this.type = 'car';\n  }\n  \n  drive() {\n    console.log(`Driving ${this.make} ${this.model}`);\n  }\n}\n\nclass Truck {\n  constructor(make, model, capacity) {\n    this.make = make;\n    this.model = model;\n    this.capacity = capacity;\n    this.type = 'truck';\n  }\n  \n  drive() {\n    console.log(`Driving ${this.make} ${this.model} truck with ${this.capacity} capacity`);\n  }\n}\n\nclass Motorcycle {\n  constructor(make, model) {\n    this.make = make;\n    this.model = model;\n    this.type = 'motorcycle';\n  }\n  \n  drive() {\n    console.log(`Riding ${this.make} ${this.model}`);\n  }\n}\n\nconst VehicleFactory = {\n  createVehicle(type, ...args) {\n    switch (type) {\n      case 'car':\n        return new Car(...args);\n      case 'truck':\n        return new Truck(...args);\n      case 'motorcycle':\n        return new Motorcycle(...args);\n      default:\n        throw new Error(`Unknown vehicle type: ${type}`);\n    }\n  }\n};\n\n// Factory with configuration\nclass NotificationFactory {\n  static createNotification(type, options) {\n    const notificationTypes = {\n      email: EmailNotification,\n      sms: SMSNotification,\n      push: PushNotification\n    };\n    \n    const NotificationClass = notificationTypes[type];\n    if (!NotificationClass) {\n      throw new Error(`Unknown notification type: ${type}`);\n    }\n    \n    return new NotificationClass(options);\n  }\n}\n\nclass EmailNotification {\n  constructor({ to, subject, body }) {\n    this.to = to;\n    this.subject = subject;\n    this.body = body;\n  }\n  \n  send() {\n    console.log(`Sending email to ${this.to}: ${this.subject}`);\n  }\n}\n\nclass SMSNotification {\n  constructor({ phoneNumber, message }) {\n    this.phoneNumber = phoneNumber;\n    this.message = message;\n  }\n  \n  send() {\n    console.log(`Sending SMS to ${this.phoneNumber}: ${this.message}`);\n  }\n}"
    },
    "observer": {
      "description": "Allows objects to notify multiple observers about state changes.",
      "whenToUse": "When you need loose coupling between objects that need to stay synchronized.",
      "example": "// Event Emitter Pattern\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n    \n    // Return unsubscribe function\n    return () => this.off(event, listener);\n  }\n  \n  off(event, listenerToRemove) {\n    if (!this.events[event]) return;\n    \n    this.events[event] = this.events[event].filter(\n      listener => listener !== listenerToRemove\n    );\n  }\n  \n  emit(event, ...args) {\n    if (!this.events[event]) return;\n    \n    this.events[event].forEach(listener => {\n      listener.apply(this, args);\n    });\n  }\n  \n  once(event, listener) {\n    const onceWrapper = (...args) => {\n      listener.apply(this, args);\n      this.off(event, onceWrapper);\n    };\n    this.on(event, onceWrapper);\n  }\n}\n\n// Observable Subject\nclass Subject {\n  constructor() {\n    this.observers = [];\n  }\n  \n  subscribe(observer) {\n    this.observers.push(observer);\n    \n    // Return unsubscribe function\n    return {\n      unsubscribe: () => {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n          this.observers.splice(index, 1);\n        }\n      }\n    };\n  }\n  \n  notify(data) {\n    this.observers.forEach(observer => {\n      if (typeof observer === 'function') {\n        observer(data);\n      } else if (observer.update) {\n        observer.update(data);\n      }\n    });\n  }\n}\n\n// Concrete usage example\nclass StockPrice extends Subject {\n  constructor(symbol) {\n    super();\n    this.symbol = symbol;\n    this.price = 0;\n  }\n  \n  setPrice(price) {\n    this.price = price;\n    this.notify({ symbol: this.symbol, price });\n  }\n}\n\nclass StockDisplay {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  update({ symbol, price }) {\n    console.log(`${this.name}: ${symbol} is now $${price}`);\n  }\n}"
    },
    "decorator": {
      "description": "Dynamically adds new functionality to objects without modifying their structure.",
      "whenToUse": "When you want to add features to objects in a flexible, composable way.",
      "example": "// Function decorator\nfunction measureTime(fn) {\n  return function(...args) {\n    const start = performance.now();\n    const result = fn.apply(this, args);\n    const end = performance.now();\n    console.log(`${fn.name} took ${end - start}ms`);\n    return result;\n  };\n}\n\nfunction memoize(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Returning cached result');\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Decorator with configuration\nfunction retry(attempts = 3, delay = 1000) {\n  return function(fn) {\n    return async function(...args) {\n      let lastError;\n      \n      for (let i = 0; i < attempts; i++) {\n        try {\n          return await fn.apply(this, args);\n        } catch (error) {\n          lastError = error;\n          console.log(`Attempt ${i + 1} failed, retrying...`);\n          if (i < attempts - 1) {\n            await new Promise(resolve => setTimeout(resolve, delay));\n          }\n        }\n      }\n      \n      throw lastError;\n    };\n  };\n}\n\n// Object decorator pattern\nclass Coffee {\n  constructor() {\n    this.description = 'Simple coffee';\n    this.cost = 10;\n  }\n  \n  getDescription() {\n    return this.description;\n  }\n  \n  getCost() {\n    return this.cost;\n  }\n}\n\nclass CoffeeDecorator {\n  constructor(coffee) {\n    this.coffee = coffee;\n  }\n  \n  getDescription() {\n    return this.coffee.getDescription();\n  }\n  \n  getCost() {\n    return this.coffee.getCost();\n  }\n}\n\nclass MilkDecorator extends CoffeeDecorator {\n  getDescription() {\n    return `${super.getDescription()}, with milk`;\n  }\n  \n  getCost() {\n    return super.getCost() + 2;\n  }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n  getDescription() {\n    return `${super.getDescription()}, with sugar`;\n  }\n  \n  getCost() {\n    return super.getCost() + 1;\n  }\n}"
    },
    "prototype": {
      "description": "Creates objects by cloning existing objects (prototypes).",
      "whenToUse": "When creating objects is expensive or when you need object inheritance.",
      "example": "// Prototype pattern using Object.create\nconst vehiclePrototype = {\n  init(make, model) {\n    this.make = make;\n    this.model = model;\n    return this;\n  },\n  \n  clone() {\n    return Object.create(this);\n  },\n  \n  getInfo() {\n    return `${this.make} ${this.model}`;\n  }\n};\n\n// Create instances\nconst car1 = Object.create(vehiclePrototype).init('Toyota', 'Camry');\nconst car2 = car1.clone().init('Honda', 'Accord');\n\n// Constructor function with prototype\nfunction Shape(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nShape.prototype.move = function(dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nShape.prototype.clone = function() {\n  return new this.constructor(this.x, this.y);\n};\n\nfunction Circle(x, y, radius) {\n  Shape.call(this, x, y);\n  this.radius = radius;\n}\n\nCircle.prototype = Object.create(Shape.prototype);\nCircle.prototype.constructor = Circle;\n\nCircle.prototype.area = function() {\n  return Math.PI * this.radius * this.radius;\n};\n\n// ES6 Class-based prototype\nclass Animal {\n  constructor(name, species) {\n    this.name = name;\n    this.species = species;\n  }\n  \n  clone() {\n    return new this.constructor(this.name, this.species);\n  }\n  \n  speak() {\n    console.log(`${this.name} makes a sound`);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name, 'Canine');\n    this.breed = breed;\n  }\n  \n  clone() {\n    return new Dog(this.name, this.breed);\n  }\n  \n  speak() {\n    console.log(`${this.name} barks`);\n  }\n}"
    },
    "iterator": {
      "description": "Provides a way to access elements of a collection sequentially.",
      "whenToUse": "When you need to traverse complex data structures uniformly.",
      "example": "// Iterator using Symbol.iterator\nclass Range {\n  constructor(start, end, step = 1) {\n    this.start = start;\n    this.end = end;\n    this.step = step;\n  }\n  \n  [Symbol.iterator]() {\n    let current = this.start;\n    const { end, step } = this;\n    \n    return {\n      next() {\n        if (current <= end) {\n          const value = current;\n          current += step;\n          return { value, done: false };\n        }\n        return { done: true };\n      }\n    };\n  }\n}\n\n// Usage: for (const num of new Range(1, 10, 2)) { console.log(num); }\n\n// Tree iterator\nclass TreeNode {\n  constructor(value, children = []) {\n    this.value = value;\n    this.children = children;\n  }\n  \n  *[Symbol.iterator]() {\n    yield this.value;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n}\n\n// Custom collection with iterator\nclass TodoList {\n  constructor() {\n    this.todos = [];\n  }\n  \n  add(todo) {\n    this.todos.push({\n      id: Date.now(),\n      text: todo,\n      completed: false,\n      createdAt: new Date()\n    });\n  }\n  \n  *[Symbol.iterator]() {\n    for (const todo of this.todos) {\n      yield todo;\n    }\n  }\n  \n  *completed() {\n    for (const todo of this.todos) {\n      if (todo.completed) {\n        yield todo;\n      }\n    }\n  }\n  \n  *pending() {\n    for (const todo of this.todos) {\n      if (!todo.completed) {\n        yield todo;\n      }\n    }\n  }\n}\n\n// Async iterator\nclass AsyncDataFetcher {\n  constructor(urls) {\n    this.urls = urls;\n  }\n  \n  async *[Symbol.asyncIterator]() {\n    for (const url of this.urls) {\n      const response = await fetch(url);\n      const data = await response.json();\n      yield data;\n    }\n  }\n}"
    }
  }
}