{
  "language": "java",
  "patterns": {
    "singleton": {
      "description": "Ensures a class has only one instance and provides global access to it.",
      "whenToUse": "When exactly one instance is needed (configuration, logging, database connections).",
      "example": "// Thread-safe Singleton with lazy initialization\npublic class DatabaseConnection {\n    private static volatile DatabaseConnection instance;\n    private Connection connection;\n    \n    private DatabaseConnection() {\n        // Private constructor prevents instantiation\n    }\n    \n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            synchronized (DatabaseConnection.class) {\n                if (instance == null) {\n                    instance = new DatabaseConnection();\n                }\n            }\n        }\n        return instance;\n    }\n    \n    public Connection getConnection() {\n        return connection;\n    }\n}\n\n// Enum Singleton (recommended approach)\npublic enum ConfigManager {\n    INSTANCE;\n    \n    private final Map<String, String> config = new HashMap<>();\n    \n    public void setProperty(String key, String value) {\n        config.put(key, value);\n    }\n    \n    public String getProperty(String key) {\n        return config.get(key);\n    }\n}\n\n// Bill Pugh Singleton\npublic class Logger {\n    private Logger() {}\n    \n    private static class SingletonHelper {\n        private static final Logger INSTANCE = new Logger();\n    }\n    \n    public static Logger getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n    \n    public void log(String message) {\n        System.out.println(\"[\" + new Date() + \"] \" + message);\n    }\n}"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes.",
      "whenToUse": "When object creation logic is complex or needs to be decided at runtime.",
      "example": "// Factory Method Pattern\npublic interface Vehicle {\n    void drive();\n    String getType();\n}\n\npublic class Car implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Driving a car\");\n    }\n    \n    @Override\n    public String getType() {\n        return \"Car\";\n    }\n}\n\npublic class Motorcycle implements Vehicle {\n    @Override\n    public void drive() {\n        System.out.println(\"Riding a motorcycle\");\n    }\n    \n    @Override\n    public String getType() {\n        return \"Motorcycle\";\n    }\n}\n\npublic class VehicleFactory {\n    public static Vehicle createVehicle(String type) {\n        switch (type.toLowerCase()) {\n            case \"car\":\n                return new Car();\n            case \"motorcycle\":\n                return new Motorcycle();\n            default:\n                throw new IllegalArgumentException(\"Unknown vehicle type: \" + type);\n        }\n    }\n}\n\n// Abstract Factory Pattern\npublic interface UIFactory {\n    Button createButton();\n    TextField createTextField();\n}\n\npublic interface Button {\n    void render();\n}\n\npublic interface TextField {\n    void render();\n}\n\npublic class WindowsUIFactory implements UIFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n    \n    @Override\n    public TextField createTextField() {\n        return new WindowsTextField();\n    }\n}\n\npublic class MacUIFactory implements UIFactory {\n    @Override\n    public Button createButton() {\n        return new MacButton();\n    }\n    \n    @Override\n    public TextField createTextField() {\n        return new MacTextField();\n    }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step with a fluent interface.",
      "whenToUse": "When creating objects with many optional parameters or complex initialization.",
      "example": "// Classic Builder Pattern\npublic class User {\n    private final String firstName;\n    private final String lastName;\n    private final int age;\n    private final String email;\n    private final String phone;\n    private final String address;\n    \n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.email = builder.email;\n        this.phone = builder.phone;\n        this.address = builder.address;\n    }\n    \n    public static class UserBuilder {\n        // Required parameters\n        private final String firstName;\n        private final String lastName;\n        \n        // Optional parameters\n        private int age = 0;\n        private String email = \"\";\n        private String phone = \"\";\n        private String address = \"\";\n        \n        public UserBuilder(String firstName, String lastName) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n        }\n        \n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n        \n        public UserBuilder email(String email) {\n            this.email = email;\n            return this;\n        }\n        \n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n        \n        public UserBuilder address(String address) {\n            this.address = address;\n            return this;\n        }\n        \n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Lombok-style Builder (using annotations)\n@Builder\n@Data\npublic class Product {\n    private final String id;\n    private final String name;\n    private final BigDecimal price;\n    @Builder.Default\n    private final String category = \"General\";\n    private final String description;\n}\n\n// Usage: User user = new User.UserBuilder(\"John\", \"Doe\")\n//                     .age(30)\n//                     .email(\"john@example.com\")\n//                     .build();"
    },
    "observer": {
      "description": "Defines a one-to-many dependency between objects for event notification.",
      "whenToUse": "When changes to one object require updating multiple dependent objects.",
      "example": "// Observer interface\npublic interface Observer {\n    void update(String event, Object data);\n}\n\n// Subject interface\npublic interface Subject {\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers(String event, Object data);\n}\n\n// Concrete Subject\npublic class StockPrice implements Subject {\n    private final List<Observer> observers = new ArrayList<>();\n    private final String symbol;\n    private double price;\n    \n    public StockPrice(String symbol) {\n        this.symbol = symbol;\n    }\n    \n    @Override\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    @Override\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers(String event, Object data) {\n        for (Observer observer : observers) {\n            observer.update(event, data);\n        }\n    }\n    \n    public void setPrice(double price) {\n        this.price = price;\n        notifyObservers(\"price_changed\", new PriceData(symbol, price));\n    }\n}\n\n// Using Java's built-in Observer (deprecated but still used)\npublic class NewsAgency extends Observable {\n    private String news;\n    \n    public void setNews(String news) {\n        this.news = news;\n        setChanged();\n        notifyObservers(news);\n    }\n}\n\npublic class NewsChannel implements java.util.Observer {\n    private String news;\n    \n    @Override\n    public void update(Observable o, Object news) {\n        this.news = (String) news;\n        System.out.println(\"News updated: \" + this.news);\n    }\n}\n\n// Modern approach using PropertyChangeListener\npublic class PropertyObservable {\n    private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n    private String property;\n    \n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        support.addPropertyChangeListener(listener);\n    }\n    \n    public void removePropertyChangeListener(PropertyChangeListener listener) {\n        support.removePropertyChangeListener(listener);\n    }\n    \n    public void setProperty(String value) {\n        String oldValue = this.property;\n        this.property = value;\n        support.firePropertyChange(\"property\", oldValue, value);\n    }\n}"
    },
    "strategy": {
      "description": "Defines a family of algorithms and makes them interchangeable.",
      "whenToUse": "When you have multiple algorithms for a specific task and want to switch between them.",
      "example": "// Strategy interface\npublic interface PaymentStrategy {\n    boolean pay(double amount);\n}\n\n// Concrete strategies\npublic class CreditCardPayment implements PaymentStrategy {\n    private final String cardNumber;\n    private final String cvv;\n    private final String expiryDate;\n    \n    public CreditCardPayment(String cardNumber, String cvv, String expiryDate) {\n        this.cardNumber = cardNumber;\n        this.cvv = cvv;\n        this.expiryDate = expiryDate;\n    }\n    \n    @Override\n    public boolean pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" using Credit Card\");\n        return true;\n    }\n}\n\npublic class PayPalPayment implements PaymentStrategy {\n    private final String email;\n    private final String password;\n    \n    public PayPalPayment(String email, String password) {\n        this.email = email;\n        this.password = password;\n    }\n    \n    @Override\n    public boolean pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" using PayPal\");\n        return true;\n    }\n}\n\n// Context\npublic class ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    private final List<Item> items = new ArrayList<>();\n    \n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    public void addItem(Item item) {\n        items.add(item);\n    }\n    \n    public boolean checkout() {\n        double total = calculateTotal();\n        return paymentStrategy.pay(total);\n    }\n    \n    private double calculateTotal() {\n        return items.stream()\n                   .mapToDouble(Item::getPrice)\n                   .sum();\n    }\n}\n\n// Using functional interfaces (Java 8+)\n@FunctionalInterface\npublic interface SortingStrategy<T extends Comparable<T>> {\n    void sort(List<T> list);\n}\n\npublic class Sorter<T extends Comparable<T>> {\n    private SortingStrategy<T> strategy;\n    \n    public void setStrategy(SortingStrategy<T> strategy) {\n        this.strategy = strategy;\n    }\n    \n    public void sort(List<T> list) {\n        strategy.sort(list);\n    }\n}\n\n// Usage with lambda\nSorter<Integer> sorter = new Sorter<>();\nsorter.setStrategy(list -> Collections.sort(list)); // Quick sort\nsorter.setStrategy(list -> list.sort(Comparator.reverseOrder())); // Reverse sort"
    },
    "decorator": {
      "description": "Adds new functionality to objects dynamically without altering their structure.",
      "whenToUse": "When you want to add responsibilities to objects dynamically and transparently.",
      "example": "// Component interface\npublic interface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete component\npublic class SimpleCoffee implements Coffee {\n    @Override\n    public String getDescription() {\n        return \"Simple coffee\";\n    }\n    \n    @Override\n    public double getCost() {\n        return 2.0;\n    }\n}\n\n// Decorator abstract class\npublic abstract class CoffeeDecorator implements Coffee {\n    protected final Coffee coffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n    \n    @Override\n    public String getDescription() {\n        return coffee.getDescription();\n    }\n    \n    @Override\n    public double getCost() {\n        return coffee.getCost();\n    }\n}\n\n// Concrete decorators\npublic class MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return super.getDescription() + \", with milk\";\n    }\n    \n    @Override\n    public double getCost() {\n        return super.getCost() + 0.5;\n    }\n}\n\npublic class SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return super.getDescription() + \", with sugar\";\n    }\n    \n    @Override\n    public double getCost() {\n        return super.getCost() + 0.2;\n    }\n}\n\n// Usage: Coffee coffee = new MilkDecorator(new SugarDecorator(new SimpleCoffee()));\n\n// Real-world example: InputStream decorators\ntry (BufferedReader reader = new BufferedReader(\n        new InputStreamReader(\n            new FileInputStream(\"file.txt\"), \n            StandardCharsets.UTF_8))) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        System.out.println(line);\n    }\n}"
    },
    "adapter": {
      "description": "Allows incompatible interfaces to work together.",
      "whenToUse": "When you need to use an existing class with an incompatible interface.",
      "example": "// Target interface (what client expects)\npublic interface MediaPlayer {\n    void play(String filename);\n}\n\n// Adaptee (existing incompatible interface)\npublic class AdvancedMediaPlayer {\n    public void playVlc(String filename) {\n        System.out.println(\"Playing vlc file: \" + filename);\n    }\n    \n    public void playMp4(String filename) {\n        System.out.println(\"Playing mp4 file: \" + filename);\n    }\n}\n\n// Adapter\npublic class MediaAdapter implements MediaPlayer {\n    private final AdvancedMediaPlayer advancedPlayer;\n    \n    public MediaAdapter() {\n        this.advancedPlayer = new AdvancedMediaPlayer();\n    }\n    \n    @Override\n    public void play(String filename) {\n        if (filename.endsWith(\".vlc\")) {\n            advancedPlayer.playVlc(filename);\n        } else if (filename.endsWith(\".mp4\")) {\n            advancedPlayer.playMp4(filename);\n        } else {\n            System.out.println(\"Invalid media format\");\n        }\n    }\n}\n\n// Class adapter using inheritance\npublic interface Duck {\n    void quack();\n    void fly();\n}\n\npublic class Turkey {\n    public void gobble() {\n        System.out.println(\"Gobble gobble\");\n    }\n    \n    public void fly() {\n        System.out.println(\"Flying short distance\");\n    }\n}\n\npublic class TurkeyAdapter extends Turkey implements Duck {\n    @Override\n    public void quack() {\n        gobble(); // Adapt gobble to quack\n    }\n    \n    // fly() is inherited from Turkey\n}\n\n// Real-world example: Collections adapter\npublic class EnumerationIterator<E> implements Iterator<E> {\n    private final Enumeration<E> enumeration;\n    \n    public EnumerationIterator(Enumeration<E> enumeration) {\n        this.enumeration = enumeration;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return enumeration.hasMoreElements();\n    }\n    \n    @Override\n    public E next() {\n        return enumeration.nextElement();\n    }\n}"
    },
    "visitor": {
      "description": "Separates algorithms from the objects on which they operate.",
      "whenToUse": "When you need to perform operations on a complex object structure without changing the classes.",
      "example": "// Visitor interface\npublic interface ShapeVisitor {\n    void visit(Circle circle);\n    void visit(Rectangle rectangle);\n    void visit(Triangle triangle);\n}\n\n// Element interface\npublic interface Shape {\n    void accept(ShapeVisitor visitor);\n}\n\n// Concrete elements\npublic class Circle implements Shape {\n    private final double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    public double getRadius() {\n        return radius;\n    }\n    \n    @Override\n    public void accept(ShapeVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n\npublic class Rectangle implements Shape {\n    private final double width;\n    private final double height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    public double getWidth() {\n        return width;\n    }\n    \n    public double getHeight() {\n        return height;\n    }\n    \n    @Override\n    public void accept(ShapeVisitor visitor) {\n        visitor.visit(this);\n    }\n}\n\n// Concrete visitors\npublic class AreaCalculator implements ShapeVisitor {\n    private double totalArea = 0;\n    \n    @Override\n    public void visit(Circle circle) {\n        totalArea += Math.PI * circle.getRadius() * circle.getRadius();\n    }\n    \n    @Override\n    public void visit(Rectangle rectangle) {\n        totalArea += rectangle.getWidth() * rectangle.getHeight();\n    }\n    \n    @Override\n    public void visit(Triangle triangle) {\n        // Calculate triangle area\n    }\n    \n    public double getTotalArea() {\n        return totalArea;\n    }\n}\n\npublic class DrawingVisitor implements ShapeVisitor {\n    @Override\n    public void visit(Circle circle) {\n        System.out.println(\"Drawing circle with radius: \" + circle.getRadius());\n    }\n    \n    @Override\n    public void visit(Rectangle rectangle) {\n        System.out.println(\"Drawing rectangle: \" + rectangle.getWidth() + \"x\" + rectangle.getHeight());\n    }\n    \n    @Override\n    public void visit(Triangle triangle) {\n        System.out.println(\"Drawing triangle\");\n    }\n}\n\n// Usage\nList<Shape> shapes = Arrays.asList(\n    new Circle(5),\n    new Rectangle(10, 20),\n    new Circle(3)\n);\n\nAreaCalculator areaCalc = new AreaCalculator();\nDrawingVisitor drawer = new DrawingVisitor();\n\nfor (Shape shape : shapes) {\n    shape.accept(areaCalc);\n    shape.accept(drawer);\n}"
    }
  }
}