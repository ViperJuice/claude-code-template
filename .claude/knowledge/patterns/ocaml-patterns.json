{
  "language": "ocaml",
  "patterns": {
    "module_type": {
      "description": "Module types (signatures) define interfaces for modules, enabling information hiding and abstraction by specifying which values, types, and submodules are exposed",
      "whenToUse": "Use when you need to hide implementation details, create abstract interfaces, ensure modules conform to specific contracts, or build generic modules with functors",
      "example": "(* Define a module type for a container *)\nmodule type CONTAINER = sig\n  type 'a t\n  val empty : 'a t\n  val add : 'a -> 'a t -> 'a t\n  val mem : 'a -> 'a t -> bool\n  val fold : ('a -> 'b -> 'b) -> 'a t -> 'b -> 'b\nend\n\n(* Implementation with list *)\nmodule ListContainer : CONTAINER = struct\n  type 'a t = 'a list\n  let empty = []\n  let add x xs = x :: xs\n  let mem = List.mem\n  let fold = List.fold_right\nend\n\n(* Implementation with set, hiding internal representation *)\nmodule SetContainer : CONTAINER with type 'a t = 'a list = struct\n  type 'a t = 'a list\n  let empty = []\n  let add x xs = if List.mem x xs then xs else x :: xs\n  let mem = List.mem\n  let fold f xs init = \n    List.fold_right f (List.sort_uniq compare xs) init\nend\n\n(* Abstract type in module signature *)\nmodule type COUNTER = sig\n  type t\n  val create : int -> t\n  val increment : t -> t\n  val decrement : t -> t\n  val value : t -> int\nend\n\nmodule Counter : COUNTER = struct\n  type t = int\n  let create n = n\n  let increment n = n + 1\n  let decrement n = n - 1\n  let value n = n\nend\n\n(* Module type with private type abbreviation *)\nmodule Email : sig\n  type t = private string\n  val create : string -> t option\n  val to_string : t -> string\nend = struct\n  type t = string\n  \n  let create s =\n    if String.contains s '@' then Some s\n    else None\n    \n  let to_string t = t\nend"
    },
    "functor": {
      "description": "Functors are functions from modules to modules, enabling generic programming by parameterizing modules over other modules",
      "whenToUse": "Use when building generic data structures or algorithms that work with different implementations, creating extensible libraries, or implementing dependency injection at the module level",
      "example": "(* Functor for creating ordered data structures *)\nmodule type ORDERED = sig\n  type t\n  val compare : t -> t -> int\nend\n\n(* Functor that creates a set module *)\nmodule MakeSet (Elem : ORDERED) = struct\n  type t = Elem.t list\n  \n  let empty = []\n  \n  let rec add x = function\n    | [] -> [x]\n    | h :: t ->\n        match Elem.compare x h with\n        | 0 -> h :: t  (* Already present *)\n        | n when n < 0 -> x :: h :: t\n        | _ -> h :: add x t\n  \n  let rec mem x = function\n    | [] -> false\n    | h :: t ->\n        match Elem.compare x h with\n        | 0 -> true\n        | n when n < 0 -> false\n        | _ -> mem x t\nend\n\n(* Using the functor *)\nmodule IntOrdered = struct\n  type t = int\n  let compare = compare\nend\n\nmodule IntSet = MakeSet(IntOrdered)\n\n(* Functor with multiple parameters *)\nmodule type MONAD = sig\n  type 'a t\n  val return : 'a -> 'a t\n  val bind : 'a t -> ('a -> 'b t) -> 'b t\nend\n\nmodule type MONAD_PLUS = sig\n  include MONAD\n  val zero : 'a t\n  val plus : 'a t -> 'a t -> 'a t\nend\n\n(* Functor that adds monad operations *)\nmodule MonadOps (M : MONAD) = struct\n  open M\n  \n  let (>>=) = bind\n  \n  let (>>) m1 m2 = m1 >>= fun _ -> m2\n  \n  let map f m = m >>= fun x -> return (f x)\n  \n  let join mm = mm >>= fun m -> m\n  \n  let sequence ms =\n    List.fold_right \n      (fun m acc -> m >>= fun x -> map (fun xs -> x :: xs) acc)\n      ms (return [])\nend\n\n(* Higher-order functor *)\nmodule MakePair (M1 : sig type t end) (M2 : sig type t end) = struct\n  type t = M1.t * M2.t\nend\n\n(* Recursive functor for trees *)\nmodule rec TreeSet : sig\n  type t\n  val empty : t\n  val add : int -> t -> t\n  val mem : int -> t -> bool\nend = struct\n  type t = Empty | Node of int * TreeSet.t * TreeSet.t\n  \n  let empty = Empty\n  \n  let rec add x = function\n    | Empty -> Node (x, Empty, Empty)\n    | Node (y, l, r) ->\n        if x < y then Node (y, add x l, r)\n        else if x > y then Node (y, l, add x r)\n        else Node (y, l, r)\n  \n  let rec mem x = function\n    | Empty -> false\n    | Node (y, l, r) ->\n        if x = y then true\n        else if x < y then mem x l\n        else mem x r\nend"
    },
    "phantom_type": {
      "description": "Phantom types use type parameters that don't appear in the runtime representation to encode additional type-level information and constraints",
      "whenToUse": "Use when you need to enforce compile-time constraints, create type-safe APIs, distinguish between different states or capabilities, or implement type-level programming",
      "example": "(* Phantom types for units of measurement *)\nmodule Units = struct\n  type 'a quantity = float\n  \n  type meters\n  type feet\n  type seconds\n  type meters_per_second\n  \n  let meters x : meters quantity = x\n  let feet x : feet quantity = x\n  let seconds x : seconds quantity = x\n  \n  (* Type-safe operations *)\n  let add : 'a quantity -> 'a quantity -> 'a quantity = (+.)\n  let sub : 'a quantity -> 'a quantity -> 'a quantity = (-.)\n  let mul : 'a quantity -> 'b quantity -> ('a * 'b) quantity = ( *. )\n  let div : ('a * 'b) quantity -> 'b quantity -> 'a quantity = (/.)\n  \n  (* Conversions with proper types *)\n  let feet_to_meters (x : feet quantity) : meters quantity = x *. 0.3048\n  let meters_to_feet (x : meters quantity) : feet quantity = x /. 0.3048\nend\n\n(* Phantom types for state machines *)\nmodule Door = struct\n  type 'a door = unit\n  \n  type opened\n  type closed\n  type locked\n  \n  let create () : closed door = ()\n  \n  let open_door : closed door -> opened door = fun _ -> ()\n  let close_door : opened door -> closed door = fun _ -> ()\n  let lock_door : closed door -> locked door = fun _ -> ()\n  let unlock_door : locked door -> closed door = fun _ -> ()\n  \n  (* These would cause compile errors:\n     let invalid = open_door (lock_door (create ()))\n     let invalid2 = lock_door (open_door (close_door (create ())))\n  *)\nend\n\n(* Phantom types for read/write permissions *)\nmodule File = struct\n  type 'a file = { fd : Unix.file_descr }\n  \n  type read\n  type write\n  type read_write\n  \n  let open_read path : read file = \n    { fd = Unix.openfile path [Unix.O_RDONLY] 0o644 }\n  \n  let open_write path : write file = \n    { fd = Unix.openfile path [Unix.O_WRONLY; Unix.O_CREAT] 0o644 }\n  \n  let open_read_write path : read_write file = \n    { fd = Unix.openfile path [Unix.O_RDWR; Unix.O_CREAT] 0o644 }\n  \n  (* Type-safe operations *)\n  let read : [> read] file -> bytes -> int -> int -> int = \n    fun file buf ofs len -> Unix.read file.fd buf ofs len\n  \n  let write : [> write] file -> bytes -> int -> int -> int = \n    fun file buf ofs len -> Unix.write file.fd buf ofs len\n  \n  let close : 'a file -> unit = fun file -> Unix.close file.fd\nend\n\n(* GADTs as enhanced phantom types *)\ntype _ term =\n  | Int : int -> int term\n  | Bool : bool -> bool term\n  | Add : int term * int term -> int term\n  | Equal : 'a term * 'a term -> bool term\n  | If : bool term * 'a term * 'a term -> 'a term\n\nlet rec eval : type a. a term -> a = function\n  | Int n -> n\n  | Bool b -> b\n  | Add (t1, t2) -> eval t1 + eval t2\n  | Equal (t1, t2) -> eval t1 = eval t2\n  | If (cond, t1, t2) -> if eval cond then eval t1 else eval t2"
    },
    "first_class_module": {
      "description": "First-class modules allow modules to be treated as regular values that can be passed to functions, stored in data structures, and created dynamically",
      "whenToUse": "Use when you need runtime selection of implementations, plugin architectures, dependency injection, or dynamic module composition based on runtime conditions",
      "example": "(* Module type for different strategies *)\nmodule type STRATEGY = sig\n  type t\n  val name : string\n  val compute : t -> int -> int\nend\n\n(* Different implementations *)\nmodule DoubleStrategy = struct\n  type t = unit\n  let name = \"double\"\n  let compute () x = x * 2\nend\n\nmodule SquareStrategy = struct\n  type t = unit\n  let name = \"square\"\n  let compute () x = x * x\nend\n\nmodule IncrementStrategy = struct\n  type t = int\n  let name = \"increment\"\n  let compute n x = x + n\nend\n\n(* Using first-class modules *)\nlet strategies = [\n  (module DoubleStrategy : STRATEGY);\n  (module SquareStrategy : STRATEGY);\n  (module struct\n    type t = int\n    let name = \"custom\"\n    let compute n x = x + n * 10\n  end : STRATEGY)\n]\n\n(* Function taking a first-class module *)\nlet apply_strategy (module S : STRATEGY) (state : S.t) value =\n  Printf.printf \"Using strategy: %s\\n\" S.name;\n  S.compute state value\n\n(* Dynamic selection *)\nlet select_strategy name =\n  List.find (fun (module S : STRATEGY) -> S.name = name) strategies\n\n(* Plugin system example *)\nmodule type PLUGIN = sig\n  val name : string\n  val init : unit -> unit\n  val process : string -> string\n  val cleanup : unit -> unit\nend\n\ntype plugin = (module PLUGIN)\n\nlet loaded_plugins : plugin list ref = ref []\n\nlet register_plugin p = loaded_plugins := p :: !loaded_plugins\n\nlet load_plugin path =\n  (* In real code, this would dynamically load a module *)\n  let plugin = (module struct\n    let name = Filename.basename path\n    let init () = Printf.printf \"Initializing %s\\n\" name\n    let process s = String.uppercase_ascii s\n    let cleanup () = Printf.printf \"Cleaning up %s\\n\" name\n  end : PLUGIN) in\n  register_plugin plugin\n\nlet run_plugins input =\n  List.fold_left (fun acc (module P : PLUGIN) ->\n    P.init ();\n    let result = P.process acc in\n    P.cleanup ();\n    result\n  ) input !loaded_plugins\n\n(* Existential types with first-class modules *)\nmodule type T = sig \n  type t \n  val create : int -> t\n  val get : t -> int\nend\n\ntype packed = Packed : (module T with type t = 'a) * 'a -> packed\n\nlet pack_int n = \n  Packed ((module struct\n    type t = int\n    let create x = x\n    let get x = x\n  end), n)\n\nlet pack_string n =\n  Packed ((module struct\n    type t = string\n    let create x = string_of_int x\n    let get x = int_of_string x\n  end), string_of_int n)\n\nlet unpack (Packed ((module M), v)) = M.get v"
    },
    "gadt": {
      "description": "Generalized Algebraic Data Types (GADTs) allow more precise type information in constructors, enabling type-safe heterogeneous data structures and embedded DSLs",
      "whenToUse": "Use when building type-safe interpreters, heterogeneous lists, deep embeddings of DSLs, or when you need to encode complex type relationships",
      "example": "(* Basic GADT for a typed expression language *)\ntype _ expr =\n  | Int : int -> int expr\n  | Bool : bool -> bool expr\n  | Add : int expr * int expr -> int expr\n  | Equal : 'a expr * 'a expr -> bool expr\n  | If : bool expr * 'a expr * 'a expr -> 'a expr\n\n(* Type-safe evaluator *)\nlet rec eval : type a. a expr -> a = function\n  | Int n -> n\n  | Bool b -> b\n  | Add (e1, e2) -> eval e1 + eval e2\n  | Equal (e1, e2) -> eval e1 = eval e2\n  | If (cond, e1, e2) -> if eval cond then eval e1 else eval e2\n\n(* Heterogeneous list *)\ntype _ hlist =\n  | Nil : unit hlist\n  | Cons : 'a * 'b hlist -> ('a * 'b) hlist\n\nlet rec length : type a. a hlist -> int = function\n  | Nil -> 0\n  | Cons (_, t) -> 1 + length t\n\n(* Type-safe printf *)\ntype (_, _) format =\n  | Int : (int -> 'a, 'a) format\n  | String : (string -> 'a, 'a) format\n  | Lit : string -> ('a, 'a) format\n  | Concat : ('a, 'b) format * ('b, 'c) format -> ('a, 'c) format\n\nlet rec sprintf : type a b. (a, b) format -> a -> b = \n  fun fmt k ->\n    match fmt with\n    | Int -> fun n -> k (string_of_int n)\n    | String -> fun s -> k s\n    | Lit s -> k s\n    | Concat (f1, f2) -> sprintf f1 (fun s1 -> sprintf f2 (fun s2 -> k (s1 ^ s2)))\n\nlet example = sprintf (Concat (Lit \"Hello \", Concat (String, Concat (Lit \", you have \", Concat (Int, Lit \" points\"))))) \"Alice\" 42\n\n(* Type-safe state machine *)\ntype _ state =\n  | Initial : unit state\n  | Connected : string state\n  | Authenticated : (string * int) state\n  | Disconnected : unit state\n\ntype (_, _) transition =\n  | Connect : string -> (unit state, string state) transition\n  | Authenticate : int -> (string state, (string * int) state) transition\n  | Disconnect : ('a state, unit state) transition\n\nlet apply : type a b. a state -> (a state, b state) transition -> b state =\n  fun state trans ->\n    match state, trans with\n    | Initial (), Connect session -> Connected session\n    | Connected session, Authenticate user_id -> Authenticated (session, user_id)\n    | _, Disconnect -> Disconnected ()\n\n(* Type-safe vector with length *)\ntype z = Z\ntype 'n s = S\n\ntype (_, _) vec =\n  | Nil : (z, 'a) vec\n  | Cons : 'a * ('n, 'a) vec -> ('n s, 'a) vec\n\nlet rec length : type n a. (n, a) vec -> int = function\n  | Nil -> 0\n  | Cons (_, t) -> 1 + length t\n\nlet head : type n a. (n s, a) vec -> a = function\n  | Cons (h, _) -> h\n  (* No need for Nil case - type system ensures non-empty *)\n\nlet rec append : type m n a. (m, a) vec -> (n, a) vec -> (?, a) vec = \n  fun v1 v2 ->\n    match v1 with\n    | Nil -> v2\n    | Cons (h, t) -> Cons (h, append t v2)"
    },
    "polymorphic_variant": {
      "description": "Polymorphic variants are more flexible than regular variants, allowing structural subtyping, open types, and code reuse without predeclaring all constructors",
      "whenToUse": "Use when you need flexible, extensible sum types, want to share constructors between types, implement incremental APIs, or avoid dependency cycles",
      "example": "(* Basic polymorphic variants *)\nlet color_to_string = function\n  | `Red -> \"red\"\n  | `Green -> \"green\"\n  | `Blue -> \"blue\"\n  | `RGB (r, g, b) -> Printf.sprintf \"rgb(%d,%d,%d)\" r g b\n\n(* Polymorphic variants enable extensibility *)\nlet extended_color_to_string = function\n  | `Transparent -> \"transparent\"\n  | #color as c -> color_to_string c  (* Include previous cases *)\n\n(* Subtyping with polymorphic variants *)\ntype basic_shape = [`Circle of float | `Square of float]\ntype shape = [`Circle of float | `Square of float | `Rectangle of float * float]\ntype colored_shape = [`Color of string * shape]\n\nlet area : [< shape] -> float = function\n  | `Circle r -> 3.14159 *. r *. r\n  | `Square s -> s *. s\n  | `Rectangle (w, h) -> w *. h\n\n(* Error handling with polymorphic variants *)\nlet parse_int s : (int, [> `Invalid_int of string]) result =\n  try Ok (int_of_string s)\n  with _ -> Error (`Invalid_int s)\n\nlet parse_float s : (float, [> `Invalid_float of string]) result =\n  try Ok (float_of_string s)\n  with _ -> Error (`Invalid_float s)\n\nlet parse_number s =\n  match parse_int s with\n  | Ok n -> Ok (`Int n)\n  | Error _ ->\n      match parse_float s with\n      | Ok f -> Ok (`Float f)\n      | Error _ -> Error (`Not_a_number s)\n\n(* Incremental API design *)\nmodule Http = struct\n  type 'a status = [\n    | `OK\n    | `Not_found\n    | `Internal_error\n    | 'a\n  ]\n  \n  let handle_basic : [< `OK | `Not_found] status -> string = function\n    | `OK -> \"200 OK\"\n    | `Not_found -> \"404 Not Found\"\n  \n  let handle_extended : [< `OK | `Not_found | `Unauthorized] status -> string = function\n    | `Unauthorized -> \"401 Unauthorized\"\n    | #status as s -> handle_basic s\nend\n\n(* Type-safe event handling *)\ntype 'a event = [\n  | `Click of int * int\n  | `Keypress of char\n  | 'a\n]\n\ntype 'a mouse_event = [\n  | `Click of int * int\n  | `Drag of int * int * int * int\n  | 'a\n]\n\nlet handle_event : [< _ event | _ mouse_event] -> unit = function\n  | `Click (x, y) -> Printf.printf \"Click at %d,%d\\n\" x y\n  | `Keypress c -> Printf.printf \"Key pressed: %c\\n\" c\n  | `Drag (x1, y1, x2, y2) -> Printf.printf \"Drag from %d,%d to %d,%d\\n\" x1 y1 x2 y2\n\n(* Row polymorphism simulation *)\ntype 'a handler = {\n  on_success: 'b. 'b -> ([> `Success of 'b] as 'a);\n  on_error: 'b. 'b -> ([> `Error of 'b] as 'a);\n}\n\nlet default_handler = {\n  on_success = (fun x -> `Success x);\n  on_error = (fun e -> `Error e);\n}\n\nlet with_logging h = {\n  on_success = (fun x -> \n    Printf.printf \"Success!\\n\"; \n    h.on_success x);\n  on_error = (fun e -> \n    Printf.printf \"Error!\\n\"; \n    h.on_error e);\n}"
    },
    "monad": {
      "description": "Monads provide a way to structure computations with effects, enabling composition of operations that may fail, be asynchronous, or carry state",
      "whenToUse": "Use when handling computations with effects like optional values, errors, asynchronous operations, state, or non-determinism in a composable way",
      "example": "(* Option monad *)\nmodule Option = struct\n  let bind x f =\n    match x with\n    | None -> None\n    | Some v -> f v\n  \n  let return x = Some x\n  \n  let (>>=) = bind\n  let (>>|) x f = bind x (fun v -> return (f v))\n  \n  (* Monad laws:\n     1. return a >>= f = f a\n     2. m >>= return = m  \n     3. (m >>= f) >>= g = m >>= (fun x -> f x >>= g)\n  *)\nend\n\n(* Using Option monad *)\nlet safe_div x y = \n  if y = 0 then None else Some (x / y)\n\nlet safe_sqrt x =\n  if x < 0.0 then None else Some (sqrt x)\n\nlet computation x y =\n  Option.(safe_div x y >>= fun quot ->\n          safe_sqrt (float_of_int quot) >>= fun root ->\n          return (root *. 2.0))\n\n(* Result monad for error handling *)\nmodule Result = struct\n  let bind x f =\n    match x with\n    | Error _ as e -> e\n    | Ok v -> f v\n  \n  let return x = Ok x\n  let fail e = Error e\n  \n  let (>>=) = bind\n  let (>>|) x f = bind x (fun v -> return (f v))\nend\n\n(* State monad *)\nmodule State = struct\n  type ('s, 'a) t = 's -> 'a * 's\n  \n  let return x = fun s -> (x, s)\n  \n  let bind m f = fun s ->\n    let (a, s') = m s in\n    f a s'\n  \n  let get = fun s -> (s, s)\n  let put s' = fun _ -> ((), s')\n  let modify f = fun s -> ((), f s)\n  \n  let run_state m init = m init\n  \n  let (>>=) = bind\nend\n\n(* Using State monad *)\nopen State\n\ntype counter = { value: int; history: int list }\n\nlet increment =\n  get >>= fun st ->\n  let new_value = st.value + 1 in\n  put { value = new_value; history = new_value :: st.history } >>= fun () ->\n  return new_value\n\nlet decrement =\n  modify (fun st -> \n    let new_value = st.value - 1 in\n    { value = new_value; history = new_value :: st.history }) >>= fun () ->\n  get >>= fun st ->\n  return st.value\n\n(* List monad for non-determinism *)\nmodule List = struct\n  let bind xs f = List.concat_map f xs\n  let return x = [x]\n  let zero = []\n  let plus = (@)\n  \n  let (>>=) = bind\nend\n\n(* Using List monad *)\nlet pythagorean_triples n =\n  List.(List.init n (fun i -> i + 1) >>= fun a ->\n        List.init n (fun i -> i + 1) >>= fun b ->\n        List.init n (fun i -> i + 1) >>= fun c ->\n        if a * a + b * b = c * c then\n          return (a, b, c)\n        else\n          zero)\n\n(* Monad transformers concept *)\nmodule OptionT (M : sig\n  type 'a t\n  val bind : 'a t -> ('a -> 'b t) -> 'b t\n  val return : 'a -> 'a t\nend) = struct\n  type 'a t = 'a option M.t\n  \n  let bind m f =\n    M.bind m (function\n      | None -> M.return None\n      | Some x -> f x)\n  \n  let return x = M.return (Some x)\n  let lift m = M.bind m (fun x -> M.return (Some x))\n  let none = M.return None\nend"
    },
    "builder_pattern": {
      "description": "The builder pattern in OCaml uses optional labeled arguments and partial application to create flexible APIs for constructing complex values",
      "whenToUse": "Use when creating APIs with many optional parameters, building DSLs, constructing complex configuration objects, or providing ergonomic interfaces",
      "example": "(* HTTP request builder using labeled arguments *)\nmodule Http = struct\n  type request = {\n    url: string;\n    method_: [`GET | `POST | `PUT | `DELETE];\n    headers: (string * string) list;\n    body: string option;\n    timeout: float option;\n  }\n  \n  let request \n      ?(method_=`GET) \n      ?(headers=[]) \n      ?(body=None) \n      ?(timeout=None)\n      url = {\n    url;\n    method_;\n    headers;\n    body;\n    timeout;\n  }\n  \n  (* Convenience functions *)\n  let get ?headers ?timeout url = \n    request ?headers ?timeout url\n  \n  let post ?headers ?timeout ~body url =\n    request ~method_:`POST ?headers ~body:(Some body) ?timeout url\n  \n  (* Builder with method chaining *)\n  let with_header name value req =\n    { req with headers = (name, value) :: req.headers }\n  \n  let with_timeout timeout req =\n    { req with timeout = Some timeout }\n  \n  let with_auth token req =\n    with_header \"Authorization\" (\"Bearer \" ^ token) req\nend\n\n(* Usage example *)\nlet req = \n  Http.get \"https://api.example.com/users\"\n  |> Http.with_header \"Accept\" \"application/json\"\n  |> Http.with_timeout 30.0\n  |> Http.with_auth \"secret-token\"\n\n(* Configuration builder *)\nmodule Config = struct\n  type t = {\n    host: string;\n    port: int;\n    use_ssl: bool;\n    max_connections: int;\n    buffer_size: int;\n  }\n  \n  (* Default configuration *)\n  let default = {\n    host = \"localhost\";\n    port = 8080;\n    use_ssl = false;\n    max_connections = 100;\n    buffer_size = 4096;\n  }\n  \n  (* Builder functions *)\n  let create () = default\n  \n  let host h t = { t with host = h }\n  let port p t = { t with port = p }\n  let use_ssl t = { t with use_ssl = true }\n  let max_connections n t = { t with max_connections = n }\n  let buffer_size n t = { t with buffer_size = n }\n  \n  (* Alternative: functional updates with labels *)\n  let update\n      ?host:h\n      ?port:p \n      ?use_ssl:s\n      ?max_connections:m\n      ?buffer_size:b\n      config =\n    { host = Option.value h ~default:config.host;\n      port = Option.value p ~default:config.port;\n      use_ssl = Option.value s ~default:config.use_ssl;\n      max_connections = Option.value m ~default:config.max_connections;\n      buffer_size = Option.value b ~default:config.buffer_size;\n    }\nend\n\n(* Usage *)\nlet config =\n  Config.create ()\n  |> Config.host \"api.example.com\"\n  |> Config.port 443\n  |> Config.use_ssl\n  |> Config.max_connections 200\n\n(* DSL builder pattern *)\nmodule Query = struct\n  type t = \n    | Select of string list * t\n    | From of string * t\n    | Where of string * t\n    | OrderBy of string * [`ASC | `DESC] * t\n    | End\n  \n  let select fields = Select (fields, End)\n  let from table q = match q with\n    | Select (fields, _) -> Select (fields, From (table, End))\n    | _ -> failwith \"from must follow select\"\n  \n  let where condition q = \n    let rec add_where = function\n      | Select (f, rest) -> Select (f, add_where rest)\n      | From (t, rest) -> From (t, add_where rest)\n      | Where _ -> failwith \"where already specified\"\n      | OrderBy _ as q -> Where (condition, q)\n      | End -> Where (condition, End)\n    in add_where q\n  \n  let order_by field dir q =\n    let rec add_order = function\n      | Select (f, rest) -> Select (f, add_order rest)\n      | From (t, rest) -> From (t, add_order rest)\n      | Where (c, rest) -> Where (c, add_order rest)\n      | OrderBy _ -> failwith \"order by already specified\"\n      | End -> OrderBy (field, dir, End)\n    in add_order q\n  \n  let build q = \n    let rec to_string = function\n      | Select (fields, rest) -> \n          \"SELECT \" ^ String.concat \", \" fields ^ \" \" ^ to_string rest\n      | From (table, rest) -> \n          \"FROM \" ^ table ^ \" \" ^ to_string rest\n      | Where (cond, rest) -> \n          \"WHERE \" ^ cond ^ \" \" ^ to_string rest\n      | OrderBy (field, dir, rest) ->\n          let dir_str = match dir with `ASC -> \"ASC\" | `DESC -> \"DESC\" in\n          \"ORDER BY \" ^ field ^ \" \" ^ dir_str ^ \" \" ^ to_string rest\n      | End -> \"\"\n    in to_string q\nend\n\n(* Usage *)\nlet query = \n  Query.select [\"id\"; \"name\"; \"email\"]\n  |> Query.from \"users\"\n  |> Query.where \"age > 18\"\n  |> Query.order_by \"name\" `ASC\n  |> Query.build"
    }
  }
}