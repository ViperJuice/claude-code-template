{
  "language": "swift",
  "patterns": {
    "protocol_oriented": {
      "description": "Uses protocols as the primary building blocks for composition and abstraction.",
      "whenToUse": "When designing flexible, testable APIs that can be extended without inheritance.",
      "example": "// Protocol definition\nprotocol Vehicle {\n    var numberOfWheels: Int { get }\n    var maxSpeed: Double { get }\n    func startEngine()\n    func stopEngine()\n}\n\n// Protocol with associated types\nprotocol Container {\n    associatedtype Item\n    var count: Int { get }\n    mutating func append(_ item: Item)\n    subscript(i: Int) -> Item { get }\n}\n\n// Protocol extensions with default implementation\nextension Vehicle {\n    func describe() -> String {\n        return \"This vehicle has \\(numberOfWheels) wheels and max speed of \\(maxSpeed) km/h\"\n    }\n    \n    func startEngine() {\n        print(\"Engine started\")\n    }\n}\n\n// Concrete types\nstruct Car: Vehicle {\n    let numberOfWheels = 4\n    let maxSpeed: Double\n    let model: String\n    \n    func stopEngine() {\n        print(\"Car engine stopped\")\n    }\n}\n\nstruct Bicycle: Vehicle {\n    let numberOfWheels = 2\n    let maxSpeed = 30.0\n    \n    func startEngine() {\n        print(\"No engine to start - pedal power!\")\n    }\n    \n    func stopEngine() {\n        print(\"Just stop pedaling\")\n    }\n}\n\n// Protocol composition\nprotocol Named {\n    var name: String { get }\n}\n\nprotocol Aged {\n    var age: Int { get }\n}\n\ntypealias Person = Named & Aged\n\nstruct Employee: Person {\n    let name: String\n    let age: Int\n    let employeeId: String\n}\n\n// Conditional conformance\nextension Array: Container {\n    // Already has count and append\n    // subscript is already implemented\n}\n\n// Protocol with Self requirements\nprotocol Equatable {\n    static func == (lhs: Self, rhs: Self) -> Bool\n}\n\n// Generic constraints with protocols\nfunc findIndex<T: Equatable>(of valueToFind: T, in array: [T]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}"
    },
    "delegation": {
      "description": "Enables one object to send messages to another object when a specific event happens.",
      "whenToUse": "For callbacks, customizing behavior, and decoupling components.",
      "example": "// Delegation protocol\nprotocol FileDownloaderDelegate: AnyObject {\n    func downloader(_ downloader: FileDownloader, didFinishDownloading file: String)\n    func downloader(_ downloader: FileDownloader, didFailWithError error: Error)\n    func downloader(_ downloader: FileDownloader, didUpdateProgress progress: Float)\n}\n\n// Delegating class\nclass FileDownloader {\n    weak var delegate: FileDownloaderDelegate?\n    private var progress: Float = 0.0\n    \n    func startDownload(url: URL) {\n        // Simulate download\n        Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] timer in\n            guard let self = self else { return }\n            \n            self.progress += 0.1\n            self.delegate?.downloader(self, didUpdateProgress: self.progress)\n            \n            if self.progress >= 1.0 {\n                timer.invalidate()\n                self.delegate?.downloader(self, didFinishDownloading: url.lastPathComponent)\n            }\n        }\n    }\n}\n\n// Delegate implementation\nclass DownloadViewController: UIViewController, FileDownloaderDelegate {\n    let downloader = FileDownloader()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        downloader.delegate = self\n    }\n    \n    func downloader(_ downloader: FileDownloader, didFinishDownloading file: String) {\n        print(\"Download completed: \\(file)\")\n    }\n    \n    func downloader(_ downloader: FileDownloader, didFailWithError error: Error) {\n        print(\"Download failed: \\(error.localizedDescription)\")\n    }\n    \n    func downloader(_ downloader: FileDownloader, didUpdateProgress progress: Float) {\n        print(\"Progress: \\(progress * 100)%\")\n    }\n}\n\n// Multi-delegate pattern\nclass MulticastDelegate<T> {\n    private let delegates = NSHashTable<AnyObject>.weakObjects()\n    \n    func add(_ delegate: T) {\n        delegates.add(delegate as AnyObject)\n    }\n    \n    func remove(_ delegate: T) {\n        delegates.remove(delegate as AnyObject)\n    }\n    \n    func invoke(_ invocation: (T) -> Void) {\n        delegates.allObjects\n            .compactMap { $0 as? T }\n            .forEach(invocation)\n    }\n}\n\n// Protocol with optional methods\n@objc protocol DataSourceDelegate {\n    func numberOfItems() -> Int\n    @objc optional func titleForItem(at index: Int) -> String?\n    @objc optional func didSelectItem(at index: Int)\n}\n\n// Generic delegation\nprotocol GenericDelegate: AnyObject {\n    associatedtype Input\n    associatedtype Output\n    \n    func process(_ input: Input) -> Output\n}\n\nclass Processor<D: GenericDelegate> {\n    weak var delegate: D?\n    \n    func execute(with input: D.Input) -> D.Output? {\n        return delegate?.process(input)\n    }\n}"
    },
    "coordinator": {
      "description": "Manages navigation flow and removes navigation logic from view controllers.",
      "whenToUse": "In complex apps with multiple navigation flows to improve modularity and testability.",
      "example": "// Coordinator protocol\nprotocol Coordinator: AnyObject {\n    var childCoordinators: [Coordinator] { get set }\n    var navigationController: UINavigationController { get set }\n    \n    func start()\n}\n\n// Base coordinator\nclass BaseCoordinator: Coordinator {\n    var childCoordinators: [Coordinator] = []\n    var navigationController: UINavigationController\n    \n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n    \n    func start() {\n        fatalError(\"Start method must be implemented\")\n    }\n    \n    func addChild(_ coordinator: Coordinator) {\n        childCoordinators.append(coordinator)\n    }\n    \n    func removeChild(_ coordinator: Coordinator) {\n        childCoordinators.removeAll { $0 === coordinator }\n    }\n}\n\n// App coordinator\nclass AppCoordinator: BaseCoordinator {\n    override func start() {\n        showLogin()\n    }\n    \n    private func showLogin() {\n        let loginCoordinator = LoginCoordinator(navigationController: navigationController)\n        loginCoordinator.delegate = self\n        addChild(loginCoordinator)\n        loginCoordinator.start()\n    }\n    \n    private func showMain() {\n        let mainCoordinator = MainCoordinator(navigationController: navigationController)\n        addChild(mainCoordinator)\n        mainCoordinator.start()\n    }\n}\n\n// Login coordinator\nprotocol LoginCoordinatorDelegate: AnyObject {\n    func loginCoordinatorDidFinish(_ coordinator: LoginCoordinator)\n}\n\nclass LoginCoordinator: BaseCoordinator {\n    weak var delegate: LoginCoordinatorDelegate?\n    \n    override func start() {\n        let loginVC = LoginViewController()\n        loginVC.coordinator = self\n        navigationController.setViewControllers([loginVC], animated: false)\n    }\n    \n    func didLogin(user: User) {\n        delegate?.loginCoordinatorDidFinish(self)\n    }\n    \n    func showSignup() {\n        let signupVC = SignupViewController()\n        signupVC.coordinator = self\n        navigationController.pushViewController(signupVC, animated: true)\n    }\n    \n    func showForgotPassword() {\n        let forgotPasswordVC = ForgotPasswordViewController()\n        forgotPasswordVC.coordinator = self\n        navigationController.pushViewController(forgotPasswordVC, animated: true)\n    }\n}\n\n// Main coordinator with tab bar\nclass MainCoordinator: BaseCoordinator {\n    private var tabBarController: UITabBarController?\n    \n    override func start() {\n        let tabBarController = UITabBarController()\n        self.tabBarController = tabBarController\n        \n        let homeNav = UINavigationController()\n        let homeCoordinator = HomeCoordinator(navigationController: homeNav)\n        addChild(homeCoordinator)\n        homeCoordinator.start()\n        \n        let profileNav = UINavigationController()\n        let profileCoordinator = ProfileCoordinator(navigationController: profileNav)\n        addChild(profileCoordinator)\n        profileCoordinator.start()\n        \n        tabBarController.viewControllers = [homeNav, profileNav]\n        navigationController.setViewControllers([tabBarController], animated: true)\n    }\n}\n\n// View controller with coordinator\nclass LoginViewController: UIViewController {\n    weak var coordinator: LoginCoordinator?\n    \n    @IBAction func loginTapped() {\n        // Perform login\n        let user = User(name: \"John\")\n        coordinator?.didLogin(user: user)\n    }\n    \n    @IBAction func signupTapped() {\n        coordinator?.showSignup()\n    }\n    \n    @IBAction func forgotPasswordTapped() {\n        coordinator?.showForgotPassword()\n    }\n}\n\n// Deep linking with coordinators\nprotocol DeepLinkHandler {\n    func canHandle(_ deepLink: DeepLink) -> Bool\n    func handle(_ deepLink: DeepLink)\n}\n\nextension MainCoordinator: DeepLinkHandler {\n    func canHandle(_ deepLink: DeepLink) -> Bool {\n        return deepLink.path.hasPrefix(\"/main\")\n    }\n    \n    func handle(_ deepLink: DeepLink) {\n        // Navigate to appropriate screen based on deep link\n    }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step with a fluent interface.",
      "whenToUse": "When creating objects with many optional parameters or complex initialization.",
      "example": "// Builder pattern for complex object\nclass URLRequestBuilder {\n    private var url: URL?\n    private var method: HTTPMethod = .get\n    private var headers: [String: String] = [:]\n    private var body: Data?\n    private var timeoutInterval: TimeInterval = 30\n    private var cachePolicy: URLRequest.CachePolicy = .useProtocolCachePolicy\n    \n    func with(url: URL) -> URLRequestBuilder {\n        self.url = url\n        return self\n    }\n    \n    func with(method: HTTPMethod) -> URLRequestBuilder {\n        self.method = method\n        return self\n    }\n    \n    func with(headers: [String: String]) -> URLRequestBuilder {\n        self.headers.merge(headers) { _, new in new }\n        return self\n    }\n    \n    func with(header key: String, value: String) -> URLRequestBuilder {\n        self.headers[key] = value\n        return self\n    }\n    \n    func with(body: Data) -> URLRequestBuilder {\n        self.body = body\n        return self\n    }\n    \n    func with(jsonBody: Encodable) throws -> URLRequestBuilder {\n        let encoder = JSONEncoder()\n        self.body = try encoder.encode(jsonBody)\n        self.headers[\"Content-Type\"] = \"application/json\"\n        return self\n    }\n    \n    func with(timeout: TimeInterval) -> URLRequestBuilder {\n        self.timeoutInterval = timeout\n        return self\n    }\n    \n    func build() throws -> URLRequest {\n        guard let url = url else {\n            throw BuilderError.missingURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n        request.allHTTPHeaderFields = headers\n        request.httpBody = body\n        request.timeoutInterval = timeoutInterval\n        request.cachePolicy = cachePolicy\n        \n        return request\n    }\n}\n\nenum HTTPMethod: String {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case delete = \"DELETE\"\n}\n\nenum BuilderError: Error {\n    case missingURL\n}\n\n// Result builder (formerly Function Builder)\n@resultBuilder\nstruct HTMLBuilder {\n    static func buildBlock(_ components: String...) -> String {\n        components.joined(separator: \"\\n\")\n    }\n    \n    static func buildOptional(_ component: String?) -> String {\n        component ?? \"\"\n    }\n    \n    static func buildEither(first component: String) -> String {\n        component\n    }\n    \n    static func buildEither(second component: String) -> String {\n        component\n    }\n    \n    static func buildArray(_ components: [String]) -> String {\n        components.joined(separator: \"\\n\")\n    }\n}\n\nfunc html(@HTMLBuilder content: () -> String) -> String {\n    \"<html>\\n\\(content())\\n</html>\"\n}\n\nfunc body(@HTMLBuilder content: () -> String) -> String {\n    \"<body>\\n\\(content())\\n</body>\"\n}\n\nfunc p(_ text: String) -> String {\n    \"<p>\\(text)</p>\"\n}\n\nfunc h1(_ text: String) -> String {\n    \"<h1>\\(text)</h1>\"\n}\n\n// Usage\nlet htmlContent = html {\n    body {\n        h1(\"Welcome\")\n        p(\"This is a paragraph\")\n        if true {\n            p(\"Conditional paragraph\")\n        }\n        for i in 1...3 {\n            p(\"Item \\(i)\")\n        }\n    }\n}\n\n// Configuration builder\nstruct AppConfiguration {\n    let apiEndpoint: URL\n    let apiKey: String\n    let debugMode: Bool\n    let maxRetries: Int\n    let timeout: TimeInterval\n    \n    class Builder {\n        private var apiEndpoint: URL?\n        private var apiKey: String?\n        private var debugMode: Bool = false\n        private var maxRetries: Int = 3\n        private var timeout: TimeInterval = 30\n        \n        func apiEndpoint(_ url: URL) -> Builder {\n            self.apiEndpoint = url\n            return self\n        }\n        \n        func apiKey(_ key: String) -> Builder {\n            self.apiKey = key\n            return self\n        }\n        \n        func debugMode(_ enabled: Bool) -> Builder {\n            self.debugMode = enabled\n            return self\n        }\n        \n        func maxRetries(_ count: Int) -> Builder {\n            self.maxRetries = count\n            return self\n        }\n        \n        func timeout(_ interval: TimeInterval) -> Builder {\n            self.timeout = interval\n            return self\n        }\n        \n        func build() throws -> AppConfiguration {\n            guard let apiEndpoint = apiEndpoint else {\n                throw ConfigurationError.missingAPIEndpoint\n            }\n            guard let apiKey = apiKey else {\n                throw ConfigurationError.missingAPIKey\n            }\n            \n            return AppConfiguration(\n                apiEndpoint: apiEndpoint,\n                apiKey: apiKey,\n                debugMode: debugMode,\n                maxRetries: maxRetries,\n                timeout: timeout\n            )\n        }\n    }\n}\n\nenum ConfigurationError: Error {\n    case missingAPIEndpoint\n    case missingAPIKey\n}"
    },
    "singleton": {
      "description": "Ensures a class has only one instance and provides global access to it.",
      "whenToUse": "For managing shared resources like configuration, caches, or hardware interfaces.",
      "example": "// Thread-safe singleton\nclass NetworkManager {\n    static let shared = NetworkManager()\n    \n    private let session: URLSession\n    private let baseURL: URL\n    \n    private init() {\n        let configuration = URLSessionConfiguration.default\n        configuration.timeoutIntervalForRequest = 30\n        self.session = URLSession(configuration: configuration)\n        self.baseURL = URL(string: \"https://api.example.com\")!\n    }\n    \n    func request<T: Decodable>(_ endpoint: String, type: T.Type) async throws -> T {\n        guard let url = URL(string: endpoint, relativeTo: baseURL) else {\n            throw NetworkError.invalidURL\n        }\n        \n        let (data, response) = try await session.data(from: url)\n        \n        guard let httpResponse = response as? HTTPURLResponse,\n              (200...299).contains(httpResponse.statusCode) else {\n            throw NetworkError.invalidResponse\n        }\n        \n        return try JSONDecoder().decode(type, from: data)\n    }\n}\n\nenum NetworkError: Error {\n    case invalidURL\n    case invalidResponse\n}\n\n// Singleton with dependency injection support\nclass Logger {\n    static var shared = Logger()\n    \n    private var outputs: [LogOutput] = []\n    \n    init() {\n        // Default configuration\n        outputs.append(ConsoleOutput())\n    }\n    \n    func addOutput(_ output: LogOutput) {\n        outputs.append(output)\n    }\n    \n    func log(_ message: String, level: LogLevel = .info) {\n        let timestamp = Date()\n        let logEntry = LogEntry(timestamp: timestamp, level: level, message: message)\n        \n        outputs.forEach { $0.write(logEntry) }\n    }\n}\n\nprotocol LogOutput {\n    func write(_ entry: LogEntry)\n}\n\nstruct LogEntry {\n    let timestamp: Date\n    let level: LogLevel\n    let message: String\n}\n\nenum LogLevel: String {\n    case debug, info, warning, error\n}\n\nstruct ConsoleOutput: LogOutput {\n    func write(_ entry: LogEntry) {\n        print(\"[\\(entry.level.rawValue.uppercased())] \\(entry.timestamp): \\(entry.message)\")\n    }\n}\n\n// Configuration singleton\nclass AppSettings {\n    static let shared = AppSettings()\n    \n    private let userDefaults = UserDefaults.standard\n    private var cache: [String: Any] = [:]\n    \n    private init() {\n        loadSettings()\n    }\n    \n    var apiKey: String {\n        get { return getString(\"api_key\") ?? \"\" }\n        set { setString(\"api_key\", value: newValue) }\n    }\n    \n    var isDarkMode: Bool {\n        get { return getBool(\"dark_mode\") ?? false }\n        set { setBool(\"dark_mode\", value: newValue) }\n    }\n    \n    private func loadSettings() {\n        // Load from UserDefaults or remote configuration\n    }\n    \n    private func getString(_ key: String) -> String? {\n        if let cached = cache[key] as? String {\n            return cached\n        }\n        let value = userDefaults.string(forKey: key)\n        cache[key] = value\n        return value\n    }\n    \n    private func setString(_ key: String, value: String) {\n        cache[key] = value\n        userDefaults.set(value, forKey: key)\n    }\n    \n    private func getBool(_ key: String) -> Bool? {\n        if let cached = cache[key] as? Bool {\n            return cached\n        }\n        let value = userDefaults.bool(forKey: key)\n        cache[key] = value\n        return value\n    }\n    \n    private func setBool(_ key: String, value: Bool) {\n        cache[key] = value\n        userDefaults.set(value, forKey: key)\n    }\n}"
    },
    "factory": {
      "description": "Creates objects without specifying their exact types.",
      "whenToUse": "When object creation logic is complex or needs to be decided at runtime.",
      "example": "// Protocol for products\nprotocol PaymentMethod {\n    func processPayment(amount: Decimal) throws\n    var type: PaymentType { get }\n}\n\nenum PaymentType {\n    case creditCard\n    case applePay\n    case paypal\n    case bankTransfer\n}\n\n// Concrete products\nstruct CreditCardPayment: PaymentMethod {\n    let cardNumber: String\n    let cvv: String\n    let expiryDate: String\n    \n    func processPayment(amount: Decimal) throws {\n        print(\"Processing $\\(amount) via credit card ending in \\(String(cardNumber.suffix(4)))\")\n        // Process payment\n    }\n    \n    var type: PaymentType { .creditCard }\n}\n\nstruct ApplePayPayment: PaymentMethod {\n    let deviceID: String\n    \n    func processPayment(amount: Decimal) throws {\n        print(\"Processing $\\(amount) via Apple Pay\")\n        // Process payment\n    }\n    \n    var type: PaymentType { .applePay }\n}\n\nstruct PayPalPayment: PaymentMethod {\n    let email: String\n    let password: String\n    \n    func processPayment(amount: Decimal) throws {\n        print(\"Processing $\\(amount) via PayPal\")\n        // Process payment\n    }\n    \n    var type: PaymentType { .paypal }\n}\n\n// Factory\nclass PaymentMethodFactory {\n    enum FactoryError: Error {\n        case unsupportedPaymentType\n        case invalidPaymentData\n    }\n    \n    static func createPaymentMethod(from data: PaymentData) throws -> PaymentMethod {\n        switch data {\n        case .creditCard(let number, let cvv, let expiry):\n            return CreditCardPayment(cardNumber: number, cvv: cvv, expiryDate: expiry)\n            \n        case .applePay(let deviceID):\n            return ApplePayPayment(deviceID: deviceID)\n            \n        case .paypal(let email, let password):\n            return PayPalPayment(email: email, password: password)\n            \n        default:\n            throw FactoryError.unsupportedPaymentType\n        }\n    }\n}\n\nenum PaymentData {\n    case creditCard(number: String, cvv: String, expiry: String)\n    case applePay(deviceID: String)\n    case paypal(email: String, password: String)\n    case bankTransfer(accountNumber: String, routingNumber: String)\n}\n\n// Abstract factory pattern\nprotocol UIFactory {\n    func createButton() -> Button\n    func createTextField() -> TextField\n    func createLabel() -> Label\n}\n\nprotocol Button {\n    func tap()\n}\n\nprotocol TextField {\n    var text: String { get set }\n}\n\nprotocol Label {\n    var text: String { get set }\n}\n\n// iOS Factory\nclass iOSUIFactory: UIFactory {\n    func createButton() -> Button {\n        return iOSButton()\n    }\n    \n    func createTextField() -> TextField {\n        return iOSTextField()\n    }\n    \n    func createLabel() -> Label {\n        return iOSLabel()\n    }\n}\n\nstruct iOSButton: Button {\n    func tap() {\n        print(\"iOS button tapped\")\n    }\n}\n\nstruct iOSTextField: TextField {\n    var text: String = \"\"\n}\n\nstruct iOSLabel: Label {\n    var text: String = \"\"\n}\n\n// macOS Factory\nclass macOSUIFactory: UIFactory {\n    func createButton() -> Button {\n        return macOSButton()\n    }\n    \n    func createTextField() -> TextField {\n        return macOSTextField()\n    }\n    \n    func createLabel() -> Label {\n        return macOSLabel()\n    }\n}\n\nstruct macOSButton: Button {\n    func tap() {\n        print(\"macOS button clicked\")\n    }\n}\n\nstruct macOSTextField: TextField {\n    var text: String = \"\"\n}\n\nstruct macOSLabel: Label {\n    var text: String = \"\"\n}\n\n// Factory with registration\nclass ViewControllerFactory {\n    private var creators: [String: () -> UIViewController] = [:]\n    \n    func register<T: UIViewController>(_ type: T.Type, creator: @escaping () -> T) {\n        creators[String(describing: type)] = creator\n    }\n    \n    func create<T: UIViewController>(_ type: T.Type) -> T? {\n        let key = String(describing: type)\n        return creators[key]?() as? T\n    }\n}\n\n// Generic factory\nprotocol Creatable {\n    init()\n}\n\nclass GenericFactory<T: Creatable> {\n    func create() -> T {\n        return T()\n    }\n    \n    func create(count: Int) -> [T] {\n        return (0..<count).map { _ in T() }\n    }\n}"
    },
    "observer": {
      "description": "Allows objects to notify multiple observers about state changes.",
      "whenToUse": "For event-driven programming and reactive architectures.",
      "example": "// NotificationCenter pattern\nclass EventManager {\n    static let shared = EventManager()\n    private let notificationCenter = NotificationCenter.default\n    \n    // Event names\n    static let userDidLogin = Notification.Name(\"userDidLogin\")\n    static let userDidLogout = Notification.Name(\"userDidLogout\")\n    static let dataDidUpdate = Notification.Name(\"dataDidUpdate\")\n    \n    func post(event: Notification.Name, data: Any? = nil) {\n        notificationCenter.post(name: event, object: nil, userInfo: [\"data\": data as Any])\n    }\n    \n    func observe(event: Notification.Name, object: Any? = nil, queue: OperationQueue? = .main, using block: @escaping (Notification) -> Void) -> NSObjectProtocol {\n        return notificationCenter.addObserver(forName: event, object: object, queue: queue, using: block)\n    }\n    \n    func removeObserver(_ observer: Any) {\n        notificationCenter.removeObserver(observer)\n    }\n}\n\n// Custom observer pattern\nprotocol Observable: AnyObject {\n    associatedtype T\n    var value: T { get set }\n    func bind(_ observer: @escaping (T) -> Void)\n}\n\nclass Box<T>: Observable {\n    typealias Observer = (T) -> Void\n    private var observers: [Observer] = []\n    \n    var value: T {\n        didSet {\n            notifyObservers()\n        }\n    }\n    \n    init(_ value: T) {\n        self.value = value\n    }\n    \n    func bind(_ observer: @escaping Observer) {\n        observers.append(observer)\n        observer(value) // Notify immediately\n    }\n    \n    private func notifyObservers() {\n        observers.forEach { $0(value) }\n    }\n}\n\n// Property observer wrapper\n@propertyWrapper\nclass Published<T> {\n    private var value: T\n    private var observers: [(T) -> Void] = []\n    \n    init(wrappedValue: T) {\n        self.value = wrappedValue\n    }\n    \n    var wrappedValue: T {\n        get { value }\n        set {\n            value = newValue\n            observers.forEach { $0(newValue) }\n        }\n    }\n    \n    var projectedValue: Published<T> {\n        return self\n    }\n    \n    func observe(_ observer: @escaping (T) -> Void) {\n        observers.append(observer)\n        observer(value)\n    }\n}\n\n// Usage example\nclass UserViewModel {\n    @Published var userName: String = \"\"\n    @Published var isLoggedIn: Bool = false\n    @Published var profileImage: UIImage?\n    \n    func login(name: String) {\n        userName = name\n        isLoggedIn = true\n        // Load profile image\n    }\n    \n    func logout() {\n        userName = \"\"\n        isLoggedIn = false\n        profileImage = nil\n    }\n}\n\n// KVO (Key-Value Observing) pattern\nclass Settings: NSObject {\n    @objc dynamic var theme: String = \"light\"\n    @objc dynamic var fontSize: Int = 14\n    \n    private var observations: [NSKeyValueObservation] = []\n    \n    func startObserving() {\n        let themeObservation = observe(\\.theme, options: [.new, .old]) { settings, change in\n            print(\"Theme changed from \\(change.oldValue ?? \"\") to \\(change.newValue ?? \"\")\")\n        }\n        \n        let fontObservation = observe(\\.fontSize, options: [.new]) { settings, change in\n            print(\"Font size changed to \\(change.newValue ?? 0)\")\n        }\n        \n        observations.append(contentsOf: [themeObservation, fontObservation])\n    }\n}\n\n// Combine framework observer\nimport Combine\n\nclass DataModel: ObservableObject {\n    @Published var items: [String] = []\n    @Published var isLoading: Bool = false\n    @Published var error: Error?\n    \n    private var cancellables = Set<AnyCancellable>()\n    \n    func loadData() {\n        isLoading = true\n        \n        URLSession.shared.dataTaskPublisher(for: URL(string: \"https://api.example.com/items\")!)\n            .map(\\.data)\n            .decode(type: [String].self, decoder: JSONDecoder())\n            .receive(on: DispatchQueue.main)\n            .sink(\n                receiveCompletion: { [weak self] completion in\n                    self?.isLoading = false\n                    if case .failure(let error) = completion {\n                        self?.error = error\n                    }\n                },\n                receiveValue: { [weak self] items in\n                    self?.items = items\n                }\n            )\n            .store(in: &cancellables)\n    }\n}"
    },
    "strategy": {
      "description": "Encapsulates algorithms and makes them interchangeable at runtime.",
      "whenToUse": "When you have multiple ways to perform a task and want to switch between them.",
      "example": "// Strategy protocol\nprotocol SortingStrategy {\n    func sort<T: Comparable>(_ array: [T]) -> [T]\n}\n\n// Concrete strategies\nstruct BubbleSort: SortingStrategy {\n    func sort<T: Comparable>(_ array: [T]) -> [T] {\n        var result = array\n        let n = result.count\n        \n        for i in 0..<n {\n            for j in 0..<(n-i-1) {\n                if result[j] > result[j+1] {\n                    result.swapAt(j, j+1)\n                }\n            }\n        }\n        \n        return result\n    }\n}\n\nstruct QuickSort: SortingStrategy {\n    func sort<T: Comparable>(_ array: [T]) -> [T] {\n        guard array.count > 1 else { return array }\n        \n        let pivot = array[array.count / 2]\n        let less = array.filter { $0 < pivot }\n        let equal = array.filter { $0 == pivot }\n        let greater = array.filter { $0 > pivot }\n        \n        return sort(less) + equal + sort(greater)\n    }\n}\n\nstruct MergeSort: SortingStrategy {\n    func sort<T: Comparable>(_ array: [T]) -> [T] {\n        guard array.count > 1 else { return array }\n        \n        let middleIndex = array.count / 2\n        let leftArray = sort(Array(array[0..<middleIndex]))\n        let rightArray = sort(Array(array[middleIndex..<array.count]))\n        \n        return merge(leftArray, rightArray)\n    }\n    \n    private func merge<T: Comparable>(_ left: [T], _ right: [T]) -> [T] {\n        var leftIndex = 0\n        var rightIndex = 0\n        var result: [T] = []\n        \n        while leftIndex < left.count && rightIndex < right.count {\n            if left[leftIndex] < right[rightIndex] {\n                result.append(left[leftIndex])\n                leftIndex += 1\n            } else {\n                result.append(right[rightIndex])\n                rightIndex += 1\n            }\n        }\n        \n        result.append(contentsOf: left[leftIndex...])\n        result.append(contentsOf: right[rightIndex...])\n        \n        return result\n    }\n}\n\n// Context\nclass DataProcessor {\n    private var sortingStrategy: SortingStrategy\n    \n    init(strategy: SortingStrategy = QuickSort()) {\n        self.sortingStrategy = strategy\n    }\n    \n    func setSortingStrategy(_ strategy: SortingStrategy) {\n        self.sortingStrategy = strategy\n    }\n    \n    func process<T: Comparable>(_ data: [T]) -> [T] {\n        return sortingStrategy.sort(data)\n    }\n}\n\n// Cache strategy example\nprotocol CacheStrategy {\n    func store(key: String, value: Data)\n    func retrieve(key: String) -> Data?\n    func remove(key: String)\n    func clear()\n}\n\nclass InMemoryCache: CacheStrategy {\n    private var cache: [String: Data] = [:]\n    \n    func store(key: String, value: Data) {\n        cache[key] = value\n    }\n    \n    func retrieve(key: String) -> Data? {\n        return cache[key]\n    }\n    \n    func remove(key: String) {\n        cache.removeValue(forKey: key)\n    }\n    \n    func clear() {\n        cache.removeAll()\n    }\n}\n\nclass DiskCache: CacheStrategy {\n    private let cacheDirectory: URL\n    \n    init() {\n        let paths = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)\n        cacheDirectory = paths[0].appendingPathComponent(\"DiskCache\")\n        try? FileManager.default.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)\n    }\n    \n    func store(key: String, value: Data) {\n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        try? value.write(to: fileURL)\n    }\n    \n    func retrieve(key: String) -> Data? {\n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        return try? Data(contentsOf: fileURL)\n    }\n    \n    func remove(key: String) {\n        let fileURL = cacheDirectory.appendingPathComponent(key)\n        try? FileManager.default.removeItem(at: fileURL)\n    }\n    \n    func clear() {\n        try? FileManager.default.removeItem(at: cacheDirectory)\n        try? FileManager.default.createDirectory(at: cacheDirectory, withIntermediateDirectories: true)\n    }\n}\n\n// Image loading strategy\nprotocol ImageLoadingStrategy {\n    func loadImage(from url: URL) async throws -> UIImage\n}\n\nstruct NetworkImageLoader: ImageLoadingStrategy {\n    func loadImage(from url: URL) async throws -> UIImage {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        guard let image = UIImage(data: data) else {\n            throw ImageLoadingError.invalidData\n        }\n        return image\n    }\n}\n\nstruct CachedImageLoader: ImageLoadingStrategy {\n    private let cache: CacheStrategy\n    private let networkLoader: NetworkImageLoader\n    \n    init(cache: CacheStrategy) {\n        self.cache = cache\n        self.networkLoader = NetworkImageLoader()\n    }\n    \n    func loadImage(from url: URL) async throws -> UIImage {\n        let key = url.absoluteString\n        \n        // Check cache first\n        if let cachedData = cache.retrieve(key: key),\n           let image = UIImage(data: cachedData) {\n            return image\n        }\n        \n        // Load from network\n        let image = try await networkLoader.loadImage(from: url)\n        \n        // Cache the image\n        if let data = image.pngData() {\n            cache.store(key: key, value: data)\n        }\n        \n        return image\n    }\n}\n\nenum ImageLoadingError: Error {\n    case invalidData\n}"
    }
  }
}