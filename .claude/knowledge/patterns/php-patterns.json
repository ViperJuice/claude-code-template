{
  "language": "php",
  "patterns": {
    "singleton": {
      "description": "Ensures only one instance of a class exists (considered anti-pattern, prefer DI).",
      "whenToUse": "Rarely - prefer dependency injection. Only for true global state like configuration.",
      "example": "<?php\n// Classic Singleton (NOT RECOMMENDED)\nclass DatabaseConnection\n{\n    private static ?DatabaseConnection $instance = null;\n    private PDO $connection;\n    \n    private function __construct()\n    {\n        $this->connection = new PDO(\n            'mysql:host=localhost;dbname=test',\n            'user',\n            'password'\n        );\n    }\n    \n    // Prevent cloning\n    private function __clone() {}\n    \n    // Prevent unserialization\n    public function __wakeup()\n    {\n        throw new Exception(\"Cannot unserialize singleton\");\n    }\n    \n    public static function getInstance(): self\n    {\n        if (self::$instance === null) {\n            self::$instance = new self();\n        }\n        \n        return self::$instance;\n    }\n    \n    public function query(string $sql): PDOStatement\n    {\n        return $this->connection->query($sql);\n    }\n}\n\n// Better approach using DI\nclass ConfigurationManager\n{\n    private array $config = [];\n    \n    public function __construct(string $configFile)\n    {\n        $this->config = require $configFile;\n    }\n    \n    public function get(string $key, mixed $default = null): mixed\n    {\n        return $this->config[$key] ?? $default;\n    }\n    \n    public function set(string $key, mixed $value): void\n    {\n        $this->config[$key] = $value;\n    }\n}\n\n// Register as singleton in DI container\n$container->singleton(ConfigurationManager::class, function ($container) {\n    return new ConfigurationManager(__DIR__ . '/config.php');\n});"
    },
    "dependency_injection": {
      "description": "Provides dependencies to objects rather than having them create dependencies.",
      "whenToUse": "Always - for better testability, maintainability, and following SOLID principles.",
      "example": "<?php\n// Define interfaces\ninterface MailerInterface\n{\n    public function send(string $to, string $subject, string $body): bool;\n}\n\ninterface LoggerInterface\n{\n    public function log(string $level, string $message, array $context = []): void;\n}\n\n// Implementations\nclass SmtpMailer implements MailerInterface\n{\n    public function __construct(\n        private string $host,\n        private int $port,\n        private string $username,\n        private string $password\n    ) {}\n    \n    public function send(string $to, string $subject, string $body): bool\n    {\n        // SMTP implementation\n        echo \"Sending email to {$to}: {$subject}\\n\";\n        return true;\n    }\n}\n\nclass FileLogger implements LoggerInterface\n{\n    public function __construct(private string $logFile) {}\n    \n    public function log(string $level, string $message, array $context = []): void\n    {\n        $timestamp = date('Y-m-d H:i:s');\n        $contextStr = empty($context) ? '' : json_encode($context);\n        $logEntry = \"[{$timestamp}] {$level}: {$message} {$contextStr}\\n\";\n        \n        file_put_contents($this->logFile, $logEntry, FILE_APPEND);\n    }\n}\n\n// Service using constructor injection\nclass UserService\n{\n    public function __construct(\n        private UserRepository $repository,\n        private MailerInterface $mailer,\n        private LoggerInterface $logger\n    ) {}\n    \n    public function register(array $userData): User\n    {\n        $this->logger->log('info', 'Registering new user', ['email' => $userData['email']]);\n        \n        try {\n            $user = new User($userData);\n            $this->repository->save($user);\n            \n            $this->mailer->send(\n                $user->getEmail(),\n                'Welcome!',\n                \"Welcome to our service, {$user->getName()}!\"\n            );\n            \n            $this->logger->log('info', 'User registered successfully', ['id' => $user->getId()]);\n            \n            return $user;\n        } catch (\\Exception $e) {\n            $this->logger->log('error', 'User registration failed', [\n                'error' => $e->getMessage(),\n                'userData' => $userData\n            ]);\n            throw $e;\n        }\n    }\n}\n\n// Simple DI Container\nclass Container\n{\n    private array $bindings = [];\n    private array $instances = [];\n    \n    public function bind(string $abstract, callable $concrete): void\n    {\n        $this->bindings[$abstract] = $concrete;\n    }\n    \n    public function singleton(string $abstract, callable $concrete): void\n    {\n        $this->bind($abstract, function ($container) use ($abstract, $concrete) {\n            if (!isset($this->instances[$abstract])) {\n                $this->instances[$abstract] = $concrete($container);\n            }\n            return $this->instances[$abstract];\n        });\n    }\n    \n    public function make(string $abstract): mixed\n    {\n        if (!isset($this->bindings[$abstract])) {\n            throw new Exception(\"No binding found for {$abstract}\");\n        }\n        \n        return $this->bindings[$abstract]($this);\n    }\n}\n\n// Configuration\n$container = new Container();\n\n$container->singleton(LoggerInterface::class, function ($container) {\n    return new FileLogger(__DIR__ . '/logs/app.log');\n});\n\n$container->singleton(MailerInterface::class, function ($container) {\n    return new SmtpMailer('smtp.gmail.com', 587, 'user', 'pass');\n});\n\n$container->bind(UserService::class, function ($container) {\n    return new UserService(\n        new UserRepository(),\n        $container->make(MailerInterface::class),\n        $container->make(LoggerInterface::class)\n    );\n});"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes.",
      "whenToUse": "When object creation is complex or needs to be decided at runtime.",
      "example": "<?php\n// Abstract Factory Pattern\ninterface DataSourceFactory\n{\n    public function createReader(): DataReader;\n    public function createWriter(): DataWriter;\n}\n\ninterface DataReader\n{\n    public function read(string $source): array;\n}\n\ninterface DataWriter\n{\n    public function write(string $destination, array $data): bool;\n}\n\n// Concrete Implementations\nclass JsonFactory implements DataSourceFactory\n{\n    public function createReader(): DataReader\n    {\n        return new JsonReader();\n    }\n    \n    public function createWriter(): DataWriter\n    {\n        return new JsonWriter();\n    }\n}\n\nclass JsonReader implements DataReader\n{\n    public function read(string $source): array\n    {\n        $content = file_get_contents($source);\n        return json_decode($content, true) ?? [];\n    }\n}\n\nclass JsonWriter implements DataWriter\n{\n    public function write(string $destination, array $data): bool\n    {\n        $json = json_encode($data, JSON_PRETTY_PRINT);\n        return file_put_contents($destination, $json) !== false;\n    }\n}\n\nclass CsvFactory implements DataSourceFactory\n{\n    public function createReader(): DataReader\n    {\n        return new CsvReader();\n    }\n    \n    public function createWriter(): DataWriter\n    {\n        return new CsvWriter();\n    }\n}\n\nclass CsvReader implements DataReader\n{\n    public function read(string $source): array\n    {\n        $data = [];\n        if (($handle = fopen($source, 'r')) !== false) {\n            while (($row = fgetcsv($handle)) !== false) {\n                $data[] = $row;\n            }\n            fclose($handle);\n        }\n        return $data;\n    }\n}\n\nclass CsvWriter implements DataWriter\n{\n    public function write(string $destination, array $data): bool\n    {\n        $handle = fopen($destination, 'w');\n        if ($handle === false) {\n            return false;\n        }\n        \n        foreach ($data as $row) {\n            fputcsv($handle, $row);\n        }\n        \n        fclose($handle);\n        return true;\n    }\n}\n\n// Factory Method Pattern\nabstract class NotificationFactory\n{\n    abstract protected function createNotification(): Notification;\n    \n    public function send(string $recipient, string $message): bool\n    {\n        $notification = $this->createNotification();\n        return $notification->send($recipient, $message);\n    }\n}\n\ninterface Notification\n{\n    public function send(string $recipient, string $message): bool;\n}\n\nclass EmailNotificationFactory extends NotificationFactory\n{\n    protected function createNotification(): Notification\n    {\n        return new EmailNotification();\n    }\n}\n\nclass SmsNotificationFactory extends NotificationFactory\n{\n    protected function createNotification(): Notification\n    {\n        return new SmsNotification();\n    }\n}\n\nclass EmailNotification implements Notification\n{\n    public function send(string $recipient, string $message): bool\n    {\n        echo \"Sending email to {$recipient}: {$message}\\n\";\n        return mail($recipient, 'Notification', $message);\n    }\n}\n\nclass SmsNotification implements Notification\n{\n    public function send(string $recipient, string $message): bool\n    {\n        echo \"Sending SMS to {$recipient}: {$message}\\n\";\n        // SMS API call here\n        return true;\n    }\n}\n\n// Static Factory Pattern\nclass Payment\n{\n    private function __construct(\n        private string $type,\n        private float $amount,\n        private array $metadata = []\n    ) {}\n    \n    public static function creditCard(float $amount, string $cardNumber, string $cvv): self\n    {\n        return new self('credit_card', $amount, [\n            'card_number' => $cardNumber,\n            'cvv' => $cvv\n        ]);\n    }\n    \n    public static function paypal(float $amount, string $email): self\n    {\n        return new self('paypal', $amount, [\n            'email' => $email\n        ]);\n    }\n    \n    public static function bankTransfer(float $amount, string $accountNumber): self\n    {\n        return new self('bank_transfer', $amount, [\n            'account_number' => $accountNumber\n        ]);\n    }\n    \n    public function process(): bool\n    {\n        echo \"Processing {$this->type} payment for \\${$this->amount}\\n\";\n        return true;\n    }\n}"
    },
    "repository": {
      "description": "Mediates between domain and data mapping layers.",
      "whenToUse": "When you need to separate business logic from data access logic.",
      "example": "<?php\n// Entity\nclass User\n{\n    public function __construct(\n        private ?int $id,\n        private string $email,\n        private string $name,\n        private DateTime $createdAt,\n        private ?DateTime $updatedAt = null\n    ) {}\n    \n    // Getters and setters...\n    public function getId(): ?int { return $this->id; }\n    public function getEmail(): string { return $this->email; }\n    public function getName(): string { return $this->name; }\n    public function getCreatedAt(): DateTime { return $this->createdAt; }\n    public function getUpdatedAt(): ?DateTime { return $this->updatedAt; }\n    \n    public function setEmail(string $email): void { $this->email = $email; }\n    public function setName(string $name): void { $this->name = $name; }\n    public function setUpdatedAt(DateTime $updatedAt): void { $this->updatedAt = $updatedAt; }\n}\n\n// Repository Interface\ninterface UserRepositoryInterface\n{\n    public function find(int $id): ?User;\n    public function findByEmail(string $email): ?User;\n    public function findAll(): array;\n    public function save(User $user): void;\n    public function delete(User $user): void;\n    public function findByFilters(array $filters): array;\n}\n\n// Repository Implementation\nclass UserRepository implements UserRepositoryInterface\n{\n    public function __construct(private PDO $connection) {}\n    \n    public function find(int $id): ?User\n    {\n        $stmt = $this->connection->prepare(\n            'SELECT * FROM users WHERE id = :id'\n        );\n        $stmt->execute(['id' => $id]);\n        \n        $data = $stmt->fetch(PDO::FETCH_ASSOC);\n        \n        return $data ? $this->hydrate($data) : null;\n    }\n    \n    public function findByEmail(string $email): ?User\n    {\n        $stmt = $this->connection->prepare(\n            'SELECT * FROM users WHERE email = :email'\n        );\n        $stmt->execute(['email' => $email]);\n        \n        $data = $stmt->fetch(PDO::FETCH_ASSOC);\n        \n        return $data ? $this->hydrate($data) : null;\n    }\n    \n    public function findAll(): array\n    {\n        $stmt = $this->connection->query('SELECT * FROM users');\n        $users = [];\n        \n        while ($data = $stmt->fetch(PDO::FETCH_ASSOC)) {\n            $users[] = $this->hydrate($data);\n        }\n        \n        return $users;\n    }\n    \n    public function save(User $user): void\n    {\n        if ($user->getId() === null) {\n            $this->insert($user);\n        } else {\n            $this->update($user);\n        }\n    }\n    \n    public function delete(User $user): void\n    {\n        $stmt = $this->connection->prepare(\n            'DELETE FROM users WHERE id = :id'\n        );\n        $stmt->execute(['id' => $user->getId()]);\n    }\n    \n    public function findByFilters(array $filters): array\n    {\n        $query = 'SELECT * FROM users WHERE 1=1';\n        $params = [];\n        \n        if (isset($filters['name'])) {\n            $query .= ' AND name LIKE :name';\n            $params['name'] = '%' . $filters['name'] . '%';\n        }\n        \n        if (isset($filters['created_after'])) {\n            $query .= ' AND created_at > :created_after';\n            $params['created_after'] = $filters['created_after'];\n        }\n        \n        $stmt = $this->connection->prepare($query);\n        $stmt->execute($params);\n        \n        $users = [];\n        while ($data = $stmt->fetch(PDO::FETCH_ASSOC)) {\n            $users[] = $this->hydrate($data);\n        }\n        \n        return $users;\n    }\n    \n    private function insert(User $user): void\n    {\n        $stmt = $this->connection->prepare(\n            'INSERT INTO users (email, name, created_at) VALUES (:email, :name, :created_at)'\n        );\n        \n        $stmt->execute([\n            'email' => $user->getEmail(),\n            'name' => $user->getName(),\n            'created_at' => $user->getCreatedAt()->format('Y-m-d H:i:s')\n        ]);\n        \n        // Set the ID on the entity\n        $id = (int) $this->connection->lastInsertId();\n        $reflection = new ReflectionClass($user);\n        $property = $reflection->getProperty('id');\n        $property->setAccessible(true);\n        $property->setValue($user, $id);\n    }\n    \n    private function update(User $user): void\n    {\n        $user->setUpdatedAt(new DateTime());\n        \n        $stmt = $this->connection->prepare(\n            'UPDATE users SET email = :email, name = :name, updated_at = :updated_at WHERE id = :id'\n        );\n        \n        $stmt->execute([\n            'id' => $user->getId(),\n            'email' => $user->getEmail(),\n            'name' => $user->getName(),\n            'updated_at' => $user->getUpdatedAt()->format('Y-m-d H:i:s')\n        ]);\n    }\n    \n    private function hydrate(array $data): User\n    {\n        return new User(\n            (int) $data['id'],\n            $data['email'],\n            $data['name'],\n            new DateTime($data['created_at']),\n            $data['updated_at'] ? new DateTime($data['updated_at']) : null\n        );\n    }\n}\n\n// Unit of Work Pattern (often used with Repository)\nclass UnitOfWork\n{\n    private array $new = [];\n    private array $dirty = [];\n    private array $removed = [];\n    \n    public function __construct(\n        private UserRepositoryInterface $userRepository\n    ) {}\n    \n    public function registerNew(User $user): void\n    {\n        $this->new[] = $user;\n    }\n    \n    public function registerDirty(User $user): void\n    {\n        if (!in_array($user, $this->new, true)) {\n            $this->dirty[] = $user;\n        }\n    }\n    \n    public function registerRemoved(User $user): void\n    {\n        if (in_array($user, $this->new, true)) {\n            $this->new = array_filter($this->new, fn($u) => $u !== $user);\n        } else {\n            $this->dirty = array_filter($this->dirty, fn($u) => $u !== $user);\n            $this->removed[] = $user;\n        }\n    }\n    \n    public function commit(): void\n    {\n        foreach ($this->new as $user) {\n            $this->userRepository->save($user);\n        }\n        \n        foreach ($this->dirty as $user) {\n            $this->userRepository->save($user);\n        }\n        \n        foreach ($this->removed as $user) {\n            $this->userRepository->delete($user);\n        }\n        \n        $this->clear();\n    }\n    \n    private function clear(): void\n    {\n        $this->new = [];\n        $this->dirty = [];\n        $this->removed = [];\n    }\n}"
    },
    "traits": {
      "description": "Enables horizontal code reuse and composition.",
      "whenToUse": "When you need to share functionality between unrelated classes.",
      "example": "<?php\n// Timestampable trait\ntrait Timestampable\n{\n    protected DateTime $createdAt;\n    protected ?DateTime $updatedAt = null;\n    \n    public function getCreatedAt(): DateTime\n    {\n        return $this->createdAt;\n    }\n    \n    public function getUpdatedAt(): ?DateTime\n    {\n        return $this->updatedAt;\n    }\n    \n    public function setCreatedAt(DateTime $createdAt): void\n    {\n        $this->createdAt = $createdAt;\n    }\n    \n    public function setUpdatedAt(?DateTime $updatedAt): void\n    {\n        $this->updatedAt = $updatedAt;\n    }\n    \n    public function touch(): void\n    {\n        $this->updatedAt = new DateTime();\n    }\n    \n    public function initializeTimestamps(): void\n    {\n        $this->createdAt = new DateTime();\n        $this->updatedAt = null;\n    }\n}\n\n// Sluggable trait\ntrait Sluggable\n{\n    protected string $slug;\n    \n    public function getSlug(): string\n    {\n        return $this->slug;\n    }\n    \n    public function setSlug(string $slug): void\n    {\n        $this->slug = $this->sanitizeSlug($slug);\n    }\n    \n    public function generateSlug(string $from): void\n    {\n        $this->slug = $this->createSlug($from);\n    }\n    \n    protected function createSlug(string $text): string\n    {\n        // Convert to lowercase\n        $text = mb_strtolower($text, 'UTF-8');\n        \n        // Replace non-alphanumeric characters with hyphens\n        $text = preg_replace('/[^a-z0-9]+/i', '-', $text);\n        \n        // Remove leading/trailing hyphens\n        $text = trim($text, '-');\n        \n        return $text;\n    }\n    \n    protected function sanitizeSlug(string $slug): string\n    {\n        return preg_replace('/[^a-z0-9-]/i', '', $slug);\n    }\n}\n\n// Logger trait\ntrait LoggerAware\n{\n    protected ?LoggerInterface $logger = null;\n    \n    public function setLogger(LoggerInterface $logger): void\n    {\n        $this->logger = $logger;\n    }\n    \n    protected function log(string $level, string $message, array $context = []): void\n    {\n        if ($this->logger) {\n            $this->logger->log($level, $message, $context);\n        }\n    }\n    \n    protected function logInfo(string $message, array $context = []): void\n    {\n        $this->log('info', $message, $context);\n    }\n    \n    protected function logError(string $message, array $context = []): void\n    {\n        $this->log('error', $message, $context);\n    }\n    \n    protected function logDebug(string $message, array $context = []): void\n    {\n        $this->log('debug', $message, $context);\n    }\n}\n\n// Using multiple traits\nclass Article\n{\n    use Timestampable, Sluggable, LoggerAware;\n    \n    private string $title;\n    private string $content;\n    private string $author;\n    \n    public function __construct(string $title, string $content, string $author)\n    {\n        $this->title = $title;\n        $this->content = $content;\n        $this->author = $author;\n        \n        $this->initializeTimestamps();\n        $this->generateSlug($title);\n        \n        $this->logInfo('Article created', ['title' => $title]);\n    }\n    \n    public function publish(): void\n    {\n        $this->touch();\n        $this->logInfo('Article published', ['slug' => $this->getSlug()]);\n    }\n}\n\n// Trait with abstract methods\ntrait Cacheable\n{\n    protected array $cache = [];\n    \n    abstract protected function getCacheKey(): string;\n    abstract protected function getCacheTtl(): int;\n    \n    protected function getFromCache(string $key): mixed\n    {\n        $fullKey = $this->getCacheKey() . ':' . $key;\n        \n        if (isset($this->cache[$fullKey])) {\n            $cached = $this->cache[$fullKey];\n            if ($cached['expires'] > time()) {\n                return $cached['value'];\n            }\n            unset($this->cache[$fullKey]);\n        }\n        \n        return null;\n    }\n    \n    protected function setCache(string $key, mixed $value): void\n    {\n        $fullKey = $this->getCacheKey() . ':' . $key;\n        $this->cache[$fullKey] = [\n            'value' => $value,\n            'expires' => time() + $this->getCacheTtl()\n        ];\n    }\n    \n    protected function clearCache(): void\n    {\n        $prefix = $this->getCacheKey() . ':';\n        foreach (array_keys($this->cache) as $key) {\n            if (str_starts_with($key, $prefix)) {\n                unset($this->cache[$key]);\n            }\n        }\n    }\n}\n\n// Trait composition and conflict resolution\ntrait A\n{\n    public function hello()\n    {\n        return 'Hello from A';\n    }\n}\n\ntrait B\n{\n    public function hello()\n    {\n        return 'Hello from B';\n    }\n}\n\nclass Example\n{\n    use A, B {\n        B::hello insteadof A;\n        A::hello as helloFromA;\n    }\n}"
    },
    "strategy": {
      "description": "Encapsulates algorithms and makes them interchangeable.",
      "whenToUse": "When you have multiple algorithms for a task and want to switch between them.",
      "example": "<?php\n// Strategy Interface\ninterface SortingStrategy\n{\n    public function sort(array $data): array;\n}\n\n// Concrete Strategies\nclass BubbleSort implements SortingStrategy\n{\n    public function sort(array $data): array\n    {\n        $n = count($data);\n        for ($i = 0; $i < $n - 1; $i++) {\n            for ($j = 0; $j < $n - $i - 1; $j++) {\n                if ($data[$j] > $data[$j + 1]) {\n                    $temp = $data[$j];\n                    $data[$j] = $data[$j + 1];\n                    $data[$j + 1] = $temp;\n                }\n            }\n        }\n        return $data;\n    }\n}\n\nclass QuickSort implements SortingStrategy\n{\n    public function sort(array $data): array\n    {\n        if (count($data) <= 1) {\n            return $data;\n        }\n        \n        $pivot = $data[0];\n        $left = [];\n        $right = [];\n        \n        for ($i = 1; $i < count($data); $i++) {\n            if ($data[$i] < $pivot) {\n                $left[] = $data[$i];\n            } else {\n                $right[] = $data[$i];\n            }\n        }\n        \n        return array_merge(\n            $this->sort($left),\n            [$pivot],\n            $this->sort($right)\n        );\n    }\n}\n\nclass MergeSort implements SortingStrategy\n{\n    public function sort(array $data): array\n    {\n        if (count($data) <= 1) {\n            return $data;\n        }\n        \n        $middle = count($data) / 2;\n        $left = array_slice($data, 0, $middle);\n        $right = array_slice($data, $middle);\n        \n        $left = $this->sort($left);\n        $right = $this->sort($right);\n        \n        return $this->merge($left, $right);\n    }\n    \n    private function merge(array $left, array $right): array\n    {\n        $result = [];\n        \n        while (count($left) > 0 && count($right) > 0) {\n            if ($left[0] <= $right[0]) {\n                $result[] = array_shift($left);\n            } else {\n                $result[] = array_shift($right);\n            }\n        }\n        \n        return array_merge($result, $left, $right);\n    }\n}\n\n// Context\nclass Sorter\n{\n    private SortingStrategy $strategy;\n    \n    public function __construct(SortingStrategy $strategy)\n    {\n        $this->strategy = $strategy;\n    }\n    \n    public function setStrategy(SortingStrategy $strategy): void\n    {\n        $this->strategy = $strategy;\n    }\n    \n    public function sort(array $data): array\n    {\n        return $this->strategy->sort($data);\n    }\n}\n\n// Payment Strategy Example\ninterface PaymentStrategy\n{\n    public function pay(float $amount): array;\n    public function validatePaymentData(array $data): bool;\n}\n\nclass CreditCardPayment implements PaymentStrategy\n{\n    public function __construct(\n        private string $cardNumber,\n        private string $cvv,\n        private string $expiryDate\n    ) {}\n    \n    public function pay(float $amount): array\n    {\n        if (!$this->validatePaymentData([\n            'card_number' => $this->cardNumber,\n            'cvv' => $this->cvv,\n            'expiry_date' => $this->expiryDate\n        ])) {\n            return ['success' => false, 'error' => 'Invalid payment data'];\n        }\n        \n        // Process payment\n        return [\n            'success' => true,\n            'transaction_id' => uniqid('cc_'),\n            'amount' => $amount,\n            'method' => 'credit_card'\n        ];\n    }\n    \n    public function validatePaymentData(array $data): bool\n    {\n        // Validate card number (simple check)\n        if (!preg_match('/^\\d{16}$/', $data['card_number'])) {\n            return false;\n        }\n        \n        // Validate CVV\n        if (!preg_match('/^\\d{3,4}$/', $data['cvv'])) {\n            return false;\n        }\n        \n        // Validate expiry date\n        if (!preg_match('/^(0[1-9]|1[0-2])\\/\\d{2}$/', $data['expiry_date'])) {\n            return false;\n        }\n        \n        return true;\n    }\n}\n\nclass PayPalPayment implements PaymentStrategy\n{\n    public function __construct(\n        private string $email,\n        private string $password\n    ) {}\n    \n    public function pay(float $amount): array\n    {\n        if (!$this->validatePaymentData([\n            'email' => $this->email,\n            'password' => $this->password\n        ])) {\n            return ['success' => false, 'error' => 'Invalid PayPal credentials'];\n        }\n        \n        // Process PayPal payment\n        return [\n            'success' => true,\n            'transaction_id' => uniqid('pp_'),\n            'amount' => $amount,\n            'method' => 'paypal'\n        ];\n    }\n    \n    public function validatePaymentData(array $data): bool\n    {\n        return filter_var($data['email'], FILTER_VALIDATE_EMAIL) && \n               strlen($data['password']) >= 8;\n    }\n}\n\nclass PaymentProcessor\n{\n    private PaymentStrategy $strategy;\n    \n    public function __construct(PaymentStrategy $strategy)\n    {\n        $this->strategy = $strategy;\n    }\n    \n    public function setPaymentMethod(PaymentStrategy $strategy): void\n    {\n        $this->strategy = $strategy;\n    }\n    \n    public function processPayment(float $amount): array\n    {\n        return $this->strategy->pay($amount);\n    }\n}\n\n// Usage with callable strategies\nclass DataProcessor\n{\n    private $strategy;\n    \n    public function __construct(callable $strategy)\n    {\n        $this->strategy = $strategy;\n    }\n    \n    public function process(array $data): array\n    {\n        return ($this->strategy)($data);\n    }\n    \n    public function setStrategy(callable $strategy): void\n    {\n        $this->strategy = $strategy;\n    }\n}\n\n// Usage\n$processor = new DataProcessor(function($data) {\n    return array_map('strtoupper', $data);\n});\n\n$processor->setStrategy(function($data) {\n    return array_filter($data, fn($item) => strlen($item) > 3);\n});"
    },
    "observer": {
      "description": "Implements event-driven architecture with observers and subjects.",
      "whenToUse": "When objects need to be notified of state changes in other objects.",
      "example": "<?php\n// SPL Observer Pattern\nclass User implements \\SplSubject\n{\n    private string $email;\n    private string $name;\n    private \\SplObjectStorage $observers;\n    \n    public function __construct(string $email, string $name)\n    {\n        $this->email = $email;\n        $this->name = $name;\n        $this->observers = new \\SplObjectStorage();\n    }\n    \n    public function attach(\\SplObserver $observer): void\n    {\n        $this->observers->attach($observer);\n    }\n    \n    public function detach(\\SplObserver $observer): void\n    {\n        $this->observers->detach($observer);\n    }\n    \n    public function notify(): void\n    {\n        foreach ($this->observers as $observer) {\n            $observer->update($this);\n        }\n    }\n    \n    public function changeEmail(string $email): void\n    {\n        $oldEmail = $this->email;\n        $this->email = $email;\n        $this->notify();\n    }\n    \n    public function getEmail(): string\n    {\n        return $this->email;\n    }\n    \n    public function getName(): string\n    {\n        return $this->name;\n    }\n}\n\nclass EmailChangeLogger implements \\SplObserver\n{\n    public function update(\\SplSubject $subject): void\n    {\n        if ($subject instanceof User) {\n            echo \"User {$subject->getName()} changed email to {$subject->getEmail()}\\n\";\n        }\n    }\n}\n\nclass EmailChangeNotifier implements \\SplObserver\n{\n    public function update(\\SplSubject $subject): void\n    {\n        if ($subject instanceof User) {\n            // Send email notification\n            echo \"Sending email notification to {$subject->getEmail()}\\n\";\n        }\n    }\n}\n\n// Custom Event System\ninterface EventListenerInterface\n{\n    public function handle(Event $event): void;\n}\n\nclass Event\n{\n    public function __construct(\n        private string $name,\n        private mixed $subject = null,\n        private array $data = []\n    ) {}\n    \n    public function getName(): string\n    {\n        return $this->name;\n    }\n    \n    public function getSubject(): mixed\n    {\n        return $this->subject;\n    }\n    \n    public function getData(): array\n    {\n        return $this->data;\n    }\n    \n    public function stopPropagation(): void\n    {\n        $this->propagationStopped = true;\n    }\n    \n    public function isPropagationStopped(): bool\n    {\n        return $this->propagationStopped ?? false;\n    }\n}\n\nclass EventDispatcher\n{\n    private array $listeners = [];\n    \n    public function addListener(string $eventName, EventListenerInterface|callable $listener, int $priority = 0): void\n    {\n        $this->listeners[$eventName][$priority][] = $listener;\n    }\n    \n    public function removeListener(string $eventName, EventListenerInterface|callable $listener): void\n    {\n        if (!isset($this->listeners[$eventName])) {\n            return;\n        }\n        \n        foreach ($this->listeners[$eventName] as $priority => &$listeners) {\n            $key = array_search($listener, $listeners, true);\n            if ($key !== false) {\n                unset($listeners[$key]);\n            }\n        }\n    }\n    \n    public function dispatch(Event $event): void\n    {\n        $eventName = $event->getName();\n        \n        if (!isset($this->listeners[$eventName])) {\n            return;\n        }\n        \n        // Sort by priority\n        krsort($this->listeners[$eventName]);\n        \n        foreach ($this->listeners[$eventName] as $listeners) {\n            foreach ($listeners as $listener) {\n                if ($event->isPropagationStopped()) {\n                    return;\n                }\n                \n                if ($listener instanceof EventListenerInterface) {\n                    $listener->handle($event);\n                } elseif (is_callable($listener)) {\n                    $listener($event);\n                }\n            }\n        }\n    }\n    \n    public function hasListeners(string $eventName): bool\n    {\n        return !empty($this->listeners[$eventName]);\n    }\n}\n\n// Event-driven Model\nclass Order\n{\n    private string $id;\n    private string $status;\n    private EventDispatcher $eventDispatcher;\n    \n    public function __construct(string $id, EventDispatcher $eventDispatcher)\n    {\n        $this->id = $id;\n        $this->status = 'pending';\n        $this->eventDispatcher = $eventDispatcher;\n        \n        $this->eventDispatcher->dispatch(\n            new Event('order.created', $this)\n        );\n    }\n    \n    public function confirm(): void\n    {\n        if ($this->status !== 'pending') {\n            throw new \\Exception('Cannot confirm order in status: ' . $this->status);\n        }\n        \n        $this->status = 'confirmed';\n        \n        $this->eventDispatcher->dispatch(\n            new Event('order.confirmed', $this)\n        );\n    }\n    \n    public function ship(): void\n    {\n        if ($this->status !== 'confirmed') {\n            throw new \\Exception('Cannot ship unconfirmed order');\n        }\n        \n        $this->status = 'shipped';\n        \n        $this->eventDispatcher->dispatch(\n            new Event('order.shipped', $this)\n        );\n    }\n    \n    public function getId(): string\n    {\n        return $this->id;\n    }\n    \n    public function getStatus(): string\n    {\n        return $this->status;\n    }\n}\n\n// Usage\n$dispatcher = new EventDispatcher();\n\n// Add listeners\n$dispatcher->addListener('order.created', function(Event $event) {\n    $order = $event->getSubject();\n    echo \"New order created: {$order->getId()}\\n\";\n});\n\n$dispatcher->addListener('order.confirmed', function(Event $event) {\n    $order = $event->getSubject();\n    echo \"Order confirmed: {$order->getId()}\\n\";\n    // Send confirmation email\n});\n\n$dispatcher->addListener('order.shipped', function(Event $event) {\n    $order = $event->getSubject();\n    echo \"Order shipped: {$order->getId()}\\n\";\n    // Update inventory\n});"
    },
    "decorator": {
      "description": "Adds new functionality to objects dynamically without altering their structure.",
      "whenToUse": "When you want to add responsibilities to objects dynamically.",
      "example": "<?php\n// Component interface\ninterface Coffee\n{\n    public function getCost(): float;\n    public function getDescription(): string;\n}\n\n// Concrete component\nclass SimpleCoffee implements Coffee\n{\n    public function getCost(): float\n    {\n        return 2.0;\n    }\n    \n    public function getDescription(): string\n    {\n        return 'Simple coffee';\n    }\n}\n\n// Decorator abstract class\nabstract class CoffeeDecorator implements Coffee\n{\n    protected Coffee $coffee;\n    \n    public function __construct(Coffee $coffee)\n    {\n        $this->coffee = $coffee;\n    }\n    \n    public function getCost(): float\n    {\n        return $this->coffee->getCost();\n    }\n    \n    public function getDescription(): string\n    {\n        return $this->coffee->getDescription();\n    }\n}\n\n// Concrete decorators\nclass MilkDecorator extends CoffeeDecorator\n{\n    public function getCost(): float\n    {\n        return parent::getCost() + 0.5;\n    }\n    \n    public function getDescription(): string\n    {\n        return parent::getDescription() . ', with milk';\n    }\n}\n\nclass SugarDecorator extends CoffeeDecorator\n{\n    public function getCost(): float\n    {\n        return parent::getCost() + 0.2;\n    }\n    \n    public function getDescription(): string\n    {\n        return parent::getDescription() . ', with sugar';\n    }\n}\n\nclass WhipCreamDecorator extends CoffeeDecorator\n{\n    public function getCost(): float\n    {\n        return parent::getCost() + 0.7;\n    }\n    \n    public function getDescription(): string\n    {\n        return parent::getDescription() . ', with whip cream';\n    }\n}\n\n// Cache Decorator Example\ninterface DataSourceInterface\n{\n    public function getData(string $key): ?array;\n    public function setData(string $key, array $data): void;\n}\n\nclass DatabaseDataSource implements DataSourceInterface\n{\n    public function getData(string $key): ?array\n    {\n        echo \"Fetching from database: {$key}\\n\";\n        // Simulate database query\n        return ['id' => $key, 'data' => 'from database'];\n    }\n    \n    public function setData(string $key, array $data): void\n    {\n        echo \"Saving to database: {$key}\\n\";\n        // Save to database\n    }\n}\n\nclass CacheDecorator implements DataSourceInterface\n{\n    private array $cache = [];\n    private DataSourceInterface $dataSource;\n    private int $ttl;\n    \n    public function __construct(DataSourceInterface $dataSource, int $ttl = 3600)\n    {\n        $this->dataSource = $dataSource;\n        $this->ttl = $ttl;\n    }\n    \n    public function getData(string $key): ?array\n    {\n        // Check cache first\n        if (isset($this->cache[$key])) {\n            $cached = $this->cache[$key];\n            if ($cached['expires'] > time()) {\n                echo \"Cache hit for: {$key}\\n\";\n                return $cached['data'];\n            }\n            unset($this->cache[$key]);\n        }\n        \n        // Cache miss, fetch from source\n        echo \"Cache miss for: {$key}\\n\";\n        $data = $this->dataSource->getData($key);\n        \n        if ($data !== null) {\n            $this->cache[$key] = [\n                'data' => $data,\n                'expires' => time() + $this->ttl\n            ];\n        }\n        \n        return $data;\n    }\n    \n    public function setData(string $key, array $data): void\n    {\n        // Update cache\n        $this->cache[$key] = [\n            'data' => $data,\n            'expires' => time() + $this->ttl\n        ];\n        \n        // Update source\n        $this->dataSource->setData($key, $data);\n    }\n}\n\n// Logger Decorator\nclass LoggerDecorator implements DataSourceInterface\n{\n    private DataSourceInterface $dataSource;\n    private LoggerInterface $logger;\n    \n    public function __construct(DataSourceInterface $dataSource, LoggerInterface $logger)\n    {\n        $this->dataSource = $dataSource;\n        $this->logger = $logger;\n    }\n    \n    public function getData(string $key): ?array\n    {\n        $this->logger->log('info', \"Getting data for key: {$key}\");\n        \n        try {\n            $data = $this->dataSource->getData($key);\n            $this->logger->log('info', \"Successfully retrieved data for key: {$key}\");\n            return $data;\n        } catch (\\Exception $e) {\n            $this->logger->log('error', \"Failed to get data for key: {$key}\", [\n                'exception' => $e->getMessage()\n            ]);\n            throw $e;\n        }\n    }\n    \n    public function setData(string $key, array $data): void\n    {\n        $this->logger->log('info', \"Setting data for key: {$key}\");\n        \n        try {\n            $this->dataSource->setData($key, $data);\n            $this->logger->log('info', \"Successfully set data for key: {$key}\");\n        } catch (\\Exception $e) {\n            $this->logger->log('error', \"Failed to set data for key: {$key}\", [\n                'exception' => $e->getMessage()\n            ]);\n            throw $e;\n        }\n    }\n}\n\n// Usage\n$coffee = new SimpleCoffee();\n$coffee = new MilkDecorator($coffee);\n$coffee = new SugarDecorator($coffee);\n$coffee = new WhipCreamDecorator($coffee);\n\necho $coffee->getDescription() . \" costs $\" . $coffee->getCost() . \"\\n\";\n\n// Layered decorators\n$dataSource = new DatabaseDataSource();\n$dataSource = new CacheDecorator($dataSource, 300);\n$dataSource = new LoggerDecorator($dataSource, new FileLogger('/tmp/data.log'));\n\n$data = $dataSource->getData('user:123');"
    }
  }
}