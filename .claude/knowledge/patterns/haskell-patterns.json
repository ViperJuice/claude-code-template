{
  "language": "haskell",
  "patterns": {
    "monad": {
      "description": "Represents computations as a series of steps that can be composed.",
      "whenToUse": "For sequencing operations with context (IO, Maybe, Either, State, etc.).",
      "example": "-- Maybe Monad for handling failures\nsafeDivide :: Double -> Double -> Maybe Double\nsafeDivide _ 0 = Nothing\nsafeDivide x y = Just (x / y)\n\n-- Using do notation\ncalculation :: Double -> Double -> Double -> Maybe Double\ncalculation x y z = do\n  a <- safeDivide x y\n  b <- safeDivide a z\n  return (b * 2)\n\n-- Using bind (>>=)\ncalculation' :: Double -> Double -> Double -> Maybe Double\ncalculation' x y z = \n  safeDivide x y >>= \\a ->\n  safeDivide a z >>= \\b ->\n  return (b * 2)\n\n-- Custom Monad: Logger\nnewtype Logger a = Logger { runLogger :: (a, [String]) }\n\ninstance Functor Logger where\n  fmap f (Logger (a, log)) = Logger (f a, log)\n\ninstance Applicative Logger where\n  pure a = Logger (a, [])\n  Logger (f, log1) <*> Logger (a, log2) = Logger (f a, log1 ++ log2)\n\ninstance Monad Logger where\n  return = pure\n  Logger (a, log) >>= f = \n    let Logger (b, newLog) = f a\n    in Logger (b, log ++ newLog)\n\nlogMessage :: String -> Logger ()\nlogMessage msg = Logger ((), [msg])\n\n-- State Monad example\nimport Control.Monad.State\n\ntype Stack = [Int]\n\npush :: Int -> State Stack ()\npush x = modify (x:)\n\npop :: State Stack (Maybe Int)\npop = do\n  stack <- get\n  case stack of\n    []     -> return Nothing\n    (x:xs) -> do\n      put xs\n      return (Just x)\n\nstackOperations :: State Stack (Maybe Int)\nstackOperations = do\n  push 3\n  push 5\n  push 7\n  _ <- pop\n  result <- pop\n  return result\n\n-- Reader Monad for dependency injection\nimport Control.Monad.Reader\n\ndata Config = Config\n  { apiUrl :: String\n  , apiKey :: String\n  , timeout :: Int\n  }\n\ntype ConfigReader = Reader Config\n\ngetApiUrl :: ConfigReader String\ngetApiUrl = asks apiUrl\n\ngetApiKey :: ConfigReader String\ngetApiKey = asks apiKey\n\nmakeRequest :: String -> ConfigReader String\nmakeRequest endpoint = do\n  url <- getApiUrl\n  key <- getApiKey\n  return $ \"GET \" ++ url ++ endpoint ++ \" with key: \" ++ key"
    },
    "functor": {
      "description": "Represents types that can be mapped over, preserving structure.",
      "whenToUse": "When you need to transform values inside a context.",
      "example": "-- Basic Functor usage\n-- fmap :: Functor f => (a -> b) -> f a -> f b\n\n-- With lists\naddOne :: [Int] -> [Int]\naddOne = fmap (+1)\n-- addOne [1,2,3] = [2,3,4]\n\n-- With Maybe\nsquareIfPositive :: Int -> Maybe Int\nsquareIfPositive x\n  | x > 0     = Just (x * x)\n  | otherwise = Nothing\n\n-- fmap with Maybe\ndoubleSquare :: Int -> Maybe Int\ndoubleSquare x = fmap (*2) (squareIfPositive x)\n\n-- Custom Functor\ndata Tree a = Leaf a | Branch (Tree a) (Tree a)\n  deriving (Show, Eq)\n\ninstance Functor Tree where\n  fmap f (Leaf x) = Leaf (f x)\n  fmap f (Branch left right) = Branch (fmap f left) (fmap f right)\n\n-- Using custom functor\ntreeExample :: Tree Int\ntreeExample = Branch (Leaf 1) (Branch (Leaf 2) (Leaf 3))\n\n-- fmap (*10) treeExample = Branch (Leaf 10) (Branch (Leaf 20) (Leaf 30))\n\n-- Functor laws\n-- 1. fmap id = id\n-- 2. fmap (f . g) = fmap f . fmap g\n\n-- Bifunctor for types with two type parameters\nimport Data.Bifunctor\n\n-- bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d\nexampleBifunctor :: Either String Int -> Either String String\nexampleBifunctor = bimap (\"Error: \" ++) show\n\n-- Contravariant functor\nnewtype Predicate a = Predicate { getPredicate :: a -> Bool }\n\ninstance Contravariant Predicate where\n  contramap f (Predicate p) = Predicate (p . f)\n\n-- Example: adapting a predicate\nisEven :: Predicate Int\nisEven = Predicate (\\x -> x `mod` 2 == 0)\n\nlengthIsEven :: Predicate String\nlengthIsEven = contramap length isEven"
    },
    "applicative": {
      "description": "Allows applying functions wrapped in a context to values wrapped in a context.",
      "whenToUse": "For combining multiple computations with independent effects.",
      "example": "-- Applicative basics\n-- (<*>) :: Applicative f => f (a -> b) -> f a -> f b\n-- pure :: Applicative f => a -> f a\n\n-- Maybe Applicative\naddMaybe :: Maybe Int -> Maybe Int -> Maybe Int\naddMaybe x y = pure (+) <*> x <*> y\n-- Or using liftA2\naddMaybe' :: Maybe Int -> Maybe Int -> Maybe Int\naddMaybe' = liftA2 (+)\n\n-- List Applicative (cartesian product)\ncolors :: [String]\ncolors = [\"red\", \"green\", \"blue\"]\n\nsizes :: [String]\nsizes = [\"small\", \"large\"]\n\nproducts :: [String]\nproducts = (\\c s -> c ++ \" \" ++ s) <$> colors <*> sizes\n-- Result: [\"red small\",\"red large\",\"green small\",\"green large\",\"blue small\",\"blue large\"]\n\n-- Validation with Applicative\ndata Validation e a = Failure e | Success a\n  deriving (Show, Eq)\n\ninstance Functor (Validation e) where\n  fmap _ (Failure e) = Failure e\n  fmap f (Success a) = Success (f a)\n\ninstance Semigroup e => Applicative (Validation e) where\n  pure = Success\n  Failure e1 <*> Failure e2 = Failure (e1 <> e2)\n  Failure e <*> _ = Failure e\n  _ <*> Failure e = Failure e\n  Success f <*> Success a = Success (f a)\n\n-- Form validation example\ndata User = User\n  { userName :: String\n  , userAge :: Int\n  , userEmail :: String\n  } deriving Show\n\nvalidateName :: String -> Validation [String] String\nvalidateName name\n  | null name = Failure [\"Name cannot be empty\"]\n  | length name < 3 = Failure [\"Name must be at least 3 characters\"]\n  | otherwise = Success name\n\nvalidateAge :: Int -> Validation [String] Int\nvalidateAge age\n  | age < 0 = Failure [\"Age cannot be negative\"]\n  | age > 150 = Failure [\"Age seems unrealistic\"]\n  | otherwise = Success age\n\nvalidateEmail :: String -> Validation [String] String\nvalidateEmail email\n  | '@' `notElem` email = Failure [\"Email must contain @\"]\n  | otherwise = Success email\n\nvalidateUser :: String -> Int -> String -> Validation [String] User\nvalidateUser name age email =\n  User <$> validateName name\n       <*> validateAge age\n       <*> validateEmail email\n\n-- ZipList for parallel application\nimport Control.Applicative\n\n-- ZipList applies functions element-wise\nzipExample :: [Int]\nzipExample = getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [10,20,30]\n-- Result: [11,22,33]"
    },
    "type_class": {
      "description": "Defines a set of functions that can be implemented by multiple types.",
      "whenToUse": "For ad-hoc polymorphism and defining common interfaces.",
      "example": "-- Basic type class definition\nclass Eq a where\n  (==) :: a -> a -> Bool\n  (/=) :: a -> a -> Bool\n  \n  -- Default implementation\n  x /= y = not (x == y)\n\n-- Instance for custom type\ndata Color = Red | Green | Blue\n\ninstance Eq Color where\n  Red == Red = True\n  Green == Green = True\n  Blue == Blue = True\n  _ == _ = False\n\n-- Multi-parameter type class\nclass Convertible a b where\n  convert :: a -> b\n\ninstance Convertible Int String where\n  convert = show\n\ninstance Convertible String Int where\n  convert = read\n\ninstance Convertible Int Double where\n  convert = fromIntegral\n\n-- Type class with constraints\nclass (Eq a, Show a) => Pretty a where\n  pretty :: a -> String\n  pretty = show  -- default implementation\n\n-- Associated types (type families)\nclass Container c where\n  type Elem c :: *\n  empty :: c\n  insert :: Elem c -> c -> c\n  member :: Elem c -> c -> Bool\n\ninstance Container [a] where\n  type Elem [a] = a\n  empty = []\n  insert = (:)\n  member = elem\n\ninstance Ord a => Container (Set a) where\n  type Elem (Set a) = a\n  empty = Set.empty\n  insert = Set.insert\n  member = Set.member\n\n-- Functional dependencies\nclass Collects c e | c -> e where\n  emptyCollection :: c\n  insertElement :: e -> c -> c\n  memberElement :: e -> c -> Bool\n\ninstance Eq a => Collects [a] a where\n  emptyCollection = []\n  insertElement = (:)\n  memberElement = elem\n\n-- Higher-kinded type classes\nclass Mappable f where\n  mapOver :: (a -> b) -> f a -> f b\n\ninstance Mappable [] where\n  mapOver = map\n\ninstance Mappable Maybe where\n  mapOver = fmap\n\ninstance Mappable (Either e) where\n  mapOver = fmap\n\n-- Deriving type classes\ndata Point = Point Double Double\n  deriving (Eq, Show, Ord)\n\n-- Newtype deriving\nnewtype Age = Age Int\n  deriving (Eq, Ord, Show, Num)\n\n-- DerivingVia extension\n{-# LANGUAGE DerivingVia #-}\nnewtype Reverse a = Reverse a\n  deriving (Eq, Show) via a\n\ninstance Ord a => Ord (Reverse a) where\n  Reverse x <= Reverse y = y <= x"
    },
    "lens": {
      "description": "Composable getters and setters for nested data structures.",
      "whenToUse": "For accessing and modifying deeply nested immutable data structures.",
      "example": "-- Simple lens implementation\ndata Lens s a = Lens\n  { view :: s -> a\n  , set :: a -> s -> s\n  }\n\n-- Lens composition\ncompose :: Lens s a -> Lens a b -> Lens s b\ncompose l1 l2 = Lens\n  { view = view l2 . view l1\n  , set = \\b s -> set l1 (set l2 b (view l1 s)) s\n  }\n\n-- Example data types\ndata Address = Address\n  { _street :: String\n  , _city :: String\n  , _zipCode :: String\n  } deriving Show\n\ndata Person = Person\n  { _name :: String\n  , _age :: Int\n  , _address :: Address\n  } deriving Show\n\n-- Manual lens creation\naddressLens :: Lens Person Address\naddressLens = Lens _address (\\a p -> p { _address = a })\n\nstreetLens :: Lens Address String\nstreetLens = Lens _street (\\s a -> a { _street = s })\n\n-- Composed lens\npersonStreetLens :: Lens Person String\npersonStreetLens = compose addressLens streetLens\n\n-- Using the lens\nexamplePerson :: Person\nexamplePerson = Person \"Alice\" 30 (Address \"123 Main St\" \"Boston\" \"02101\")\n\n-- Get street\ncurrentStreet :: String\ncurrentStreet = view personStreetLens examplePerson\n\n-- Set street\nupdatedPerson :: Person\nupdatedPerson = set personStreetLens \"456 Elm St\" examplePerson\n\n-- Lens operators (simplified)\ninfixr 4 .~\n(.~) :: Lens s a -> a -> s -> s\n(.~) = set\n\ninfixl 8 ^.\n(^.) :: s -> Lens s a -> a\n(^.) s l = view l s\n\n-- With lens library\n{-# LANGUAGE TemplateHaskell #-}\nimport Control.Lens\n\ndata Company = Company\n  { _companyName :: String\n  , _employees :: [Employee]\n  } deriving Show\n\ndata Employee = Employee\n  { _employeeName :: String\n  , _salary :: Double\n  , _department :: String\n  } deriving Show\n\n-- Generate lenses\nmakeLenses ''Company\nmakeLenses ''Employee\n\n-- Using generated lenses\nraiseSalary :: Double -> Employee -> Employee\nraiseSalary percent = salary *~ (1 + percent / 100)\n\n-- Traversing with lenses\nraiseAllSalaries :: Double -> Company -> Company\nraiseAllSalaries percent = employees . traverse . salary *~ (1 + percent / 100)\n\n-- Prisms for sum types\ndata Result a = Error String | Ok a\n  deriving Show\n\nmakePrisms ''Result\n\n-- Using prisms\ngetOk :: Result a -> Maybe a\ngetOk = preview _Ok\n\n-- Lens laws\n-- 1. view l (set l v s) = v\n-- 2. set l (view l s) s = s\n-- 3. set l v (set l u s) = set l v s"
    },
    "free_monad": {
      "description": "Separates the structure of computation from its interpretation.",
      "whenToUse": "For building DSLs and separating program description from execution.",
      "example": "-- Free monad definition\ndata Free f a\n  = Pure a\n  | Free (f (Free f a))\n\ninstance Functor f => Functor (Free f) where\n  fmap f (Pure a) = Pure (f a)\n  fmap f (Free fa) = Free (fmap (fmap f) fa)\n\ninstance Functor f => Applicative (Free f) where\n  pure = Pure\n  Pure f <*> a = fmap f a\n  Free f <*> a = Free (fmap (<*> a) f)\n\ninstance Functor f => Monad (Free f) where\n  return = Pure\n  Pure a >>= f = f a\n  Free m >>= f = Free (fmap (>>= f) m)\n\n-- DSL for a simple calculator\ndata CalculatorF next\n  = Add Int next\n  | Multiply Int next\n  | Recall (Int -> next)\n  deriving Functor\n\ntype Calculator = Free CalculatorF\n\n-- Smart constructors\nadd :: Int -> Calculator ()\nadd n = Free (Add n (Pure ()))\n\nmultiply :: Int -> Calculator ()\nmultiply n = Free (Multiply n (Pure ()))\n\nrecall :: Calculator Int\nrecall = Free (Recall Pure)\n\n-- Example program\ncalculatorProgram :: Calculator Int\ncalculatorProgram = do\n  add 10\n  multiply 2\n  add 5\n  result <- recall\n  return result\n\n-- Interpreter\nrunCalculator :: Calculator a -> Int -> (a, Int)\nrunCalculator (Pure a) acc = (a, acc)\nrunCalculator (Free (Add n next)) acc = runCalculator next (acc + n)\nrunCalculator (Free (Multiply n next)) acc = runCalculator next (acc * n)\nrunCalculator (Free (Recall next)) acc = runCalculator (next acc) acc\n\n-- Alternative interpreter (logging)\nrunCalculatorWithLog :: Calculator a -> Int -> ([String], a, Int)\nrunCalculatorWithLog (Pure a) acc = ([], a, acc)\nrunCalculatorWithLog (Free (Add n next)) acc =\n  let (log, a, acc') = runCalculatorWithLog next (acc + n)\n  in (\"Added \" ++ show n : log, a, acc')\nrunCalculatorWithLog (Free (Multiply n next)) acc =\n  let (log, a, acc') = runCalculatorWithLog next (acc * n)\n  in (\"Multiplied by \" ++ show n : log, a, acc')\nrunCalculatorWithLog (Free (Recall next)) acc =\n  let (log, a, acc') = runCalculatorWithLog (next acc) acc\n  in (\"Recalled \" ++ show acc : log, a, acc')\n\n-- File system DSL\ndata FileSystemF next\n  = ReadFile FilePath (String -> next)\n  | WriteFile FilePath String next\n  | DeleteFile FilePath next\n  | ListDirectory FilePath ([FilePath] -> next)\n  deriving Functor\n\ntype FileSystem = Free FileSystemF\n\nreadFileFS :: FilePath -> FileSystem String\nreadFileFS path = Free (ReadFile path Pure)\n\nwriteFileFS :: FilePath -> String -> FileSystem ()\nwriteFileFS path content = Free (WriteFile path content (Pure ()))\n\ndeleteFileFS :: FilePath -> FileSystem ()\ndeleteFileFS path = Free (DeleteFile path (Pure ()))\n\nlistDirectoryFS :: FilePath -> FileSystem [FilePath]\nlistDirectoryFS path = Free (ListDirectory path Pure)\n\n-- Example file system program\nfileProgram :: FileSystem ()\nfileProgram = do\n  content <- readFileFS \"input.txt\"\n  let processed = map toUpper content\n  writeFileFS \"output.txt\" processed\n  files <- listDirectoryFS \".\"\n  when (\"temp.txt\" `elem` files) $\n    deleteFileFS \"temp.txt\""
    },
    "gadt": {
      "description": "Generalized Algebraic Data Types allow more precise type information.",
      "whenToUse": "For type-safe DSLs, ensuring invariants at the type level.",
      "example": "{-# LANGUAGE GADTs #-}\n\n-- Expression DSL with GADTs\ndata Expr a where\n  IntLit    :: Int -> Expr Int\n  BoolLit   :: Bool -> Expr Bool\n  Add       :: Expr Int -> Expr Int -> Expr Int\n  Mul       :: Expr Int -> Expr Int -> Expr Int\n  Eq        :: Eq a => Expr a -> Expr a -> Expr Bool\n  If        :: Expr Bool -> Expr a -> Expr a -> Expr a\n\n-- Type-safe evaluator\neval :: Expr a -> a\neval (IntLit n) = n\neval (BoolLit b) = b\neval (Add x y) = eval x + eval y\neval (Mul x y) = eval x * eval y\neval (Eq x y) = eval x == eval y\neval (If cond t f) = if eval cond then eval t else eval f\n\n-- Example expressions\nexpr1 :: Expr Int\nexpr1 = Add (IntLit 5) (Mul (IntLit 3) (IntLit 2))\n-- eval expr1 = 11\n\nexpr2 :: Expr Bool\nexpr2 = Eq (Add (IntLit 1) (IntLit 1)) (IntLit 2)\n-- eval expr2 = True\n\n-- Vector with length in type\ndata Vec n a where\n  VNil  :: Vec 'Z a\n  VCons :: a -> Vec n a -> Vec ('S n) a\n\ndata Nat = Z | S Nat\n\n-- Type-safe head\nvhead :: Vec ('S n) a -> a\nvhead (VCons x _) = x\n-- vhead VNil would be a type error!\n\n-- Type-safe append\nvappend :: Vec n a -> Vec m a -> Vec (Plus n m) a\nvappend VNil ys = ys\nvappend (VCons x xs) ys = VCons x (vappend xs ys)\n\ntype family Plus (n :: Nat) (m :: Nat) :: Nat where\n  Plus 'Z m = m\n  Plus ('S n) m = 'S (Plus n m)\n\n-- Format strings\ndata Format a where\n  Lit   :: String -> Format a -> Format a\n  Str   :: Format a -> Format (String -> a)\n  Dec   :: Format a -> Format (Int -> a)\n  End   :: Format String\n\n-- Type-safe printf\nprintf :: Format a -> a\nprintf = sprintf \"\"\n  where\n    sprintf :: String -> Format a -> a\n    sprintf acc (Lit s rest) = sprintf (acc ++ s) rest\n    sprintf acc (Str rest) = \\s -> sprintf (acc ++ s) rest\n    sprintf acc (Dec rest) = \\n -> sprintf (acc ++ show n) rest\n    sprintf acc End = acc\n\n-- Usage\ngreeting :: String\ngreeting = printf (Str (Lit \" is \" (Dec (Lit \" years old\" End)))) \"Alice\" 30\n-- Result: \"Alice is 30 years old\"\n\n-- Authentication states\ndata AuthState = LoggedOut | LoggedIn\n\ndata Session s where\n  Guest    :: Session 'LoggedOut\n  User     :: String -> String -> Session 'LoggedIn\n\n-- Operations that require authentication\nsecureOperation :: Session 'LoggedIn -> IO ()\nsecureOperation (User name token) = putStrLn $ \"Performing secure operation for \" ++ name\n\n-- This won't compile:\n-- secureOperation Guest\n\n-- State machine with GADTs\ndata DoorState = Opened | Closed | Locked\n\ndata Door s where\n  MkDoor :: Door s\n\nopen :: Door 'Closed -> Door 'Opened\nopen MkDoor = MkDoor\n\nclose :: Door 'Opened -> Door 'Closed\nclose MkDoor = MkDoor\n\nlock :: Door 'Closed -> Door 'Locked\nlock MkDoor = MkDoor\n\nunlock :: Door 'Locked -> Door 'Closed\nunlock MkDoor = MkDoor"
    },
    "smart_constructor": {
      "description": "Constructor functions that validate inputs and maintain invariants.",
      "whenToUse": "When you need to ensure data validity and hide implementation details.",
      "example": "-- Email type with validation\nmodule Email\n  ( Email  -- Opaque type export\n  , mkEmail\n  , emailToString\n  , emailDomain\n  ) where\n\nimport Data.Char (isAlphaNum)\n\n-- Email type (constructor not exported)\nnewtype Email = Email String\n  deriving (Eq, Show)\n\n-- Smart constructor\nmkEmail :: String -> Maybe Email\nmkEmail str\n  | isValidEmail str = Just (Email str)\n  | otherwise = Nothing\n  where\n    isValidEmail s = \n      case break (== '@') s of\n        (local, '@':domain) -> \n          not (null local) && \n          not (null domain) && \n          '.' `elem` domain &&\n          all isValidChar local\n        _ -> False\n    isValidChar c = isAlphaNum c || c `elem` \"._-\"\n\nemailToString :: Email -> String\nemailToString (Email str) = str\n\nemailDomain :: Email -> String\nemailDomain (Email str) = drop 1 $ dropWhile (/= '@') str\n\n-- NonEmpty list with smart constructor\ndata NonEmpty a = NonEmpty a [a]\n  deriving (Show, Eq)\n\n-- Smart constructor ensures non-emptiness\nnonEmpty :: [a] -> Maybe (NonEmpty a)\nnonEmpty [] = Nothing\nnonEmpty (x:xs) = Just (NonEmpty x xs)\n\n-- Safe operations\nhead' :: NonEmpty a -> a\nhead' (NonEmpty x _) = x\n\ntail' :: NonEmpty a -> [a]\ntail' (NonEmpty _ xs) = xs\n\n-- Convert back to list\ntoList :: NonEmpty a -> [a]\ntoList (NonEmpty x xs) = x : xs\n\n-- Age with bounds checking\nnewtype Age = Age Int\n  deriving (Eq, Ord, Show)\n\nmkAge :: Int -> Maybe Age\nmkAge n\n  | n >= 0 && n <= 150 = Just (Age n)\n  | otherwise = Nothing\n\nageValue :: Age -> Int\nageValue (Age n) = n\n\n-- Positive number type\nnewtype Positive = Positive Double\n  deriving (Eq, Ord, Show)\n\nmkPositive :: Double -> Maybe Positive\nmkPositive x\n  | x > 0 = Just (Positive x)\n  | otherwise = Nothing\n\n-- Safe arithmetic preserving invariant\naddPositive :: Positive -> Positive -> Positive\naddPositive (Positive x) (Positive y) = Positive (x + y)\n\nmultiplyPositive :: Positive -> Positive -> Positive\nmultiplyPositive (Positive x) (Positive y) = Positive (x * y)\n\n-- May break invariant, so returns Maybe\nsubtractPositive :: Positive -> Positive -> Maybe Positive\nsubtractPositive (Positive x) (Positive y)\n  | x > y = Just (Positive (x - y))\n  | otherwise = Nothing\n\n-- Refined types pattern\ndata Refined p a = Refined a\n\nclass Predicate p a where\n  validate :: p -> a -> Bool\n\nrefine :: Predicate p a => p -> a -> Maybe (Refined p a)\nrefine p x\n  | validate p x = Just (Refined x)\n  | otherwise = Nothing\n\nunrefine :: Refined p a -> a\nunrefine (Refined x) = x\n\n-- Example predicates\ndata Positive'\ninstance Predicate Positive' Double where\n  validate _ x = x > 0\n\ndata LengthBetween = LengthBetween Int Int\ninstance Predicate LengthBetween String where\n  validate (LengthBetween min max) s = \n    let len = length s\n    in len >= min && len <= max"
    },
    "phantom_type": {
      "description": "Type parameters that don't appear in the data constructor but provide type safety.",
      "whenToUse": "For encoding states or properties at the type level.",
      "example": "{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\n\n-- Temperature with units\ndata Celsius\ndata Fahrenheit\ndata Kelvin\n\nnewtype Temperature (unit :: *) = Temperature Double\n  deriving (Eq, Show)\n\n-- Smart constructors\ncelsius :: Double -> Temperature Celsius\ncelsius = Temperature\n\nfahrenheit :: Double -> Temperature Fahrenheit\nfahrenheit = Temperature\n\nkelvin :: Double -> Temperature Kelvin\nkelvin = Temperature\n\n-- Type-safe conversions\ncelsiusToFahrenheit :: Temperature Celsius -> Temperature Fahrenheit\ncelsiusToFahrenheit (Temperature c) = Temperature (c * 9/5 + 32)\n\nfahrenheitToCelsius :: Temperature Fahrenheit -> Temperature Celsius\nfahrenheitToCelsius (Temperature f) = Temperature ((f - 32) * 5/9)\n\ncelsiusToKelvin :: Temperature Celsius -> Temperature Kelvin\ncelsiusToKelvin (Temperature c) = Temperature (c + 273.15)\n\n-- File handles with state\ndata ReadMode\ndata WriteMode\ndata ReadWriteMode\n\nnewtype Handle mode = Handle FilePath\n\nopenForReading :: FilePath -> IO (Handle ReadMode)\nopenForReading path = return (Handle path)\n\nopenForWriting :: FilePath -> IO (Handle WriteMode)\nopenForWriting path = return (Handle path)\n\nopenForReadWrite :: FilePath -> IO (Handle ReadWriteMode)\nopenForReadWrite path = return (Handle path)\n\n-- Type-safe operations\nreadFrom :: Handle ReadMode -> IO String\nreadFrom (Handle path) = readFile path\n\nreadFromRW :: Handle ReadWriteMode -> IO String\nreadFromRW (Handle path) = readFile path\n\nwriteTo :: Handle WriteMode -> String -> IO ()\nwriteTo (Handle path) content = writeFile path content\n\nwriteToRW :: Handle ReadWriteMode -> String -> IO ()\nwriteToRW (Handle path) content = writeFile path content\n\n-- Currency types\ndata USD\ndata EUR\ndata GBP\n\nnewtype Money (currency :: *) = Money Rational\n  deriving (Eq, Ord, Show)\n\n-- Smart constructors\nusd :: Rational -> Money USD\nusd = Money\n\neur :: Rational -> Money EUR\neur = Money\n\ngbp :: Rational -> Money GBP\ngbp = Money\n\n-- Type-safe arithmetic (same currency only)\naddMoney :: Money c -> Money c -> Money c\naddMoney (Money a) (Money b) = Money (a + b)\n\nsubtractMoney :: Money c -> Money c -> Money c\nsubtractMoney (Money a) (Money b) = Money (a - b)\n\n-- Exchange rates\nexchangeRate :: (Money USD -> Money EUR)\nexchangeRate (Money amount) = Money (amount * 0.85)\n\n-- Builder pattern with phantom types\ndata Incomplete\ndata Complete\n\ndata Builder s = Builder\n  { buildName :: Maybe String\n  , buildAge :: Maybe Int\n  , buildEmail :: Maybe String\n  }\n\nemptyBuilder :: Builder Incomplete\nemptyBuilder = Builder Nothing Nothing Nothing\n\nsetName :: String -> Builder s -> Builder s\nsetName name b = b { buildName = Just name }\n\nsetAge :: Int -> Builder s -> Builder s\nsetAge age b = b { buildAge = Just age }\n\nsetEmail :: String -> Builder s -> Builder s\nsetEmail email b = b { buildEmail = Just email }\n\n-- Finalize only works if all fields are set\nfinalize :: Builder s -> Maybe (Builder Complete)\nfinalize b@(Builder (Just _) (Just _) (Just _)) = \n  Just (b { buildName = buildName b\n          , buildAge = buildAge b\n          , buildEmail = buildEmail b\n          })\nfinalize _ = Nothing\n\n-- Extract only from complete builder\nbuild :: Builder Complete -> (String, Int, String)\nbuild (Builder (Just n) (Just a) (Just e)) = (n, a, e)\nbuild _ = error \"Impossible: Complete builder has all fields\""
    }
  }
}