{
  "language": "wasm",
  "patterns": {
    "hybrid_architecture": {
      "description": "Strategically combine WebAssembly for computation-intensive tasks with JavaScript for UI and flexibility.",
      "whenToUse": "When optimizing performance bottlenecks while maintaining development velocity.",
      "example": ";; Module definition with imports and exports\n(module\n  ;; Import JavaScript functions for DOM manipulation\n  (import \"js\" \"updateUI\" (func $updateUI (param i32)))\n  (import \"js\" \"console_log\" (func $log (param i32 i32)))\n  \n  ;; Import memory from JavaScript\n  (import \"js\" \"memory\" (memory 1))\n  \n  ;; Export functions for JavaScript to call\n  (export \"processData\" (func $processData))\n  (export \"fibonacci\" (func $fibonacci))\n  (export \"matrixMultiply\" (func $matrixMultiply))\n  \n  ;; Efficient fibonacci calculation\n  (func $fibonacci (param $n i32) (result i32)\n    (local $a i32)\n    (local $b i32)\n    (local $temp i32)\n    (local $i i32)\n    \n    ;; Handle base cases\n    (if (i32.le_s (local.get $n) (i32.const 1))\n      (return (local.get $n))\n    )\n    \n    ;; Initialize\n    (local.set $a (i32.const 0))\n    (local.set $b (i32.const 1))\n    (local.set $i (i32.const 2))\n    \n    ;; Main loop\n    (loop $continue\n      (local.set $temp (i32.add (local.get $a) (local.get $b)))\n      (local.set $a (local.get $b))\n      (local.set $b (local.get $temp))\n      \n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      \n      (br_if $continue\n        (i32.le_s (local.get $i) (local.get $n))\n      )\n    )\n    \n    (local.get $b)\n  )\n  \n  ;; Process large array of data\n  (func $processData (param $ptr i32) (param $len i32) (result f32)\n    (local $sum f32)\n    (local $i i32)\n    (local $value f32)\n    \n    (local.set $sum (f32.const 0))\n    (local.set $i (i32.const 0))\n    \n    (loop $process_loop\n      ;; Load value from memory\n      (local.set $value \n        (f32.load (i32.add (local.get $ptr) \n                           (i32.mul (local.get $i) (i32.const 4))))\n      )\n      \n      ;; Process value (example: apply transformation)\n      (local.set $value \n        (f32.mul (local.get $value) (f32.const 1.5))\n      )\n      \n      ;; Accumulate\n      (local.set $sum \n        (f32.add (local.get $sum) (local.get $value))\n      )\n      \n      ;; Increment counter\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      \n      ;; Continue if not done\n      (br_if $process_loop\n        (i32.lt_u (local.get $i) (local.get $len))\n      )\n    )\n    \n    ;; Update UI periodically\n    (call $updateUI (i32.const 100))\n    \n    (local.get $sum)\n  )\n)\n\n// JavaScript integration\nconst wasmModule = await WebAssembly.instantiateStreaming(\n  fetch('compute.wasm'),\n  {\n    js: {\n      memory: new WebAssembly.Memory({ initial: 256 }),\n      updateUI: (progress) => {\n        document.getElementById('progress').value = progress;\n      },\n      console_log: (ptr, len) => {\n        const bytes = new Uint8Array(memory.buffer, ptr, len);\n        console.log(new TextDecoder().decode(bytes));\n      }\n    }\n  }\n);\n\n// Use WASM for heavy computation\nconst result = wasmModule.instance.exports.processData(dataPtr, dataLength);\n\n// Use JavaScript for UI updates\nupdateChart(result);"
    },
    "streaming_compilation": {
      "description": "Use streaming APIs for efficient loading and compilation of WebAssembly modules.",
      "whenToUse": "For optimal loading performance, especially with large modules.",
      "example": "// Efficient module loading with streaming\nasync function loadWasmModule(url, importObject) {\n  try {\n    // Preferred: streaming compilation\n    const module = await WebAssembly.instantiateStreaming(\n      fetch(url),\n      importObject\n    );\n    return module;\n  } catch (e) {\n    // Fallback for servers without proper MIME type\n    console.warn('Streaming compilation failed, falling back to ArrayBuffer');\n    \n    const response = await fetch(url);\n    const bytes = await response.arrayBuffer();\n    const module = await WebAssembly.instantiate(bytes, importObject);\n    return module;\n  }\n}\n\n// Parallel loading of multiple modules\nasync function loadModules() {\n  const moduleUrls = [\n    'physics.wasm',\n    'graphics.wasm',\n    'audio.wasm'\n  ];\n  \n  // Load and compile in parallel\n  const modulePromises = moduleUrls.map(url => \n    WebAssembly.compileStreaming(fetch(url))\n  );\n  \n  const compiledModules = await Promise.all(modulePromises);\n  \n  // Instantiate when needed\n  const instances = new Map();\n  \n  return {\n    getInstance: async (moduleName, importObject) => {\n      const index = moduleUrls.findIndex(url => url.includes(moduleName));\n      if (index === -1) throw new Error(`Module ${moduleName} not found`);\n      \n      if (!instances.has(moduleName)) {\n        const instance = await WebAssembly.instantiate(\n          compiledModules[index],\n          importObject\n        );\n        instances.set(moduleName, instance);\n      }\n      \n      return instances.get(moduleName);\n    }\n  };\n}\n\n// Caching compiled modules\nconst moduleCache = new Map();\n\nasync function getCachedModule(url) {\n  if (!moduleCache.has(url)) {\n    const module = await WebAssembly.compileStreaming(fetch(url));\n    moduleCache.set(url, module);\n  }\n  return moduleCache.get(url);\n}\n\n// Progressive loading with feedback\nasync function loadWithProgress(url, onProgress) {\n  const response = await fetch(url);\n  const reader = response.body.getReader();\n  const contentLength = +response.headers.get('Content-Length');\n  \n  let receivedLength = 0;\n  const chunks = [];\n  \n  while(true) {\n    const {done, value} = await reader.read();\n    \n    if (done) break;\n    \n    chunks.push(value);\n    receivedLength += value.length;\n    \n    onProgress(receivedLength / contentLength);\n  }\n  \n  const chunksAll = new Uint8Array(receivedLength);\n  let position = 0;\n  for(let chunk of chunks) {\n    chunksAll.set(chunk, position);\n    position += chunk.length;\n  }\n  \n  return WebAssembly.instantiate(chunksAll);\n}"
    },
    "memory_management": {
      "description": "Efficient memory sharing and management between WebAssembly and JavaScript.",
      "whenToUse": "When passing data between WASM and JavaScript, especially for large datasets.",
      "example": ";; WebAssembly module with memory management\n(module\n  ;; Define memory with initial size and max size\n  (memory (export \"memory\") 1 10)  ;; 1 initial page, max 10 pages\n  \n  ;; Memory allocator\n  (global $heap_base (mut i32) (i32.const 1024))  ;; Start after reserved space\n  \n  ;; Simple malloc implementation\n  (func $malloc (param $size i32) (result i32)\n    (local $ptr i32)\n    \n    ;; Get current heap pointer\n    (local.set $ptr (global.get $heap_base))\n    \n    ;; Update heap pointer\n    (global.set $heap_base \n      (i32.add (local.get $ptr) (local.get $size))\n    )\n    \n    ;; Check if we need to grow memory\n    (if (i32.gt_u (global.get $heap_base)\n                  (i32.mul (memory.size) (i32.const 65536)))\n      (then\n        ;; Calculate pages needed\n        (drop (memory.grow \n          (i32.div_u \n            (i32.add (local.get $size) (i32.const 65535))\n            (i32.const 65536)\n          )\n        ))\n      )\n    )\n    \n    (local.get $ptr)\n  )\n  \n  ;; Free memory (simple version - just for demonstration)\n  (func $free (param $ptr i32)\n    ;; In a real implementation, maintain a free list\n    ;; For now, this is a no-op\n  )\n  \n  ;; Export allocator functions\n  (export \"malloc\" (func $malloc))\n  (export \"free\" (func $free))\n)\n\n// JavaScript memory management utilities\nclass WasmMemoryManager {\n  constructor(wasmInstance) {\n    this.instance = wasmInstance;\n    this.memory = wasmInstance.exports.memory;\n    this.malloc = wasmInstance.exports.malloc;\n    this.free = wasmInstance.exports.free;\n  }\n  \n  // Allocate typed array in WASM memory\n  allocateFloat32Array(length) {\n    const bytes = length * 4;\n    const ptr = this.malloc(bytes);\n    \n    return {\n      ptr,\n      length,\n      array: new Float32Array(this.memory.buffer, ptr, length),\n      free: () => this.free(ptr)\n    };\n  }\n  \n  // Copy JavaScript array to WASM memory\n  copyToWasm(jsArray, TypedArrayConstructor = Float32Array) {\n    const bytes = jsArray.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    const ptr = this.malloc(bytes);\n    \n    const wasmArray = new TypedArrayConstructor(\n      this.memory.buffer, \n      ptr, \n      jsArray.length\n    );\n    wasmArray.set(jsArray);\n    \n    return { ptr, length: jsArray.length };\n  }\n  \n  // Read string from WASM memory\n  readString(ptr, length) {\n    const bytes = new Uint8Array(this.memory.buffer, ptr, length);\n    return new TextDecoder().decode(bytes);\n  }\n  \n  // Write string to WASM memory\n  writeString(str) {\n    const encoder = new TextEncoder();\n    const encoded = encoder.encode(str);\n    const ptr = this.malloc(encoded.length + 1);\n    \n    const bytes = new Uint8Array(this.memory.buffer, ptr, encoded.length + 1);\n    bytes.set(encoded);\n    bytes[encoded.length] = 0; // Null terminator\n    \n    return { ptr, length: encoded.length };\n  }\n}\n\n// Usage example\nconst memManager = new WasmMemoryManager(wasmInstance);\n\n// Allocate array in WASM\nconst wasmData = memManager.allocateFloat32Array(1000);\nwasmData.array.fill(42.0);\n\n// Process in WASM\nconst result = wasmInstance.exports.processArray(wasmData.ptr, wasmData.length);\n\n// Clean up\nwasmData.free();\n\n// Zero-copy data sharing\nclass SharedBuffer {\n  constructor(wasmMemory, size) {\n    this.memory = wasmMemory;\n    this.size = size;\n    this.views = new Map();\n  }\n  \n  getView(offset, length, TypedArrayConstructor) {\n    const key = `${offset}-${length}-${TypedArrayConstructor.name}`;\n    \n    if (!this.views.has(key)) {\n      this.views.set(key, new TypedArrayConstructor(\n        this.memory.buffer,\n        offset,\n        length\n      ));\n    }\n    \n    return this.views.get(key);\n  }\n  \n  // Handle memory growth\n  onMemoryGrow() {\n    // Recreate views after memory growth\n    this.views.clear();\n  }\n}"
    },
    "worker_integration": {
      "description": "Run WebAssembly in Web Workers for non-blocking computation.",
      "whenToUse": "For CPU-intensive tasks that shouldn't block the main thread.",
      "example": "// Worker script (worker.js)\nlet wasmInstance = null;\n\n// Initialize WASM module once\nself.addEventListener('message', async (e) => {\n  const { type, data } = e.data;\n  \n  switch (type) {\n    case 'init':\n      try {\n        // Compile and instantiate module\n        const module = await WebAssembly.instantiate(data.wasmBytes, {\n          env: {\n            memory: new WebAssembly.Memory({ initial: 256 }),\n            log: (value) => console.log('WASM:', value)\n          }\n        });\n        \n        wasmInstance = module.instance;\n        self.postMessage({ type: 'ready' });\n      } catch (error) {\n        self.postMessage({ type: 'error', error: error.message });\n      }\n      break;\n      \n    case 'compute':\n      if (!wasmInstance) {\n        self.postMessage({ \n          type: 'error', \n          error: 'WASM not initialized' \n        });\n        return;\n      }\n      \n      try {\n        // Perform computation\n        const result = wasmInstance.exports[data.function](...data.args);\n        \n        self.postMessage({\n          type: 'result',\n          id: data.id,\n          result\n        });\n      } catch (error) {\n        self.postMessage({\n          type: 'error',\n          id: data.id,\n          error: error.message\n        });\n      }\n      break;\n  }\n});\n\n// Main thread worker pool\nclass WasmWorkerPool {\n  constructor(workerScript, wasmUrl, poolSize = navigator.hardwareConcurrency) {\n    this.workers = [];\n    this.taskQueue = [];\n    this.busyWorkers = new Set();\n    this.readyPromise = this.initialize(workerScript, wasmUrl, poolSize);\n  }\n  \n  async initialize(workerScript, wasmUrl, poolSize) {\n    // Fetch WASM bytes once\n    const wasmResponse = await fetch(wasmUrl);\n    const wasmBytes = await wasmResponse.arrayBuffer();\n    \n    // Create worker pool\n    const initPromises = [];\n    \n    for (let i = 0; i < poolSize; i++) {\n      const worker = new Worker(workerScript);\n      this.workers.push(worker);\n      \n      const initPromise = new Promise((resolve, reject) => {\n        const handler = (e) => {\n          if (e.data.type === 'ready') {\n            worker.removeEventListener('message', handler);\n            resolve();\n          } else if (e.data.type === 'error') {\n            reject(new Error(e.data.error));\n          }\n        };\n        \n        worker.addEventListener('message', handler);\n        worker.postMessage({ type: 'init', data: { wasmBytes } });\n      });\n      \n      initPromises.push(initPromise);\n    }\n    \n    await Promise.all(initPromises);\n  }\n  \n  async execute(functionName, ...args) {\n    await this.readyPromise;\n    \n    return new Promise((resolve, reject) => {\n      const task = {\n        id: Math.random().toString(36).substr(2, 9),\n        function: functionName,\n        args,\n        resolve,\n        reject\n      };\n      \n      this.scheduleTask(task);\n    });\n  }\n  \n  scheduleTask(task) {\n    // Find available worker\n    const availableWorker = this.workers.find(w => !this.busyWorkers.has(w));\n    \n    if (availableWorker) {\n      this.runTask(availableWorker, task);\n    } else {\n      this.taskQueue.push(task);\n    }\n  }\n  \n  runTask(worker, task) {\n    this.busyWorkers.add(worker);\n    \n    const handler = (e) => {\n      if (e.data.id !== task.id) return;\n      \n      worker.removeEventListener('message', handler);\n      this.busyWorkers.delete(worker);\n      \n      if (e.data.type === 'result') {\n        task.resolve(e.data.result);\n      } else if (e.data.type === 'error') {\n        task.reject(new Error(e.data.error));\n      }\n      \n      // Process next task if any\n      if (this.taskQueue.length > 0) {\n        const nextTask = this.taskQueue.shift();\n        this.runTask(worker, nextTask);\n      }\n    };\n    \n    worker.addEventListener('message', handler);\n    worker.postMessage({\n      type: 'compute',\n      data: {\n        id: task.id,\n        function: task.function,\n        args: task.args\n      }\n    });\n  }\n  \n  terminate() {\n    this.workers.forEach(w => w.terminate());\n    this.workers = [];\n    this.taskQueue = [];\n    this.busyWorkers.clear();\n  }\n}\n\n// Usage\nconst pool = new WasmWorkerPool('worker.js', 'compute.wasm');\n\n// Execute tasks in parallel\nconst results = await Promise.all([\n  pool.execute('fibonacci', 40),\n  pool.execute('processData', dataPtr, dataLength),\n  pool.execute('matrixMultiply', matrixA, matrixB)\n]);"
    },
    "simd_optimization": {
      "description": "Use SIMD instructions for parallel data processing.",
      "whenToUse": "For operations on arrays of numerical data that can benefit from vectorization.",
      "example": ";; SIMD-optimized image processing\n(module\n  ;; Import memory\n  (import \"js\" \"memory\" (memory 1))\n  \n  ;; Export optimized functions\n  (export \"grayscaleImage\" (func $grayscaleImage))\n  (export \"applyGaussianBlur\" (func $applyGaussianBlur))\n  \n  ;; Convert RGBA image to grayscale using SIMD\n  (func $grayscaleImage \n    (param $src i32)      ;; Source image pointer\n    (param $dst i32)      ;; Destination image pointer  \n    (param $pixels i32)   ;; Number of pixels\n    (local $i i32)\n    (local $rgba v128)\n    (local $weights v128)\n    (local $gray v128)\n    \n    ;; Load grayscale weights (0.299, 0.587, 0.114, 0)\n    (local.set $weights \n      (f32x4.const 0.299 0.587 0.114 0.0)\n    )\n    \n    (local.set $i (i32.const 0))\n    \n    (loop $pixel_loop\n      ;; Load 4 pixels (16 bytes) as RGBA values\n      (local.set $rgba (v128.load (i32.add (local.get $src) \n                                           (i32.mul (local.get $i) (i32.const 16)))))\n      \n      ;; Convert bytes to floats\n      (local.set $rgba (f32x4.convert_i32x4_u \n                        (i32x4.extend_low_i16x8_u \n                         (i16x8.extend_low_i8x16_u $rgba))))\n      \n      ;; Calculate grayscale value\n      (local.set $gray (f32x4.mul (local.get $rgba) (local.get $weights)))\n      \n      ;; Sum components\n      (local.set $gray (f32x4.add (local.get $gray)\n                                  (f32x4.shuffle 1 1 1 1 (local.get $gray) (local.get $gray))))\n      (local.set $gray (f32x4.add (local.get $gray)\n                                  (f32x4.shuffle 2 2 2 2 (local.get $gray) (local.get $gray))))\n      \n      ;; Store grayscale value in all channels\n      (v128.store (i32.add (local.get $dst) (i32.mul (local.get $i) (i32.const 16)))\n                  (local.get $gray))\n      \n      ;; Increment and continue\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br_if $pixel_loop (i32.lt_u (local.get $i) \n                                   (i32.div_u (local.get $pixels) (i32.const 4))))\n    )\n  )\n  \n  ;; Vector addition using SIMD\n  (func $vectorAdd\n    (param $a i32)      ;; First vector pointer\n    (param $b i32)      ;; Second vector pointer\n    (param $result i32) ;; Result vector pointer\n    (param $length i32) ;; Vector length\n    (local $i i32)\n    (local $vec_a v128)\n    (local $vec_b v128)\n    \n    ;; Process 4 floats at a time\n    (local.set $i (i32.const 0))\n    \n    (loop $vector_loop\n      ;; Load 4 floats from each vector\n      (local.set $vec_a (v128.load (i32.add (local.get $a)\n                                           (i32.mul (local.get $i) (i32.const 16)))))\n      (local.set $vec_b (v128.load (i32.add (local.get $b)\n                                           (i32.mul (local.get $i) (i32.const 16)))))\n      \n      ;; Add vectors\n      (v128.store (i32.add (local.get $result)\n                          (i32.mul (local.get $i) (i32.const 16)))\n                  (f32x4.add (local.get $vec_a) (local.get $vec_b)))\n      \n      ;; Increment by 4\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      \n      (br_if $vector_loop \n        (i32.lt_u (i32.mul (local.get $i) (i32.const 4)) (local.get $length)))\n    )\n    \n    ;; Handle remaining elements\n    (local.set $i (i32.mul (local.get $i) (i32.const 4)))\n    (loop $remainder_loop\n      (if (i32.lt_u (local.get $i) (local.get $length))\n        (then\n          (f32.store (i32.add (local.get $result) (i32.mul (local.get $i) (i32.const 4)))\n                     (f32.add (f32.load (i32.add (local.get $a) \n                                               (i32.mul (local.get $i) (i32.const 4))))\n                             (f32.load (i32.add (local.get $b)\n                                               (i32.mul (local.get $i) (i32.const 4))))))\n          (local.set $i (i32.add (local.get $i) (i32.const 1)))\n          (br $remainder_loop)\n        )\n      )\n    )\n  )\n)\n\n// JavaScript SIMD feature detection and fallback\nclass SimdProcessor {\n  constructor(wasmInstance) {\n    this.instance = wasmInstance;\n    this.simdSupported = this.checkSimdSupport();\n  }\n  \n  checkSimdSupport() {\n    try {\n      // Try to instantiate a minimal WASM module with SIMD\n      const simdTest = new Uint8Array([\n        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n        0x01, 0x05, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02,\n        0x01, 0x00, 0x07, 0x08, 0x01, 0x04, 0x74, 0x65,\n        0x73, 0x74, 0x00, 0x00, 0x0a, 0x0a, 0x01, 0x08,\n        0x00, 0xfd, 0x0f, 0xfd, 0x0f, 0x1a, 0x0b\n      ]);\n      \n      new WebAssembly.Module(simdTest);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  processImage(imageData) {\n    if (this.simdSupported) {\n      // Use SIMD-optimized function\n      const srcPtr = this.allocateImageData(imageData);\n      const dstPtr = this.allocateImageData(imageData);\n      \n      this.instance.exports.grayscaleImage(\n        srcPtr, \n        dstPtr, \n        imageData.width * imageData.height\n      );\n      \n      return this.readImageData(dstPtr, imageData.width, imageData.height);\n    } else {\n      // Fallback to scalar implementation\n      return this.grayscaleScalar(imageData);\n    }\n  }\n  \n  grayscaleScalar(imageData) {\n    const data = imageData.data;\n    const result = new Uint8ClampedArray(data.length);\n    \n    for (let i = 0; i < data.length; i += 4) {\n      const gray = Math.round(\n        data[i] * 0.299 +     // R\n        data[i + 1] * 0.587 + // G\n        data[i + 2] * 0.114   // B\n      );\n      \n      result[i] = gray;     // R\n      result[i + 1] = gray; // G\n      result[i + 2] = gray; // B\n      result[i + 3] = data[i + 3]; // A\n    }\n    \n    return new ImageData(result, imageData.width, imageData.height);\n  }\n}"
    },
    "module_composition": {
      "description": "Compose multiple WASM modules for modular architecture.",
      "whenToUse": "For large applications that benefit from code separation and reusability.",
      "example": ";; Math module (math.wat)\n(module $math\n  ;; Export math functions\n  (export \"add\" (func $add))\n  (export \"multiply\" (func $multiply))\n  (export \"power\" (func $power))\n  \n  (func $add (param $a f64) (param $b f64) (result f64)\n    (f64.add (local.get $a) (local.get $b))\n  )\n  \n  (func $multiply (param $a f64) (param $b f64) (result f64)\n    (f64.mul (local.get $a) (local.get $b))\n  )\n  \n  (func $power (param $base f64) (param $exp i32) (result f64)\n    (local $result f64)\n    (local $i i32)\n    \n    (local.set $result (f64.const 1))\n    (local.set $i (i32.const 0))\n    \n    (loop $power_loop\n      (if (i32.lt_s (local.get $i) (local.get $exp))\n        (then\n          (local.set $result (f64.mul (local.get $result) (local.get $base)))\n          (local.set $i (i32.add (local.get $i) (i32.const 1)))\n          (br $power_loop)\n        )\n      )\n    )\n    \n    (local.get $result)\n  )\n)\n\n;; Physics module (physics.wat)\n(module $physics\n  ;; Import math functions\n  (import \"math\" \"add\" (func $add (param f64 f64) (result f64)))\n  (import \"math\" \"multiply\" (func $multiply (param f64 f64) (result f64)))\n  (import \"math\" \"power\" (func $power (param f64 i32) (result f64)))\n  \n  ;; Import memory\n  (import \"env\" \"memory\" (memory 1))\n  \n  ;; Export physics functions\n  (export \"calculateVelocity\" (func $calculateVelocity))\n  (export \"calculateKineticEnergy\" (func $calculateKineticEnergy))\n  \n  (func $calculateVelocity \n    (param $distance f64) \n    (param $time f64) \n    (result f64)\n    (f64.div (local.get $distance) (local.get $time))\n  )\n  \n  (func $calculateKineticEnergy\n    (param $mass f64)\n    (param $velocity f64)\n    (result f64)\n    (local $v_squared f64)\n    \n    ;; KE = 0.5 * m * vÂ²\n    (local.set $v_squared (call $power (local.get $velocity) (i32.const 2)))\n    (call $multiply \n      (f64.const 0.5)\n      (call $multiply (local.get $mass) (local.get $v_squared))\n    )\n  )\n)\n\n// JavaScript module composition\nclass WasmModuleComposer {\n  constructor() {\n    this.modules = new Map();\n    this.instances = new Map();\n    this.imports = new Map();\n  }\n  \n  async loadModule(name, url) {\n    const response = await fetch(url);\n    const bytes = await response.arrayBuffer();\n    const module = await WebAssembly.compile(bytes);\n    \n    this.modules.set(name, module);\n    \n    // Extract imports for dependency resolution\n    const imports = WebAssembly.Module.imports(module);\n    this.imports.set(name, imports);\n    \n    return module;\n  }\n  \n  async instantiate(name, additionalImports = {}) {\n    if (this.instances.has(name)) {\n      return this.instances.get(name);\n    }\n    \n    const module = this.modules.get(name);\n    if (!module) {\n      throw new Error(`Module ${name} not loaded`);\n    }\n    \n    // Build import object\n    const importObject = { ...additionalImports };\n    \n    // Resolve module dependencies\n    const moduleImports = this.imports.get(name) || [];\n    \n    for (const imp of moduleImports) {\n      if (this.instances.has(imp.module)) {\n        // Import from another WASM module\n        if (!importObject[imp.module]) {\n          importObject[imp.module] = {};\n        }\n        \n        const exportedModule = this.instances.get(imp.module);\n        importObject[imp.module][imp.name] = \n          exportedModule.exports[imp.name];\n      }\n    }\n    \n    // Instantiate module\n    const instance = await WebAssembly.instantiate(module, importObject);\n    this.instances.set(name, instance);\n    \n    return instance;\n  }\n  \n  getExports(name) {\n    const instance = this.instances.get(name);\n    return instance ? instance.exports : null;\n  }\n}\n\n// Usage\nconst composer = new WasmModuleComposer();\n\n// Load modules\nawait Promise.all([\n  composer.loadModule('math', 'math.wasm'),\n  composer.loadModule('physics', 'physics.wasm'),\n  composer.loadModule('graphics', 'graphics.wasm')\n]);\n\n// Instantiate with dependencies\nconst memory = new WebAssembly.Memory({ initial: 256 });\n\n// Math module has no dependencies\nconst mathInstance = await composer.instantiate('math');\n\n// Physics depends on math\nconst physicsInstance = await composer.instantiate('physics', {\n  env: { memory },\n  math: mathInstance.exports\n});\n\n// Use composed modules\nconst velocity = physicsInstance.exports.calculateVelocity(100, 10);\nconst energy = physicsInstance.exports.calculateKineticEnergy(50, velocity);\n\n// Module hot reloading\nclass HotReloadableWasm {\n  constructor(moduleName, url) {\n    this.moduleName = moduleName;\n    this.url = url;\n    this.instance = null;\n    this.version = 0;\n  }\n  \n  async reload() {\n    const newUrl = `${this.url}?v=${++this.version}`;\n    const response = await fetch(newUrl);\n    const bytes = await response.arrayBuffer();\n    \n    const module = await WebAssembly.compile(bytes);\n    const imports = this.buildImports();\n    \n    this.instance = await WebAssembly.instantiate(module, imports);\n    \n    // Notify listeners\n    this.onReload?.(this.instance);\n    \n    return this.instance;\n  }\n  \n  buildImports() {\n    // Override in subclass\n    return {};\n  }\n}"
    },
    "autotune": {
      "description": "Automatically tune WebAssembly code for optimal performance on target hardware.",
      "whenToUse": "When deploying to diverse hardware configurations and need optimal performance.",
      "example": "// Performance tuning framework\nclass WasmAutoTuner {\n  constructor(wasmModule) {\n    this.module = wasmModule;\n    this.benchmarks = new Map();\n    this.optimalParams = new Map();\n  }\n  \n  // Benchmark different configurations\n  async tune(functionName, paramSpace, testData) {\n    const results = [];\n    \n    for (const params of this.generateParamCombinations(paramSpace)) {\n      const time = await this.benchmark(functionName, params, testData);\n      \n      results.push({\n        params,\n        time,\n        throughput: testData.length / time\n      });\n    }\n    \n    // Find optimal parameters\n    const optimal = results.reduce((best, current) => \n      current.throughput > best.throughput ? current : best\n    );\n    \n    this.optimalParams.set(functionName, optimal.params);\n    \n    return optimal;\n  }\n  \n  async benchmark(functionName, params, testData) {\n    const fn = this.module.exports[functionName];\n    \n    // Warm up\n    for (let i = 0; i < 10; i++) {\n      fn(testData, ...Object.values(params));\n    }\n    \n    // Actual benchmark\n    const iterations = 100;\n    const start = performance.now();\n    \n    for (let i = 0; i < iterations; i++) {\n      fn(testData, ...Object.values(params));\n    }\n    \n    const end = performance.now();\n    return (end - start) / iterations;\n  }\n  \n  generateParamCombinations(paramSpace) {\n    const keys = Object.keys(paramSpace);\n    const combinations = [];\n    \n    function generate(index, current) {\n      if (index === keys.length) {\n        combinations.push({ ...current });\n        return;\n      }\n      \n      const key = keys[index];\n      const values = paramSpace[key];\n      \n      for (const value of values) {\n        current[key] = value;\n        generate(index + 1, current);\n      }\n    }\n    \n    generate(0, {});\n    return combinations;\n  }\n  \n  // Apply optimal parameters\n  createOptimizedFunction(functionName) {\n    const originalFn = this.module.exports[functionName];\n    const optimalParams = this.optimalParams.get(functionName);\n    \n    return (data) => {\n      return originalFn(data, ...Object.values(optimalParams));\n    };\n  }\n}\n\n// Hardware-specific optimization\nclass HardwareOptimizer {\n  constructor() {\n    this.capabilities = this.detectCapabilities();\n  }\n  \n  detectCapabilities() {\n    return {\n      cores: navigator.hardwareConcurrency || 4,\n      memory: this.estimateMemory(),\n      simd: this.checkSimdSupport(),\n      threads: this.checkThreadsSupport(),\n      gpu: this.checkWebGPU()\n    };\n  }\n  \n  estimateMemory() {\n    // Estimate available memory\n    if ('memory' in performance) {\n      return performance.memory.jsHeapSizeLimit;\n    }\n    // Fallback estimation\n    return 2 * 1024 * 1024 * 1024; // 2GB\n  }\n  \n  checkSimdSupport() {\n    try {\n      new WebAssembly.Module(new Uint8Array([\n        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00\n      ]));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  checkThreadsSupport() {\n    return typeof SharedArrayBuffer !== 'undefined';\n  }\n  \n  checkWebGPU() {\n    return 'gpu' in navigator;\n  }\n  \n  selectImplementation(implementations) {\n    // Select best implementation based on hardware\n    if (this.capabilities.simd && implementations.simd) {\n      return implementations.simd;\n    }\n    \n    if (this.capabilities.threads && implementations.threaded) {\n      return implementations.threaded;\n    }\n    \n    return implementations.scalar || implementations.default;\n  }\n  \n  optimizeMemoryLayout(dataSize) {\n    const pageSize = 65536; // WASM page size\n    const cacheLineSize = 64; // Typical cache line size\n    \n    return {\n      pages: Math.ceil(dataSize / pageSize),\n      alignment: cacheLineSize,\n      chunkSize: this.calculateOptimalChunkSize(dataSize)\n    };\n  }\n  \n  calculateOptimalChunkSize(totalSize) {\n    const l1Cache = 32 * 1024; // Typical L1 cache size\n    const cores = this.capabilities.cores;\n    \n    // Aim for chunks that fit in L1 cache\n    const idealChunkSize = Math.floor(l1Cache / 2);\n    const numChunks = Math.ceil(totalSize / idealChunkSize);\n    \n    // Distribute evenly across cores\n    const chunksPerCore = Math.ceil(numChunks / cores);\n    \n    return Math.floor(totalSize / (cores * chunksPerCore));\n  }\n}\n\n// Usage\nconst tuner = new WasmAutoTuner(wasmModule);\nconst optimizer = new HardwareOptimizer();\n\n// Tune matrix multiplication tile size\nconst paramSpace = {\n  tileSize: [16, 32, 64, 128],\n  unrollFactor: [1, 2, 4, 8]\n};\n\nconst optimal = await tuner.tune('matrixMultiply', paramSpace, testMatrices);\nconsole.log('Optimal parameters:', optimal.params);\n\n// Create optimized function\nconst optimizedMultiply = tuner.createOptimizedFunction('matrixMultiply');\n\n// Select implementation based on hardware\nconst implementation = optimizer.selectImplementation({\n  scalar: wasmModule.exports.matrixMultiplyScalar,\n  simd: wasmModule.exports.matrixMultiplySIMD,\n  threaded: wasmModule.exports.matrixMultiplyThreaded\n});"
    }
  }
}