{
  "language": "python",
  "patterns": {
    "singleton": {
      "description": "Ensures a class has only one instance throughout the application.",
      "whenToUse": "When you need exactly one instance of a class (e.g., configuration manager, database connection pool).",
      "example": "class Singleton:\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Alternative: Using decorator\ndef singleton(cls):\n    instances = {}\n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return get_instance\n\n@singleton\nclass Database:\n    def __init__(self):\n        self.connection = self._connect()"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes.",
      "whenToUse": "When you need to create objects based on runtime conditions or configuration.",
      "example": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def make_sound(self):\n        pass\n\nclass Dog(Animal):\n    def make_sound(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def make_sound(self):\n        return \"Meow!\"\n\nclass AnimalFactory:\n    @staticmethod\n    def create_animal(animal_type: str) -> Animal:\n        if animal_type == \"dog\":\n            return Dog()\n        elif animal_type == \"cat\":\n            return Cat()\n        else:\n            raise ValueError(f\"Unknown animal type: {animal_type}\")"
    },
    "builder": {
      "description": "Constructs complex objects step by step.",
      "whenToUse": "When creating objects with many optional parameters or complex initialization.",
      "example": "class ServerConfig:\n    def __init__(self):\n        self.host = \"localhost\"\n        self.port = 8080\n        self.timeout = 30\n        self.debug = False\n\nclass ServerConfigBuilder:\n    def __init__(self):\n        self.config = ServerConfig()\n    \n    def with_host(self, host: str):\n        self.config.host = host\n        return self\n    \n    def with_port(self, port: int):\n        self.config.port = port\n        return self\n    \n    def with_timeout(self, timeout: int):\n        self.config.timeout = timeout\n        return self\n    \n    def with_debug(self, debug: bool = True):\n        self.config.debug = debug\n        return self\n    \n    def build(self) -> ServerConfig:\n        return self.config\n\n# Usage: config = ServerConfigBuilder().with_host(\"0.0.0.0\").with_port(9000).build()"
    },
    "decorator": {
      "description": "Adds new functionality to objects without altering their structure.",
      "whenToUse": "When you want to add responsibilities to objects dynamically.",
      "example": "from functools import wraps\nimport time\n\n# Function decorator\ndef timer(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"{func.__name__} took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer\ndef slow_function():\n    time.sleep(1)\n\n# Class decorator pattern\nclass Component:\n    def operation(self):\n        return \"Component\"\n\nclass Decorator(Component):\n    def __init__(self, component: Component):\n        self._component = component\n    \n    def operation(self):\n        return f\"Decorated({self._component.operation()})\""
    },
    "context_manager": {
      "description": "Manages resources using with statements, ensuring proper cleanup.",
      "whenToUse": "When working with resources that need setup and cleanup (files, connections, locks).",
      "example": "from contextlib import contextmanager\nimport threading\n\n# Class-based context manager\nclass DatabaseConnection:\n    def __enter__(self):\n        self.conn = self._connect()\n        return self.conn\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.conn.close()\n        if exc_type:\n            print(f\"Error occurred: {exc_val}\")\n        return False  # Re-raise exception\n\n# Decorator-based context manager\n@contextmanager\ndef file_manager(filename, mode):\n    f = open(filename, mode)\n    try:\n        yield f\n    finally:\n        f.close()\n\n# Thread lock context manager\nlock = threading.Lock()\n\nwith lock:\n    # Critical section\n    pass"
    },
    "observer": {
      "description": "Defines a one-to-many dependency between objects.",
      "whenToUse": "When changes to one object require updating multiple dependent objects.",
      "example": "from typing import List, Protocol\n\nclass Observer(Protocol):\n    def update(self, message: str) -> None:\n        ...\n\nclass Subject:\n    def __init__(self):\n        self._observers: List[Observer] = []\n        self._state = None\n    \n    def attach(self, observer: Observer) -> None:\n        self._observers.append(observer)\n    \n    def detach(self, observer: Observer) -> None:\n        self._observers.remove(observer)\n    \n    def notify(self, message: str) -> None:\n        for observer in self._observers:\n            observer.update(message)\n    \n    @property\n    def state(self):\n        return self._state\n    \n    @state.setter\n    def state(self, value):\n        self._state = value\n        self.notify(f\"State changed to {value}\")\n\nclass ConcreteObserver:\n    def __init__(self, name: str):\n        self.name = name\n    \n    def update(self, message: str) -> None:\n        print(f\"{self.name} received: {message}\")"
    },
    "strategy": {
      "description": "Defines a family of algorithms and makes them interchangeable.",
      "whenToUse": "When you have multiple ways to perform a task and want to switch between them.",
      "example": "from abc import ABC, abstractmethod\nfrom typing import List\n\nclass SortStrategy(ABC):\n    @abstractmethod\n    def sort(self, data: List[int]) -> List[int]:\n        pass\n\nclass BubbleSort(SortStrategy):\n    def sort(self, data: List[int]) -> List[int]:\n        arr = data.copy()\n        n = len(arr)\n        for i in range(n):\n            for j in range(0, n-i-1):\n                if arr[j] > arr[j+1]:\n                    arr[j], arr[j+1] = arr[j+1], arr[j]\n        return arr\n\nclass QuickSort(SortStrategy):\n    def sort(self, data: List[int]) -> List[int]:\n        if len(data) <= 1:\n            return data\n        pivot = data[len(data) // 2]\n        left = [x for x in data if x < pivot]\n        middle = [x for x in data if x == pivot]\n        right = [x for x in data if x > pivot]\n        return self.sort(left) + middle + self.sort(right)\n\nclass Sorter:\n    def __init__(self, strategy: SortStrategy):\n        self._strategy = strategy\n    \n    def sort(self, data: List[int]) -> List[int]:\n        return self._strategy.sort(data)"
    },
    "iterator": {
      "description": "Provides a way to access elements of a collection sequentially.",
      "whenToUse": "When you need to traverse a collection without exposing its internal structure.",
      "example": "class Node:\n    def __init__(self, value, next=None):\n        self.value = value\n        self.next = next\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, value):\n        if not self.head:\n            self.head = Node(value)\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = Node(value)\n    \n    def __iter__(self):\n        current = self.head\n        while current:\n            yield current.value\n            current = current.next\n\n# Custom iterator class\nclass Counter:\n    def __init__(self, start, end):\n        self.current = start\n        self.end = end\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current < self.end:\n            number = self.current\n            self.current += 1\n            return number\n        raise StopIteration"
    },
    "property": {
      "description": "Controls access to attributes using getter, setter, and deleter methods.",
      "whenToUse": "When you need to add validation, lazy loading, or computed properties.",
      "example": "class Temperature:\n    def __init__(self, celsius=0):\n        self._celsius = celsius\n    \n    @property\n    def celsius(self):\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero is not possible\")\n        self._celsius = value\n    \n    @property\n    def fahrenheit(self):\n        return self._celsius * 9/5 + 32\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        self.celsius = (value - 32) * 5/9\n\n# Cached property\nfrom functools import cached_property\n\nclass DataProcessor:\n    def __init__(self, data):\n        self.data = data\n    \n    @cached_property\n    def processed_data(self):\n        # Expensive computation, cached after first access\n        return self._process_data()"
    },
    "mixin": {
      "description": "Provides additional functionality to classes through multiple inheritance.",
      "whenToUse": "When you want to add common functionality to multiple unrelated classes.",
      "example": "import json\n\nclass JsonMixin:\n    def to_json(self):\n        return json.dumps(self.__dict__)\n    \n    @classmethod\n    def from_json(cls, json_str):\n        data = json.loads(json_str)\n        return cls(**data)\n\nclass TimestampMixin:\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.created_at = datetime.now()\n        self.updated_at = self.created_at\n    \n    def update(self):\n        self.updated_at = datetime.now()\n\nclass User(JsonMixin, TimestampMixin):\n    def __init__(self, name, email):\n        super().__init__()\n        self.name = name\n        self.email = email\n\n# Usage\nuser = User(\"Alice\", \"alice@example.com\")\njson_str = user.to_json()\nuser2 = User.from_json(json_str)"
    },
    "dependency_injection": {
      "description": "Provides dependencies to an object rather than having it create them.",
      "whenToUse": "When you want to decouple object creation from business logic and improve testability.",
      "example": "from typing import Protocol\n\nclass EmailSender(Protocol):\n    def send(self, to: str, subject: str, body: str) -> None:\n        ...\n\nclass SMTPEmailSender:\n    def __init__(self, host: str, port: int):\n        self.host = host\n        self.port = port\n    \n    def send(self, to: str, subject: str, body: str) -> None:\n        # SMTP implementation\n        print(f\"Sending email to {to} via SMTP\")\n\nclass MockEmailSender:\n    def send(self, to: str, subject: str, body: str) -> None:\n        print(f\"Mock: Email to {to} - {subject}\")\n\nclass UserService:\n    def __init__(self, email_sender: EmailSender):\n        self.email_sender = email_sender\n    \n    def register_user(self, email: str, name: str) -> None:\n        # Business logic\n        self.email_sender.send(\n            to=email,\n            subject=\"Welcome!\",\n            body=f\"Hello {name}, welcome to our service!\"\n        )\n\n# Production\nemail_sender = SMTPEmailSender(\"smtp.gmail.com\", 587)\nuser_service = UserService(email_sender)\n\n# Testing\nmock_sender = MockEmailSender()\ntest_service = UserService(mock_sender)"
    },
    "dataclass": {
      "description": "Reduces boilerplate code for classes that primarily store data.",
      "whenToUse": "When creating classes that mainly hold data with minimal behavior.",
      "example": "from dataclasses import dataclass, field\nfrom typing import List, Optional\nfrom datetime import datetime\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n    \n    def distance_from_origin(self) -> float:\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n\n@dataclass\nclass User:\n    name: str\n    email: str\n    age: int\n    tags: List[str] = field(default_factory=list)\n    created_at: datetime = field(default_factory=datetime.now)\n    is_active: bool = True\n    \n    def __post_init__(self):\n        if self.age < 0:\n            raise ValueError(\"Age cannot be negative\")\n\n@dataclass(frozen=True)  # Immutable\nclass Config:\n    api_key: str\n    timeout: int = 30\n    debug: bool = False"
    },
    "abstract_base_class": {
      "description": "Defines interfaces and enforces implementation of methods in subclasses.",
      "whenToUse": "When you want to define a contract that subclasses must follow.",
      "example": "from abc import ABC, abstractmethod\nfrom typing import List, Any\n\nclass DataStore(ABC):\n    @abstractmethod\n    def save(self, key: str, value: Any) -> None:\n        \"\"\"Save a value with the given key.\"\"\"\n        pass\n    \n    @abstractmethod\n    def load(self, key: str) -> Any:\n        \"\"\"Load the value for the given key.\"\"\"\n        pass\n    \n    @abstractmethod\n    def delete(self, key: str) -> None:\n        \"\"\"Delete the value for the given key.\"\"\"\n        pass\n    \n    def exists(self, key: str) -> bool:\n        \"\"\"Check if a key exists (default implementation).\"\"\"\n        try:\n            self.load(key)\n            return True\n        except KeyError:\n            return False\n\nclass InMemoryStore(DataStore):\n    def __init__(self):\n        self._data = {}\n    \n    def save(self, key: str, value: Any) -> None:\n        self._data[key] = value\n    \n    def load(self, key: str) -> Any:\n        if key not in self._data:\n            raise KeyError(f\"Key '{key}' not found\")\n        return self._data[key]\n    \n    def delete(self, key: str) -> None:\n        if key in self._data:\n            del self._data[key]"
    },
    "generator": {
      "description": "Creates iterators using yield to produce values on demand.",
      "whenToUse": "When working with large datasets or infinite sequences to save memory.",
      "example": "def fibonacci(n: int):\n    \"\"\"Generate first n Fibonacci numbers.\"\"\"\n    a, b = 0, 1\n    for _ in range(n):\n        yield a\n        a, b = b, a + b\n\ndef read_large_file(file_path: str):\n    \"\"\"Read large file line by line without loading entire file.\"\"\"\n    with open(file_path, 'r') as file:\n        for line in file:\n            yield line.strip()\n\ndef infinite_counter(start: int = 0):\n    \"\"\"Create an infinite counter.\"\"\"\n    count = start\n    while True:\n        yield count\n        count += 1\n\n# Generator expression\nsquares = (x**2 for x in range(10))\n\n# Pipeline of generators\ndef process_data(filename: str):\n    lines = read_large_file(filename)\n    numbers = (int(line) for line in lines if line.isdigit())\n    positive = (n for n in numbers if n > 0)\n    return sum(positive)"
    }
  }
}