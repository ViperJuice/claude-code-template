{
  "language": "dart",
  "patterns": {
    "singleton": {
      "description": "Ensures only one instance of a class exists throughout the application.",
      "whenToUse": "For app-wide configuration, logging, database connections, or managing global state.",
      "example": "// Classic Singleton with factory constructor\nclass DatabaseConnection {\n  static DatabaseConnection? _instance;\n  late final String _connectionString;\n  \n  // Private constructor\n  DatabaseConnection._internal(String connectionString) {\n    _connectionString = connectionString;\n    _connect();\n  }\n  \n  // Factory constructor returns singleton instance\n  factory DatabaseConnection(String connectionString) {\n    _instance ??= DatabaseConnection._internal(connectionString);\n    return _instance!;\n  }\n  \n  void _connect() {\n    print('Connecting to database: $_connectionString');\n  }\n  \n  Future<Map<String, dynamic>> query(String sql) async {\n    // Simulate database query\n    await Future.delayed(Duration(milliseconds: 100));\n    return {'result': 'data'};\n  }\n}\n\n// Lazy Singleton with late initialization\nclass Logger {\n  static late final Logger _instance = Logger._internal();\n  final List<String> _logs = [];\n  \n  Logger._internal();\n  \n  factory Logger() => _instance;\n  \n  void log(String message) {\n    final timestamp = DateTime.now().toIso8601String();\n    _logs.add('[$timestamp] $message');\n    print('[$timestamp] $message');\n  }\n  \n  List<String> get logs => List.unmodifiable(_logs);\n}\n\n// Singleton for app configuration\nclass AppConfig {\n  static final AppConfig instance = AppConfig._();\n  \n  late String apiUrl;\n  late String appVersion;\n  late bool debugMode;\n  \n  AppConfig._();\n  \n  Future<void> initialize() async {\n    // Load configuration from file or remote\n    apiUrl = 'https://api.example.com';\n    appVersion = '1.0.0';\n    debugMode = true;\n  }\n}"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes.",
      "whenToUse": "When object creation is complex or needs to be decided at runtime.",
      "example": "// Abstract class for products\nabstract class Platform {\n  String get name;\n  void configure();\n}\n\nclass AndroidPlatform implements Platform {\n  @override\n  String get name => 'Android';\n  \n  @override\n  void configure() {\n    print('Configuring for Android platform');\n  }\n}\n\nclass IOSPlatform implements Platform {\n  @override\n  String get name => 'iOS';\n  \n  @override\n  void configure() {\n    print('Configuring for iOS platform');\n  }\n}\n\nclass WebPlatform implements Platform {\n  @override\n  String get name => 'Web';\n  \n  @override\n  void configure() {\n    print('Configuring for Web platform');\n  }\n}\n\n// Factory class\nclass PlatformFactory {\n  static Platform createPlatform(String type) {\n    switch (type.toLowerCase()) {\n      case 'android':\n        return AndroidPlatform();\n      case 'ios':\n        return IOSPlatform();\n      case 'web':\n        return WebPlatform();\n      default:\n        throw ArgumentError('Unknown platform type: $type');\n    }\n  }\n  \n  // Factory method using Platform detection\n  static Platform getCurrentPlatform() {\n    if (Platform.isAndroid) return AndroidPlatform();\n    if (Platform.isIOS) return IOSPlatform();\n    if (Platform.isWeb) return WebPlatform();\n    throw UnsupportedError('Platform not supported');\n  }\n}\n\n// Factory for creating widgets\nabstract class ButtonFactory {\n  Widget createButton(String text, VoidCallback onPressed);\n  Widget createIconButton(IconData icon, VoidCallback onPressed);\n}\n\nclass MaterialButtonFactory implements ButtonFactory {\n  @override\n  Widget createButton(String text, VoidCallback onPressed) {\n    return ElevatedButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n  \n  @override\n  Widget createIconButton(IconData icon, VoidCallback onPressed) {\n    return IconButton(\n      icon: Icon(icon),\n      onPressed: onPressed,\n    );\n  }\n}\n\nclass CupertinoButtonFactory implements ButtonFactory {\n  @override\n  Widget createButton(String text, VoidCallback onPressed) {\n    return CupertinoButton(\n      onPressed: onPressed,\n      child: Text(text),\n    );\n  }\n  \n  @override\n  Widget createIconButton(IconData icon, VoidCallback onPressed) {\n    return CupertinoButton(\n      padding: EdgeInsets.zero,\n      onPressed: onPressed,\n      child: Icon(icon),\n    );\n  }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step with method chaining.",
      "whenToUse": "When creating objects with many optional parameters or complex initialization.",
      "example": "// HTTP Request Builder\nclass HttpRequest {\n  final String url;\n  final String method;\n  final Map<String, String>? headers;\n  final dynamic body;\n  final Duration? timeout;\n  final int? retryCount;\n  \n  HttpRequest._builder(HttpRequestBuilder builder)\n      : url = builder._url,\n        method = builder._method,\n        headers = builder._headers,\n        body = builder._body,\n        timeout = builder._timeout,\n        retryCount = builder._retryCount;\n}\n\nclass HttpRequestBuilder {\n  late String _url;\n  String _method = 'GET';\n  Map<String, String>? _headers;\n  dynamic _body;\n  Duration? _timeout;\n  int? _retryCount;\n  \n  HttpRequestBuilder(String url) {\n    _url = url;\n  }\n  \n  HttpRequestBuilder method(String method) {\n    _method = method;\n    return this;\n  }\n  \n  HttpRequestBuilder headers(Map<String, String> headers) {\n    _headers = headers;\n    return this;\n  }\n  \n  HttpRequestBuilder header(String key, String value) {\n    _headers ??= {};\n    _headers![key] = value;\n    return this;\n  }\n  \n  HttpRequestBuilder body(dynamic body) {\n    _body = body;\n    return this;\n  }\n  \n  HttpRequestBuilder timeout(Duration timeout) {\n    _timeout = timeout;\n    return this;\n  }\n  \n  HttpRequestBuilder retryCount(int count) {\n    _retryCount = count;\n    return this;\n  }\n  \n  HttpRequest build() {\n    return HttpRequest._builder(this);\n  }\n}\n\n// Flutter Widget Builder Pattern\nclass CustomCard {\n  final Widget? title;\n  final Widget? subtitle;\n  final Widget? leading;\n  final Widget? trailing;\n  final EdgeInsets? padding;\n  final Color? backgroundColor;\n  final double? elevation;\n  final VoidCallback? onTap;\n  \n  CustomCard._builder(CustomCardBuilder builder)\n      : title = builder._title,\n        subtitle = builder._subtitle,\n        leading = builder._leading,\n        trailing = builder._trailing,\n        padding = builder._padding,\n        backgroundColor = builder._backgroundColor,\n        elevation = builder._elevation,\n        onTap = builder._onTap;\n  \n  Widget build() {\n    return Card(\n      color: backgroundColor,\n      elevation: elevation ?? 2.0,\n      child: InkWell(\n        onTap: onTap,\n        child: Padding(\n          padding: padding ?? EdgeInsets.all(16.0),\n          child: Row(\n            children: [\n              if (leading != null) leading!,\n              Expanded(\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: [\n                    if (title != null) title!,\n                    if (subtitle != null) ...[SizedBox(height: 4), subtitle!],\n                  ],\n                ),\n              ),\n              if (trailing != null) trailing!,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomCardBuilder {\n  Widget? _title;\n  Widget? _subtitle;\n  Widget? _leading;\n  Widget? _trailing;\n  EdgeInsets? _padding;\n  Color? _backgroundColor;\n  double? _elevation;\n  VoidCallback? _onTap;\n  \n  CustomCardBuilder title(Widget title) {\n    _title = title;\n    return this;\n  }\n  \n  CustomCardBuilder subtitle(Widget subtitle) {\n    _subtitle = subtitle;\n    return this;\n  }\n  \n  CustomCardBuilder leading(Widget leading) {\n    _leading = leading;\n    return this;\n  }\n  \n  CustomCardBuilder trailing(Widget trailing) {\n    _trailing = trailing;\n    return this;\n  }\n  \n  CustomCardBuilder padding(EdgeInsets padding) {\n    _padding = padding;\n    return this;\n  }\n  \n  CustomCardBuilder backgroundColor(Color color) {\n    _backgroundColor = color;\n    return this;\n  }\n  \n  CustomCardBuilder elevation(double elevation) {\n    _elevation = elevation;\n    return this;\n  }\n  \n  CustomCardBuilder onTap(VoidCallback callback) {\n    _onTap = callback;\n    return this;\n  }\n  \n  CustomCard build() {\n    return CustomCard._builder(this);\n  }\n}"
    },
    "bloc": {
      "description": "Business Logic Component pattern for separating business logic from UI.",
      "whenToUse": "For complex state management with clear separation of concerns.",
      "example": "// Events\nabstract class CounterEvent {}\n\nclass IncrementEvent extends CounterEvent {}\n\nclass DecrementEvent extends CounterEvent {}\n\nclass ResetEvent extends CounterEvent {}\n\n// States\nabstract class CounterState {\n  final int count;\n  CounterState(this.count);\n}\n\nclass CounterInitial extends CounterState {\n  CounterInitial() : super(0);\n}\n\nclass CounterUpdated extends CounterState {\n  CounterUpdated(int count) : super(count);\n}\n\n// BLoC\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(CounterInitial()) {\n    on<IncrementEvent>(_onIncrement);\n    on<DecrementEvent>(_onDecrement);\n    on<ResetEvent>(_onReset);\n  }\n  \n  void _onIncrement(IncrementEvent event, Emitter<CounterState> emit) {\n    emit(CounterUpdated(state.count + 1));\n  }\n  \n  void _onDecrement(DecrementEvent event, Emitter<CounterState> emit) {\n    emit(CounterUpdated(state.count - 1));\n  }\n  \n  void _onReset(ResetEvent event, Emitter<CounterState> emit) {\n    emit(CounterInitial());\n  }\n}\n\n// Complex BLoC example with async operations\nabstract class UserEvent {}\n\nclass LoadUserEvent extends UserEvent {\n  final String userId;\n  LoadUserEvent(this.userId);\n}\n\nclass UpdateUserEvent extends UserEvent {\n  final User user;\n  UpdateUserEvent(this.user);\n}\n\nabstract class UserState {}\n\nclass UserInitial extends UserState {}\n\nclass UserLoading extends UserState {}\n\nclass UserLoaded extends UserState {\n  final User user;\n  UserLoaded(this.user);\n}\n\nclass UserError extends UserState {\n  final String message;\n  UserError(this.message);\n}\n\nclass UserBloc extends Bloc<UserEvent, UserState> {\n  final UserRepository repository;\n  \n  UserBloc({required this.repository}) : super(UserInitial()) {\n    on<LoadUserEvent>(_onLoadUser);\n    on<UpdateUserEvent>(_onUpdateUser);\n  }\n  \n  Future<void> _onLoadUser(\n    LoadUserEvent event,\n    Emitter<UserState> emit,\n  ) async {\n    emit(UserLoading());\n    \n    try {\n      final user = await repository.getUser(event.userId);\n      emit(UserLoaded(user));\n    } catch (e) {\n      emit(UserError(e.toString()));\n    }\n  }\n  \n  Future<void> _onUpdateUser(\n    UpdateUserEvent event,\n    Emitter<UserState> emit,\n  ) async {\n    emit(UserLoading());\n    \n    try {\n      await repository.updateUser(event.user);\n      emit(UserLoaded(event.user));\n    } catch (e) {\n      emit(UserError(e.toString()));\n    }\n  }\n}"
    },
    "provider": {
      "description": "State management pattern using InheritedWidget for dependency injection.",
      "whenToUse": "For simpler state management and dependency injection needs.",
      "example": "// Simple ChangeNotifier\nclass ThemeProvider extends ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.light;\n  \n  ThemeMode get themeMode => _themeMode;\n  \n  void toggleTheme() {\n    _themeMode = _themeMode == ThemeMode.light\n        ? ThemeMode.dark\n        : ThemeMode.light;\n    notifyListeners();\n  }\n  \n  void setTheme(ThemeMode mode) {\n    if (_themeMode != mode) {\n      _themeMode = mode;\n      notifyListeners();\n    }\n  }\n}\n\n// Complex state management with Provider\nclass CartItem {\n  final String id;\n  final String name;\n  final double price;\n  int quantity;\n  \n  CartItem({\n    required this.id,\n    required this.name,\n    required this.price,\n    this.quantity = 1,\n  });\n  \n  double get total => price * quantity;\n}\n\nclass CartProvider extends ChangeNotifier {\n  final Map<String, CartItem> _items = {};\n  \n  Map<String, CartItem> get items => {..._items};\n  \n  int get itemCount => _items.length;\n  \n  double get totalAmount {\n    return _items.values.fold(0.0, (sum, item) => sum + item.total);\n  }\n  \n  void addItem(String productId, String name, double price) {\n    if (_items.containsKey(productId)) {\n      _items[productId]!.quantity++;\n    } else {\n      _items[productId] = CartItem(\n        id: productId,\n        name: name,\n        price: price,\n      );\n    }\n    notifyListeners();\n  }\n  \n  void removeItem(String productId) {\n    _items.remove(productId);\n    notifyListeners();\n  }\n  \n  void updateQuantity(String productId, int quantity) {\n    if (_items.containsKey(productId)) {\n      if (quantity <= 0) {\n        removeItem(productId);\n      } else {\n        _items[productId]!.quantity = quantity;\n        notifyListeners();\n      }\n    }\n  }\n  \n  void clear() {\n    _items.clear();\n    notifyListeners();\n  }\n}\n\n// Provider with Future\nclass AuthProvider extends ChangeNotifier {\n  User? _user;\n  bool _isLoading = false;\n  String? _error;\n  \n  User? get user => _user;\n  bool get isAuthenticated => _user != null;\n  bool get isLoading => _isLoading;\n  String? get error => _error;\n  \n  Future<void> login(String email, String password) async {\n    _isLoading = true;\n    _error = null;\n    notifyListeners();\n    \n    try {\n      // Simulate API call\n      await Future.delayed(Duration(seconds: 2));\n      \n      _user = User(\n        id: '123',\n        email: email,\n        name: 'John Doe',\n      );\n      _isLoading = false;\n      notifyListeners();\n    } catch (e) {\n      _error = e.toString();\n      _isLoading = false;\n      notifyListeners();\n    }\n  }\n  \n  void logout() {\n    _user = null;\n    notifyListeners();\n  }\n}"
    },
    "stream": {
      "description": "Handles asynchronous data flows using Dart's Stream API.",
      "whenToUse": "For reactive programming and handling continuous data flows.",
      "example": "// Stream Controller pattern\nclass DataService {\n  final _dataController = StreamController<List<String>>.broadcast();\n  final _errorController = StreamController<String>.broadcast();\n  \n  Stream<List<String>> get dataStream => _dataController.stream;\n  Stream<String> get errorStream => _errorController.stream;\n  \n  Timer? _timer;\n  \n  void startFetchingData() {\n    _timer = Timer.periodic(Duration(seconds: 2), (_) {\n      _fetchData();\n    });\n  }\n  \n  Future<void> _fetchData() async {\n    try {\n      // Simulate API call\n      await Future.delayed(Duration(milliseconds: 500));\n      \n      final data = List.generate(\n        5,\n        (i) => 'Item ${DateTime.now().millisecondsSinceEpoch}-$i',\n      );\n      \n      _dataController.add(data);\n    } catch (e) {\n      _errorController.add(e.toString());\n    }\n  }\n  \n  void dispose() {\n    _timer?.cancel();\n    _dataController.close();\n    _errorController.close();\n  }\n}\n\n// Stream Transformer pattern\nclass SearchService {\n  final _searchController = StreamController<String>();\n  late final Stream<List<SearchResult>> searchResults;\n  \n  SearchService() {\n    searchResults = _searchController.stream\n        .debounceTime(Duration(milliseconds: 300))\n        .distinct()\n        .where((query) => query.length >= 3)\n        .asyncMap(_performSearch);\n  }\n  \n  void search(String query) {\n    _searchController.add(query);\n  }\n  \n  Future<List<SearchResult>> _performSearch(String query) async {\n    // Simulate API search\n    await Future.delayed(Duration(seconds: 1));\n    \n    return List.generate(\n      5,\n      (i) => SearchResult(\n        id: '$i',\n        title: '$query result $i',\n        description: 'Description for $query result $i',\n      ),\n    );\n  }\n  \n  void dispose() {\n    _searchController.close();\n  }\n}\n\n// Reactive pattern with multiple streams\nclass ChatService {\n  final _messagesController = StreamController<Message>.broadcast();\n  final _typingController = StreamController<String>.broadcast();\n  final _onlineUsersController = StreamController<List<User>>.broadcast();\n  \n  Stream<Message> get messages => _messagesController.stream;\n  Stream<String> get typingUsers => _typingController.stream;\n  Stream<List<User>> get onlineUsers => _onlineUsersController.stream;\n  \n  // Combine streams\n  Stream<ChatState> get chatState => Rx.combineLatest3(\n        messages,\n        typingUsers,\n        onlineUsers,\n        (Message? lastMessage, String typing, List<User> users) {\n          return ChatState(\n            lastMessage: lastMessage,\n            typingUser: typing,\n            onlineUsers: users,\n          );\n        },\n      );\n  \n  void sendMessage(String text, String userId) {\n    final message = Message(\n      id: DateTime.now().millisecondsSinceEpoch.toString(),\n      text: text,\n      userId: userId,\n      timestamp: DateTime.now(),\n    );\n    \n    _messagesController.add(message);\n  }\n  \n  void setTyping(String userId, bool isTyping) {\n    _typingController.add(isTyping ? userId : '');\n  }\n  \n  void updateOnlineUsers(List<User> users) {\n    _onlineUsersController.add(users);\n  }\n  \n  void dispose() {\n    _messagesController.close();\n    _typingController.close();\n    _onlineUsersController.close();\n  }\n}"
    },
    "repository": {
      "description": "Abstracts data sources and provides a clean API for data access.",
      "whenToUse": "When you need to separate data access logic from business logic.",
      "example": "// Repository interface\nabstract class UserRepository {\n  Future<User?> getUser(String id);\n  Future<List<User>> getAllUsers();\n  Future<void> saveUser(User user);\n  Future<void> deleteUser(String id);\n  Future<List<User>> searchUsers(String query);\n}\n\n// Implementation with multiple data sources\nclass UserRepositoryImpl implements UserRepository {\n  final ApiService _apiService;\n  final LocalDatabase _localDb;\n  final CacheService _cache;\n  \n  UserRepositoryImpl({\n    required ApiService apiService,\n    required LocalDatabase localDb,\n    required CacheService cache,\n  })  : _apiService = apiService,\n        _localDb = localDb,\n        _cache = cache;\n  \n  @override\n  Future<User?> getUser(String id) async {\n    // Check cache first\n    final cachedUser = await _cache.getUser(id);\n    if (cachedUser != null) {\n      return cachedUser;\n    }\n    \n    // Check local database\n    final localUser = await _localDb.getUser(id);\n    if (localUser != null) {\n      await _cache.saveUser(localUser);\n      return localUser;\n    }\n    \n    // Fetch from API\n    try {\n      final apiUser = await _apiService.fetchUser(id);\n      await _localDb.saveUser(apiUser);\n      await _cache.saveUser(apiUser);\n      return apiUser;\n    } catch (e) {\n      throw RepositoryException('Failed to fetch user: $e');\n    }\n  }\n  \n  @override\n  Future<List<User>> getAllUsers() async {\n    try {\n      // Try to get from API for fresh data\n      final users = await _apiService.fetchAllUsers();\n      \n      // Update local database\n      await _localDb.saveAllUsers(users);\n      \n      return users;\n    } catch (e) {\n      // Fallback to local data\n      final localUsers = await _localDb.getAllUsers();\n      if (localUsers.isNotEmpty) {\n        return localUsers;\n      }\n      throw RepositoryException('Failed to fetch users: $e');\n    }\n  }\n  \n  @override\n  Future<void> saveUser(User user) async {\n    try {\n      // Save to API\n      await _apiService.updateUser(user);\n      \n      // Update local copies\n      await _localDb.saveUser(user);\n      await _cache.saveUser(user);\n    } catch (e) {\n      throw RepositoryException('Failed to save user: $e');\n    }\n  }\n  \n  @override\n  Future<void> deleteUser(String id) async {\n    try {\n      await _apiService.deleteUser(id);\n      await _localDb.deleteUser(id);\n      await _cache.deleteUser(id);\n    } catch (e) {\n      throw RepositoryException('Failed to delete user: $e');\n    }\n  }\n  \n  @override\n  Future<List<User>> searchUsers(String query) async {\n    if (query.isEmpty) return [];\n    \n    try {\n      return await _apiService.searchUsers(query);\n    } catch (e) {\n      // Fallback to local search\n      return await _localDb.searchUsers(query);\n    }\n  }\n}\n\n// Repository with error handling\nclass Result<T> {\n  final T? data;\n  final String? error;\n  \n  Result.success(this.data) : error = null;\n  Result.failure(this.error) : data = null;\n  \n  bool get isSuccess => data != null;\n  bool get isFailure => error != null;\n}\n\nabstract class ProductRepository {\n  Future<Result<List<Product>>> getProducts();\n  Future<Result<Product>> getProduct(String id);\n  Future<Result<void>> addProduct(Product product);\n}\n\nclass ProductRepositoryImpl implements ProductRepository {\n  @override\n  Future<Result<List<Product>>> getProducts() async {\n    try {\n      final products = await _fetchProducts();\n      return Result.success(products);\n    } catch (e) {\n      return Result.failure(e.toString());\n    }\n  }\n  \n  @override\n  Future<Result<Product>> getProduct(String id) async {\n    try {\n      final product = await _fetchProduct(id);\n      return Result.success(product);\n    } catch (e) {\n      return Result.failure(e.toString());\n    }\n  }\n  \n  @override\n  Future<Result<void>> addProduct(Product product) async {\n    try {\n      await _saveProduct(product);\n      return Result.success(null);\n    } catch (e) {\n      return Result.failure(e.toString());\n    }\n  }\n}"
    }
  }
}