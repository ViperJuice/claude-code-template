{
  "language": "scala",
  "patterns": {
    "type_class": {
      "description": "Ad-hoc polymorphism through implicit parameters and companion objects.",
      "whenToUse": "When you need to add behavior to existing types without modifying them.",
      "example": "// Type class definition\ntrait Show[A] {\n  def show(a: A): String\n}\n\n// Type class instances\nobject Show {\n  // Summoner method\n  def apply[A](implicit sh: Show[A]): Show[A] = sh\n  \n  // Instances for common types\n  implicit val stringShow: Show[String] = new Show[String] {\n    def show(s: String): String = s\n  }\n  \n  implicit val intShow: Show[Int] = new Show[Int] {\n    def show(n: Int): String = n.toString\n  }\n  \n  implicit val booleanShow: Show[Boolean] = new Show[Boolean] {\n    def show(b: Boolean): String = if (b) \"true\" else \"false\"\n  }\n  \n  // Instance for Option\n  implicit def optionShow[A](implicit sa: Show[A]): Show[Option[A]] = new Show[Option[A]] {\n    def show(opt: Option[A]): String = opt match {\n      case Some(a) => s\"Some(${sa.show(a)})\"\n      case None => \"None\"\n    }\n  }\n  \n  // Instance for List\n  implicit def listShow[A](implicit sa: Show[A]): Show[List[A]] = new Show[List[A]] {\n    def show(list: List[A]): String = list.map(sa.show).mkString(\"[\", \", \", \"]\")\n  }\n}\n\n// Syntax extension\nobject ShowSyntax {\n  implicit class ShowOps[A](val a: A) extends AnyVal {\n    def show(implicit sa: Show[A]): String = sa.show(a)\n  }\n}\n\n// Usage\nimport ShowSyntax._\n\nval result = List(1, 2, 3).show // \"[1, 2, 3]\"\nval optResult = Some(\"hello\").show // \"Some(hello)\"\n\n// More complex type class: Monoid\ntrait Monoid[A] {\n  def empty: A\n  def combine(x: A, y: A): A\n}\n\nobject Monoid {\n  def apply[A](implicit m: Monoid[A]): Monoid[A] = m\n  \n  implicit val intAddMonoid: Monoid[Int] = new Monoid[Int] {\n    def empty: Int = 0\n    def combine(x: Int, y: Int): Int = x + y\n  }\n  \n  implicit val stringMonoid: Monoid[String] = new Monoid[String] {\n    def empty: String = \"\"\n    def combine(x: String, y: String): String = x + y\n  }\n  \n  implicit def listMonoid[A]: Monoid[List[A]] = new Monoid[List[A]] {\n    def empty: List[A] = Nil\n    def combine(x: List[A], y: List[A]): List[A] = x ++ y\n  }\n}\n\n// Using type classes\ndef combineAll[A: Monoid](list: List[A]): A = {\n  val m = implicitly[Monoid[A]]\n  list.foldLeft(m.empty)(m.combine)\n}\n\n// Multi-parameter type class\ntrait Converter[A, B] {\n  def convert(a: A): B\n}\n\nobject Converter {\n  implicit val intToString: Converter[Int, String] = new Converter[Int, String] {\n    def convert(a: Int): String = a.toString\n  }\n  \n  implicit val stringToInt: Converter[String, Int] = new Converter[String, Int] {\n    def convert(s: String): Int = s.toInt\n  }\n}\n\n// Context bounds syntax\ndef showAll[A: Show](list: List[A]): String = {\n  list.map(_.show).mkString(\", \")\n}"
    },
    "cake_pattern": {
      "description": "Dependency injection using self-types and trait composition.",
      "whenToUse": "For modular application design with compile-time dependency resolution.",
      "example": "// Component definitions\ntrait UserRepositoryComponent {\n  def userRepository: UserRepository\n  \n  trait UserRepository {\n    def findById(id: Long): Option[User]\n    def save(user: User): User\n    def findAll(): List[User]\n  }\n}\n\ntrait UserServiceComponent {\n  this: UserRepositoryComponent => // Self-type annotation\n  \n  def userService: UserService\n  \n  class UserService {\n    def getUser(id: Long): Option[User] = userRepository.findById(id)\n    \n    def createUser(name: String, email: String): User = {\n      val user = User(None, name, email)\n      userRepository.save(user)\n    }\n    \n    def getAllUsers(): List[User] = userRepository.findAll()\n  }\n}\n\ntrait EmailServiceComponent {\n  def emailService: EmailService\n  \n  trait EmailService {\n    def sendEmail(to: String, subject: String, body: String): Unit\n  }\n}\n\ntrait NotificationServiceComponent {\n  this: UserServiceComponent with EmailServiceComponent => // Multiple dependencies\n  \n  def notificationService: NotificationService\n  \n  class NotificationService {\n    def notifyUser(userId: Long, message: String): Unit = {\n      userService.getUser(userId).foreach { user =>\n        emailService.sendEmail(user.email, \"Notification\", message)\n      }\n    }\n  }\n}\n\n// Concrete implementations\ntrait UserRepositoryComponentImpl extends UserRepositoryComponent {\n  override def userRepository: UserRepository = new UserRepositoryImpl\n  \n  class UserRepositoryImpl extends UserRepository {\n    private var users = Map[Long, User]()\n    private var nextId = 1L\n    \n    def findById(id: Long): Option[User] = users.get(id)\n    \n    def save(user: User): User = {\n      val savedUser = user.id match {\n        case Some(id) => user\n        case None => \n          val withId = user.copy(id = Some(nextId))\n          nextId += 1\n          withId\n      }\n      users += (savedUser.id.get -> savedUser)\n      savedUser\n    }\n    \n    def findAll(): List[User] = users.values.toList\n  }\n}\n\ntrait EmailServiceComponentImpl extends EmailServiceComponent {\n  override def emailService: EmailService = new EmailServiceImpl\n  \n  class EmailServiceImpl extends EmailService {\n    def sendEmail(to: String, subject: String, body: String): Unit = {\n      println(s\"Sending email to $to: $subject - $body\")\n    }\n  }\n}\n\n// Wiring everything together\nobject Application extends UserServiceComponent \n  with UserRepositoryComponentImpl\n  with EmailServiceComponentImpl\n  with NotificationServiceComponent {\n  \n  override val userService = new UserService\n  override val notificationService = new NotificationService\n}\n\n// Usage\nApplication.userService.createUser(\"John\", \"john@example.com\")\nApplication.notificationService.notifyUser(1L, \"Welcome!\")\n\n// Testing with mocks\ntrait TestEnvironment extends UserServiceComponent\n  with UserRepositoryComponent\n  with EmailServiceComponent\n  with NotificationServiceComponent {\n  \n  // Mock implementations\n  override val userRepository = new UserRepository {\n    def findById(id: Long): Option[User] = Some(User(Some(id), \"Test\", \"test@test.com\"))\n    def save(user: User): User = user.copy(id = Some(1L))\n    def findAll(): List[User] = List()\n  }\n  \n  override val emailService = new EmailService {\n    var sentEmails = List[(String, String, String)]()\n    def sendEmail(to: String, subject: String, body: String): Unit = {\n      sentEmails = (to, subject, body) :: sentEmails\n    }\n  }\n  \n  override val userService = new UserService\n  override val notificationService = new NotificationService\n}\n\ncase class User(id: Option[Long], name: String, email: String)"
    },
    "implicit_context": {
      "description": "Passes context information implicitly through the call stack.",
      "whenToUse": "For dependency injection, configuration, or context propagation.",
      "example": "// Implicit context for database transactions\nimport scala.concurrent.{ExecutionContext, Future}\n\ncase class DbConnection(url: String) {\n  def execute[T](query: String): T = {\n    println(s\"Executing on $url: $query\")\n    // Actual database logic here\n    null.asInstanceOf[T]\n  }\n}\n\n// Service that needs database connection\nclass UserService {\n  def findUser(id: Long)(implicit db: DbConnection): Option[User] = {\n    db.execute(s\"SELECT * FROM users WHERE id = $id\")\n    Some(User(id, \"John\", \"john@example.com\"))\n  }\n  \n  def createUser(name: String, email: String)(implicit db: DbConnection): User = {\n    db.execute(s\"INSERT INTO users (name, email) VALUES ('$name', '$email')\")\n    User(1L, name, email)\n  }\n}\n\n// Implicit execution context for async operations\nclass AsyncService {\n  def processAsync[T](value: T)(implicit ec: ExecutionContext): Future[T] = {\n    Future {\n      Thread.sleep(100)\n      println(s\"Processing $value on thread ${Thread.currentThread.getName}\")\n      value\n    }\n  }\n}\n\n// Configuration through implicits\ncase class AppConfig(\n  apiUrl: String,\n  timeout: Int,\n  debug: Boolean\n)\n\nclass ApiClient {\n  def get(endpoint: String)(implicit config: AppConfig): String = {\n    if (config.debug) println(s\"GET ${config.apiUrl}$endpoint\")\n    // Make actual HTTP request\n    \"response\"\n  }\n}\n\n// Usage\nobject App {\n  implicit val dbConnection: DbConnection = DbConnection(\"jdbc:postgresql://localhost/mydb\")\n  implicit val executionContext: ExecutionContext = ExecutionContext.global\n  implicit val appConfig: AppConfig = AppConfig(\"https://api.example.com\", 5000, true)\n  \n  val userService = new UserService\n  val asyncService = new AsyncService\n  val apiClient = new ApiClient\n  \n  // Implicit parameters are automatically provided\n  val user = userService.findUser(1L)\n  val future = asyncService.processAsync(\"Hello\")\n  val response = apiClient.get(\"/users\")\n}\n\n// Implicit conversions (use sparingly)\nobject StringEnhancements {\n  implicit class RichString(val s: String) extends AnyVal {\n    def isEmail: Boolean = s.contains(\"@\") && s.contains(\".\")\n    def wordCount: Int = s.split(\"\\\\s+\").length\n  }\n}\n\nimport StringEnhancements._\nval email = \"test@example.com\".isEmail // true\nval count = \"Hello world test\".wordCount // 3\n\n// Implicit evidence\ndef process[T](value: T)(implicit ev: T <:< Serializable): Unit = {\n  // This only compiles if T is a subtype of Serializable\n  val serializable: Serializable = ev(value)\n  println(s\"Processing serializable: $serializable\")\n}\n\n// Multiple implicit parameters\nclass LoggingService {\n  def log[T](value: T)(implicit logger: Logger, formatter: Formatter[T]): Unit = {\n    logger.log(formatter.format(value))\n  }\n}\n\ntrait Logger {\n  def log(message: String): Unit\n}\n\ntrait Formatter[T] {\n  def format(value: T): String\n}\n\nimplicit val consoleLogger: Logger = new Logger {\n  def log(message: String): Unit = println(s\"[LOG] $message\")\n}\n\nimplicit val intFormatter: Formatter[Int] = new Formatter[Int] {\n  def format(value: Int): String = s\"Integer: $value\"\n}\n\ncase class User(id: Long, name: String, email: String)"
    },
    "sealed_trait": {
      "description": "Algebraic data types with exhaustive pattern matching.",
      "whenToUse": "For modeling finite sets of alternatives with compile-time exhaustiveness checking.",
      "example": "// Result type\nsealed trait Result[+T]\ncase class Success[T](value: T) extends Result[T]\ncase class Failure(error: String) extends Result[Nothing]\n\n// Pattern matching with exhaustiveness\ndef handleResult[T](result: Result[T]): String = result match {\n  case Success(value) => s\"Success: $value\"\n  case Failure(error) => s\"Error: $error\"\n}\n\n// Tree structure\nsealed trait Tree[+A]\ncase class Leaf[A](value: A) extends Tree[A]\ncase class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]\n\nobject Tree {\n  def size[A](tree: Tree[A]): Int = tree match {\n    case Leaf(_) => 1\n    case Branch(left, right) => size(left) + size(right)\n  }\n  \n  def map[A, B](tree: Tree[A])(f: A => B): Tree[B] = tree match {\n    case Leaf(value) => Leaf(f(value))\n    case Branch(left, right) => Branch(map(left)(f), map(right)(f))\n  }\n  \n  def fold[A, B](tree: Tree[A])(leaf: A => B)(branch: (B, B) => B): B = tree match {\n    case Leaf(value) => leaf(value)\n    case Branch(left, right) => branch(fold(left)(leaf)(branch), fold(right)(leaf)(branch))\n  }\n}\n\n// State machine\nsealed trait State\ncase object Idle extends State\ncase object Running extends State\ncase object Stopped extends State\n\nsealed trait Event\ncase object Start extends Event\ncase object Stop extends Event\ncase object Reset extends Event\n\ndef transition(state: State, event: Event): State = (state, event) match {\n  case (Idle, Start) => Running\n  case (Running, Stop) => Stopped\n  case (Stopped, Reset) => Idle\n  case (s, _) => s // No transition\n}\n\n// Expression AST\nsealed trait Expr\ncase class Num(value: Double) extends Expr\ncase class Var(name: String) extends Expr\ncase class Add(left: Expr, right: Expr) extends Expr\ncase class Mul(left: Expr, right: Expr) extends Expr\ncase class Let(name: String, value: Expr, body: Expr) extends Expr\n\ndef eval(expr: Expr, env: Map[String, Double] = Map.empty): Double = expr match {\n  case Num(value) => value\n  case Var(name) => env.getOrElse(name, throw new Exception(s\"Undefined variable: $name\"))\n  case Add(left, right) => eval(left, env) + eval(right, env)\n  case Mul(left, right) => eval(left, env) * eval(right, env)\n  case Let(name, value, body) => \n    val v = eval(value, env)\n    eval(body, env + (name -> v))\n}\n\n// JSON representation\nsealed trait Json\ncase object JNull extends Json\ncase class JBool(value: Boolean) extends Json\ncase class JNumber(value: Double) extends Json\ncase class JString(value: String) extends Json\ncase class JArray(values: List[Json]) extends Json\ncase class JObject(fields: Map[String, Json]) extends Json\n\ndef stringify(json: Json): String = json match {\n  case JNull => \"null\"\n  case JBool(b) => b.toString\n  case JNumber(n) => n.toString\n  case JString(s) => s\"\"\"\"$s\"\"\"\"\n  case JArray(values) => values.map(stringify).mkString(\"[\", \",\", \"]\")\n  case JObject(fields) => \n    fields.map { case (k, v) => s\"\"\"\"$k\":${stringify(v)}\"\"\" }.mkString(\"{\", \",\", \"}\")\n}\n\n// Nested sealed traits\nsealed trait Animal\nsealed trait Mammal extends Animal\nsealed trait Bird extends Animal\n\ncase class Dog(name: String) extends Mammal\ncase class Cat(name: String) extends Mammal\ncase class Eagle(wingspan: Double) extends Bird\ncase class Parrot(vocabulary: Int) extends Bird\n\ndef describe(animal: Animal): String = animal match {\n  case Dog(name) => s\"Dog named $name\"\n  case Cat(name) => s\"Cat named $name\"\n  case Eagle(wingspan) => s\"Eagle with ${wingspan}m wingspan\"\n  case Parrot(vocabulary) => s\"Parrot knowing $vocabulary words\"\n}"
    },
    "mixin_trait": {
      "description": "Traits that add functionality through composition.",
      "whenToUse": "For adding reusable behavior to classes without inheritance.",
      "example": "// Basic mixin traits\ntrait Timestamped {\n  val createdAt: Long = System.currentTimeMillis()\n  var updatedAt: Long = createdAt\n  \n  def touch(): Unit = {\n    updatedAt = System.currentTimeMillis()\n  }\n}\n\ntrait Identifiable {\n  def id: String\n}\n\ntrait Versioned {\n  private var _version: Long = 1L\n  \n  def version: Long = _version\n  \n  def incrementVersion(): Unit = {\n    _version += 1\n  }\n}\n\n// Composing mixins\ncase class Document(\n  id: String,\n  title: String,\n  content: String\n) extends Identifiable with Timestamped with Versioned {\n  def update(newContent: String): Document = {\n    touch()\n    incrementVersion()\n    copy(content = newContent)\n  }\n}\n\n// Stackable modifications pattern\ntrait Queue[T] {\n  def put(x: T): Unit\n  def get(): T\n}\n\nclass BasicQueue[T] extends Queue[T] {\n  private val buf = scala.collection.mutable.ListBuffer.empty[T]\n  \n  def put(x: T): Unit = buf += x\n  \n  def get(): T = buf.remove(0)\n}\n\ntrait Doubling extends Queue[Int] {\n  abstract override def put(x: Int): Unit = super.put(2 * x)\n}\n\ntrait Filtering extends Queue[Int] {\n  abstract override def put(x: Int): Unit = {\n    if (x >= 0) super.put(x)\n  }\n}\n\ntrait Incrementing extends Queue[Int] {\n  abstract override def put(x: Int): Unit = super.put(x + 1)\n}\n\n// Order matters: executed right to left\nval queue = new BasicQueue[Int] with Incrementing with Filtering with Doubling\nqueue.put(5) // Doubling -> Filtering -> Incrementing -> BasicQueue\n// Result: ((5 * 2) >= 0) then (10 + 1) = 11\n\n// Mixin for logging\ntrait Logging {\n  def log(message: String): Unit = println(s\"[${this.getClass.getSimpleName}] $message\")\n}\n\nclass Service extends Logging {\n  def process(): Unit = {\n    log(\"Processing started\")\n    // Do work\n    log(\"Processing completed\")\n  }\n}\n\n// Mixin for observable pattern\ntrait Observable {\n  private var observers = List[Observer]()\n  \n  def addObserver(observer: Observer): Unit = {\n    observers = observer :: observers\n  }\n  \n  def notifyObservers(event: Any): Unit = {\n    observers.foreach(_.notify(event))\n  }\n}\n\ntrait Observer {\n  def notify(event: Any): Unit\n}\n\nclass DataModel extends Observable {\n  private var _data: String = \"\"\n  \n  def data: String = _data\n  \n  def data_=(value: String): Unit = {\n    _data = value\n    notifyObservers(DataChanged(value))\n  }\n}\n\ncase class DataChanged(newValue: String)\n\n// Self-type with mixins\ntrait Persistence {\n  this: Identifiable =>\n  \n  def save(): Unit = {\n    println(s\"Saving entity with id: $id\")\n  }\n  \n  def load(): Unit = {\n    println(s\"Loading entity with id: $id\")\n  }\n}\n\nclass Entity(val id: String) extends Identifiable with Persistence\n\n// Dependency injection through mixins\ntrait DatabaseComponent {\n  val database: Database\n  \n  trait Database {\n    def query(sql: String): List[Map[String, Any]]\n  }\n}\n\ntrait UserRepositoryComponent {\n  this: DatabaseComponent =>\n  \n  val userRepository: UserRepository\n  \n  class UserRepository {\n    def findById(id: Long): Option[User] = {\n      database.query(s\"SELECT * FROM users WHERE id = $id\").headOption.map { row =>\n        User(row(\"id\").asInstanceOf[Long], row(\"name\").asInstanceOf[String])\n      }\n    }\n  }\n}\n\ncase class User(id: Long, name: String)"
    },
    "for_comprehension": {
      "description": "Syntactic sugar for chaining monadic operations.",
      "whenToUse": "For composing operations on monadic types (Option, Either, Future, etc.).",
      "example": "// Option composition\ndef getUser(id: Long): Option[User] = Some(User(id, \"John\", \"john@example.com\"))\ndef getAddress(user: User): Option[Address] = Some(Address(\"123 Main St\", \"NYC\"))\ndef getZipCode(address: Address): Option[String] = Some(\"10001\")\n\nval zipCode = for {\n  user <- getUser(1L)\n  address <- getAddress(user)\n  zip <- getZipCode(address)\n} yield zip\n// Result: Some(\"10001\")\n\n// Either composition for error handling\nsealed trait AppError\ncase class NotFound(message: String) extends AppError\ncase class ValidationError(message: String) extends AppError\n\ndef parseInt(s: String): Either[AppError, Int] = \n  s.toIntOption.toRight(ValidationError(s\"Not a valid integer: $s\"))\n\ndef divide(a: Int, b: Int): Either[AppError, Double] =\n  if (b == 0) Left(ValidationError(\"Division by zero\"))\n  else Right(a.toDouble / b)\n\nval result = for {\n  a <- parseInt(\"10\")\n  b <- parseInt(\"2\")\n  result <- divide(a, b)\n} yield result\n// Result: Right(5.0)\n\n// Future composition\nimport scala.concurrent.Future\nimport scala.concurrent.ExecutionContext.Implicits.global\n\ndef fetchUser(id: Long): Future[User] = Future {\n  Thread.sleep(100)\n  User(id, \"John\", \"john@example.com\")\n}\n\ndef fetchOrders(user: User): Future[List[Order]] = Future {\n  Thread.sleep(100)\n  List(Order(1, user.id, 100.0), Order(2, user.id, 200.0))\n}\n\ndef calculateTotal(orders: List[Order]): Future[Double] = Future {\n  orders.map(_.amount).sum\n}\n\nval totalSpent = for {\n  user <- fetchUser(1L)\n  orders <- fetchOrders(user)\n  total <- calculateTotal(orders)\n} yield total\n\n// Custom monad\ncase class State[S, A](run: S => (A, S)) {\n  def map[B](f: A => B): State[S, B] = State { s =>\n    val (a, s2) = run(s)\n    (f(a), s2)\n  }\n  \n  def flatMap[B](f: A => State[S, B]): State[S, B] = State { s =>\n    val (a, s2) = run(s)\n    f(a).run(s2)\n  }\n}\n\nobject State {\n  def get[S]: State[S, S] = State(s => (s, s))\n  def set[S](s: S): State[S, Unit] = State(_ => ((), s))\n  def modify[S](f: S => S): State[S, Unit] = State(s => ((), f(s)))\n}\n\n// Using State monad\ntype Stack = List[Int]\n\ndef push(x: Int): State[Stack, Unit] = State.modify[Stack](x :: _)\ndef pop: State[Stack, Option[Int]] = State { stack =>\n  stack match {\n    case Nil => (None, Nil)\n    case h :: t => (Some(h), t)\n  }\n}\n\nval computation = for {\n  _ <- push(1)\n  _ <- push(2)\n  _ <- push(3)\n  a <- pop\n  b <- pop\n} yield (a, b)\n\nval (result, finalStack) = computation.run(Nil)\n// result: (Some(3), Some(2))\n// finalStack: List(1)\n\n// Filtering in for-comprehensions\nval filtered = for {\n  x <- List(1, 2, 3, 4, 5)\n  if x % 2 == 0\n  y <- List(10, 20)\n  if y > 10\n} yield x * y\n// Result: List(40, 60, 80)\n\ncase class User(id: Long, name: String, email: String)\ncase class Address(street: String, city: String)\ncase class Order(id: Long, userId: Long, amount: Double)"
    },
    "value_class": {
      "description": "Zero-cost abstractions for primitive types with type safety.",
      "whenToUse": "For adding type safety to primitives without runtime overhead.",
      "example": "// Basic value class\nclass UserId(val value: Long) extends AnyVal {\n  def isValid: Boolean = value > 0\n}\n\nclass Email(val value: String) extends AnyVal {\n  def domain: String = value.split(\"@\").lastOption.getOrElse(\"\")\n  def localPart: String = value.split(\"@\").headOption.getOrElse(\"\")\n}\n\n// Value classes with validation (using companion object)\nclass Temperature private (val value: Double) extends AnyVal {\n  def toCelsius: Temperature = this // Already in Celsius\n  def toFahrenheit: Temperature = new Temperature(value * 9.0/5.0 + 32)\n  def toKelvin: Temperature = new Temperature(value + 273.15)\n}\n\nobject Temperature {\n  def celsius(value: Double): Option[Temperature] = \n    if (value >= -273.15) Some(new Temperature(value))\n    else None\n    \n  def fahrenheit(value: Double): Option[Temperature] = \n    celsius((value - 32) * 5.0/9.0)\n    \n  def kelvin(value: Double): Option[Temperature] = \n    if (value >= 0) Some(new Temperature(value - 273.15))\n    else None\n}\n\n// Tagged types pattern\nobject Tagged {\n  type Tagged[U] = { type Tag = U }\n  type @@[T, U] = T with Tagged[U]\n  \n  def tag[U]: T => T @@ U = _.asInstanceOf[T @@ U]\n}\n\nimport Tagged._\n\n// Define tags\ntrait UserIdTag\ntrait OrderIdTag\ntrait ProductIdTag\n\ntype UserId = Long @@ UserIdTag\ntype OrderId = Long @@ OrderIdTag\ntype ProductId = Long @@ ProductIdTag\n\n// Helper methods\nobject UserId {\n  def apply(id: Long): UserId = tag[UserIdTag](id)\n}\n\nobject OrderId {\n  def apply(id: Long): OrderId = tag[OrderIdTag](id)\n}\n\nobject ProductId {\n  def apply(id: Long): ProductId = tag[ProductIdTag](id)\n}\n\n// Type-safe usage\ndef getUser(id: UserId): User = User(id, \"John\", \"john@example.com\")\ndef getOrder(id: OrderId): Order = Order(id, UserId(1L), 100.0)\n\n// This won't compile:\n// getUser(OrderId(1L)) // Type mismatch\n\n// Value classes for units\nclass Meters(val value: Double) extends AnyVal {\n  def +(other: Meters): Meters = new Meters(value + other.value)\n  def -(other: Meters): Meters = new Meters(value - other.value)\n  def *(factor: Double): Meters = new Meters(value * factor)\n  def toFeet: Feet = new Feet(value * 3.28084)\n}\n\nclass Feet(val value: Double) extends AnyVal {\n  def +(other: Feet): Feet = new Feet(value + other.value)\n  def -(other: Feet): Feet = new Feet(value - other.value)\n  def *(factor: Double): Feet = new Feet(value * factor)\n  def toMeters: Meters = new Meters(value / 3.28084)\n}\n\n// Rich wrapper pattern\nclass RichInt(val value: Int) extends AnyVal {\n  def isEven: Boolean = value % 2 == 0\n  def isOdd: Boolean = !isEven\n  def isPrime: Boolean = {\n    if (value <= 1) false\n    else if (value <= 3) true\n    else if (value % 2 == 0 || value % 3 == 0) false\n    else {\n      var i = 5\n      while (i * i <= value) {\n        if (value % i == 0 || value % (i + 2) == 0) return false\n        i += 6\n      }\n      true\n    }\n  }\n}\n\nimplicit class IntOps(val n: Int) extends AnyVal {\n  def times(f: => Unit): Unit = {\n    var i = 0\n    while (i < n) {\n      f\n      i += 1\n    }\n  }\n}\n\n// Usage\n5.times { println(\"Hello\") }\n\ncase class User(id: Long, name: String, email: String)\ncase class Order(id: Long, userId: Long, amount: Double)"
    },
    "pattern_matching": {
      "description": "Powerful pattern matching with extractors and guards.",
      "whenToUse": "For deconstructing data structures and control flow based on structure.",
      "example": "// Basic pattern matching\ndef describe(x: Any): String = x match {\n  case i: Int if i > 0 => s\"Positive integer: $i\"\n  case i: Int if i < 0 => s\"Negative integer: $i\"\n  case 0 => \"Zero\"\n  case s: String => s\"String of length ${s.length}\"\n  case list: List[_] => s\"List of size ${list.size}\"\n  case None => \"Empty option\"\n  case Some(value) => s\"Some($value)\"\n  case _ => \"Unknown\"\n}\n\n// Case classes and pattern matching\nsealed trait Expression\ncase class Number(value: Double) extends Expression\ncase class Variable(name: String) extends Expression\ncase class BinOp(op: String, left: Expression, right: Expression) extends Expression\ncase class UnaryOp(op: String, expr: Expression) extends Expression\n\ndef evaluate(expr: Expression, env: Map[String, Double]): Double = expr match {\n  case Number(value) => value\n  case Variable(name) => env.getOrElse(name, 0.0)\n  case BinOp(\"+\", left, right) => evaluate(left, env) + evaluate(right, env)\n  case BinOp(\"-\", left, right) => evaluate(left, env) - evaluate(right, env)\n  case BinOp(\"*\", left, right) => evaluate(left, env) * evaluate(right, env)\n  case BinOp(\"/\", left, right) => evaluate(left, env) / evaluate(right, env)\n  case UnaryOp(\"-\", expr) => -evaluate(expr, env)\n  case UnaryOp(\"+\", expr) => evaluate(expr, env)\n}\n\n// Pattern matching in variable definitions\nval (x, y) = (1, 2)\nval head :: tail = List(1, 2, 3, 4)\nval Some(value) = Some(42) // Throws MatchError if None\n\n// Custom extractors\nobject Email {\n  def unapply(str: String): Option[(String, String)] = {\n    val parts = str.split(\"@\")\n    if (parts.length == 2) Some((parts(0), parts(1)))\n    else None\n  }\n}\n\nobject PhoneNumber {\n  def unapply(str: String): Option[(String, String, String)] = {\n    val cleaned = str.filter(_.isDigit)\n    if (cleaned.length == 10)\n      Some((cleaned.substring(0, 3), cleaned.substring(3, 6), cleaned.substring(6)))\n    else None\n  }\n}\n\ndef classifyContact(contact: String): String = contact match {\n  case Email(user, domain) => s\"Email: $user at $domain\"\n  case PhoneNumber(area, prefix, line) => s\"Phone: ($area) $prefix-$line\"\n  case _ => \"Unknown contact type\"\n}\n\n// Sequence extractors\nobject Names {\n  def unapplySeq(str: String): Option[Seq[String]] = {\n    val names = str.trim.split(\"\\\\s+\").toSeq\n    if (names.nonEmpty) Some(names) else None\n  }\n}\n\n\"John Doe Smith\" match {\n  case Names(first, last) => s\"$first $last\"\n  case Names(first, middle, last) => s\"$first $middle $last\"\n  case _ => \"Unknown\"\n}\n\n// Pattern guards and alternatives\ndef classify(list: List[Int]): String = list match {\n  case Nil => \"Empty list\"\n  case x :: Nil => s\"Single element: $x\"\n  case x :: y :: Nil => s\"Two elements: $x and $y\"\n  case x :: y :: z :: Nil if x == y && y == z => s\"Three identical: $x\"\n  case head :: _ if head > 0 => \"Starts with positive\"\n  case head :: _ if head < 0 => \"Starts with negative\"\n  case _ => \"Other list\"\n}\n\n// Nested patterns\ncase class Address(street: String, city: String)\ncase class Person(name: String, age: Int, address: Option[Address])\n\ndef describePerson(person: Person): String = person match {\n  case Person(name, age, Some(Address(street, \"NYC\"))) if age >= 18 =>\n    s\"$name is an adult living on $street in NYC\"\n  case Person(name, age, Some(Address(_, city))) =>\n    s\"$name is $age years old and lives in $city\"\n  case Person(name, age, None) =>\n    s\"$name is $age years old with no known address\"\n}\n\n// Partial functions\nval sqrt: PartialFunction[Double, Double] = {\n  case x if x >= 0 => Math.sqrt(x)\n}\n\nval classify: PartialFunction[Any, String] = {\n  case s: String => \"String\"\n  case i: Int => \"Int\"\n  case d: Double => \"Double\"\n}\n\n// Combining partial functions\nval combined = sqrt.andThen(x => x * x)\nval chained = classify.orElse[Any, String] {\n  case _ => \"Other\"\n}"
    }
  }
}