{
  "language": "ruby",
  "patterns": {
    "singleton": {
      "description": "Ensures only one instance of a class exists using Ruby's Singleton module.",
      "whenToUse": "When you need a single point of access to shared resources or configuration.",
      "example": "# Using Ruby's built-in Singleton module\nrequire 'singleton'\n\nclass DatabaseConnection\n  include Singleton\n  \n  attr_reader :connection\n  \n  def initialize\n    @connection = establish_connection\n    puts \"Database connection established\"\n  end\n  \n  def query(sql)\n    puts \"Executing: #{sql}\"\n    # Execute query logic\n  end\n  \n  private\n  \n  def establish_connection\n    # Connection logic here\n    { host: 'localhost', port: 5432, connected: true }\n  end\nend\n\n# Manual singleton implementation\nclass Logger\n  @instance = nil\n  \n  private_class_method :new\n  \n  def self.instance\n    @instance ||= new\n  end\n  \n  def initialize\n    @logs = []\n    @log_file = File.open('app.log', 'a')\n  end\n  \n  def log(level, message)\n    timestamp = Time.now.strftime('%Y-%m-%d %H:%M:%S')\n    log_entry = \"[#{timestamp}] #{level.upcase}: #{message}\"\n    \n    @logs << log_entry\n    @log_file.puts(log_entry)\n    @log_file.flush\n    \n    puts log_entry if level == :error\n  end\n  \n  def info(message)\n    log(:info, message)\n  end\n  \n  def error(message)\n    log(:error, message)\n  end\n  \n  def debug(message)\n    log(:debug, message) if ENV['DEBUG']\n  end\nend\n\n# Thread-safe singleton\nclass Configuration\n  @instance_mutex = Mutex.new\n  @instance = nil\n  \n  class << self\n    def instance\n      return @instance if @instance\n      \n      @instance_mutex.synchronize do\n        @instance ||= new\n      end\n    end\n    \n    private :new\n  end\n  \n  def initialize\n    @settings = {}\n    load_config\n  end\n  \n  def get(key)\n    @settings[key.to_sym]\n  end\n  \n  def set(key, value)\n    @settings[key.to_sym] = value\n  end\n  \n  private\n  \n  def load_config\n    # Load from file or environment\n    @settings = {\n      api_url: ENV['API_URL'] || 'https://api.example.com',\n      timeout: (ENV['TIMEOUT'] || 30).to_i,\n      debug: ENV['DEBUG'] == 'true'\n    }\n  end\nend"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes.",
      "whenToUse": "When object creation is complex or needs to be determined at runtime.",
      "example": "# Simple factory\nclass VehicleFactory\n  def self.create(type, attributes = {})\n    case type.to_sym\n    when :car\n      Car.new(attributes)\n    when :motorcycle\n      Motorcycle.new(attributes)\n    when :truck\n      Truck.new(attributes)\n    else\n      raise ArgumentError, \"Unknown vehicle type: #{type}\"\n    end\n  end\nend\n\nclass Vehicle\n  attr_reader :make, :model, :year\n  \n  def initialize(attributes = {})\n    @make = attributes[:make]\n    @model = attributes[:model]\n    @year = attributes[:year]\n  end\nend\n\nclass Car < Vehicle\n  attr_reader :doors\n  \n  def initialize(attributes = {})\n    super\n    @doors = attributes[:doors] || 4\n  end\n  \n  def drive\n    \"Driving #{make} #{model} car\"\n  end\nend\n\nclass Motorcycle < Vehicle\n  attr_reader :engine_size\n  \n  def initialize(attributes = {})\n    super\n    @engine_size = attributes[:engine_size]\n  end\n  \n  def drive\n    \"Riding #{make} #{model} motorcycle\"\n  end\nend\n\n# Abstract factory pattern\nmodule UIFactory\n  class Button\n    def render\n      raise NotImplementedError\n    end\n  end\n  \n  class Input\n    def render\n      raise NotImplementedError\n    end\n  end\nend\n\nclass MaterialUIFactory\n  def create_button(text)\n    MaterialButton.new(text)\n  end\n  \n  def create_input(placeholder)\n    MaterialInput.new(placeholder)\n  end\n  \n  class MaterialButton < UIFactory::Button\n    def initialize(text)\n      @text = text\n    end\n    \n    def render\n      \"<button class='material-button'>#{@text}</button>\"\n    end\n  end\n  \n  class MaterialInput < UIFactory::Input\n    def initialize(placeholder)\n      @placeholder = placeholder\n    end\n    \n    def render\n      \"<input class='material-input' placeholder='#{@placeholder}' />\"\n    end\n  end\nend\n\nclass BootstrapUIFactory\n  def create_button(text)\n    BootstrapButton.new(text)\n  end\n  \n  def create_input(placeholder)\n    BootstrapInput.new(placeholder)\n  end\n  \n  class BootstrapButton < UIFactory::Button\n    def initialize(text)\n      @text = text\n    end\n    \n    def render\n      \"<button class='btn btn-primary'>#{@text}</button>\"\n    end\n  end\n  \n  class BootstrapInput < UIFactory::Input\n    def initialize(placeholder)\n      @placeholder = placeholder\n    end\n    \n    def render\n      \"<input class='form-control' placeholder='#{@placeholder}' />\"\n    end\n  end\nend\n\n# Factory with registration\nclass NotificationFactory\n  @notifiers = {}\n  \n  class << self\n    def register(type, klass)\n      @notifiers[type.to_sym] = klass\n    end\n    \n    def create(type, options = {})\n      notifier_class = @notifiers[type.to_sym]\n      raise ArgumentError, \"Unknown notifier type: #{type}\" unless notifier_class\n      \n      notifier_class.new(options)\n    end\n  end\nend\n\n# Register notifiers\nNotificationFactory.register(:email, EmailNotifier)\nNotificationFactory.register(:sms, SMSNotifier)\nNotificationFactory.register(:push, PushNotifier)"
    },
    "mixin": {
      "description": "Provides functionality to classes through module inclusion.",
      "whenToUse": "When you want to share common functionality across unrelated classes.",
      "example": "# Basic mixin module\nmodule Timestampable\n  def self.included(base)\n    base.extend(ClassMethods)\n    base.class_eval do\n      attr_accessor :created_at, :updated_at\n    end\n  end\n  \n  module ClassMethods\n    def with_timestamps\n      include InstanceMethods\n      \n      before_create :set_created_at\n      before_save :set_updated_at\n    end\n  end\n  \n  module InstanceMethods\n    def touch\n      self.updated_at = Time.now\n    end\n    \n    private\n    \n    def set_created_at\n      self.created_at = Time.now\n    end\n    \n    def set_updated_at\n      self.updated_at = Time.now\n    end\n  end\nend\n\n# JSON serialization mixin\nmodule JsonSerializable\n  def to_json(*args)\n    as_json.to_json(*args)\n  end\n  \n  def as_json(options = {})\n    serializable_attributes.each_with_object({}) do |attr, hash|\n      value = send(attr)\n      hash[attr] = value.respond_to?(:as_json) ? value.as_json : value\n    end\n  end\n  \n  def from_json(json_string)\n    data = JSON.parse(json_string)\n    data.each do |key, value|\n      send(\"#{key}=\", value) if respond_to?(\"#{key}=\")\n    end\n    self\n  end\n  \n  private\n  \n  def serializable_attributes\n    instance_variables.map { |var| var.to_s.delete('@').to_sym }\n  end\nend\n\n# Comparable mixin with custom implementation\nmodule Rankable\n  include Comparable\n  \n  def <=>(other)\n    return nil unless other.respond_to?(:rank)\n    rank <=> other.rank\n  end\n  \n  def rank\n    raise NotImplementedError, \"Including class must implement #rank\"\n  end\nend\n\nclass Player\n  include Rankable\n  \n  attr_reader :name, :score\n  \n  def initialize(name, score)\n    @name = name\n    @score = score\n  end\n  \n  def rank\n    @score\n  end\nend\n\n# Enumerable mixin\nclass TodoList\n  include Enumerable\n  \n  def initialize\n    @items = []\n  end\n  \n  def add(item)\n    @items << item\n    self\n  end\n  \n  def remove(item)\n    @items.delete(item)\n    self\n  end\n  \n  # Required for Enumerable\n  def each\n    return enum_for(:each) unless block_given?\n    \n    @items.each { |item| yield(item) }\n  end\n  \n  def completed\n    select(&:completed?)\n  end\n  \n  def pending\n    reject(&:completed?)\n  end\nend\n\n# Mixin with hooks\nmodule Cacheable\n  def self.included(base)\n    base.extend(ClassMethods)\n  end\n  \n  module ClassMethods\n    def cache_method(*method_names)\n      method_names.each do |method_name|\n        original_method = instance_method(method_name)\n        cache_var = \"@_cache_#{method_name}\"\n        \n        define_method(method_name) do |*args, &block|\n          if instance_variable_defined?(cache_var)\n            instance_variable_get(cache_var)\n          else\n            result = original_method.bind(self).call(*args, &block)\n            instance_variable_set(cache_var, result)\n            result\n          end\n        end\n        \n        define_method(\"clear_#{method_name}_cache\") do\n          remove_instance_variable(cache_var) if instance_variable_defined?(cache_var)\n        end\n      end\n    end\n  end\nend"
    },
    "builder": {
      "description": "Constructs complex objects step by step using method chaining.",
      "whenToUse": "When creating objects with many optional parameters.",
      "example": "# HTML builder pattern\nclass HtmlBuilder\n  def initialize\n    @elements = []\n  end\n  \n  def h1(text, attributes = {})\n    @elements << create_element('h1', text, attributes)\n    self\n  end\n  \n  def p(text, attributes = {})\n    @elements << create_element('p', text, attributes)\n    self\n  end\n  \n  def div(attributes = {}, &block)\n    content = if block_given?\n      builder = self.class.new\n      builder.instance_eval(&block)\n      builder.build\n    else\n      ''\n    end\n    \n    @elements << create_element('div', content, attributes)\n    self\n  end\n  \n  def a(text, href, attributes = {})\n    attributes[:href] = href\n    @elements << create_element('a', text, attributes)\n    self\n  end\n  \n  def ul(&block)\n    list_builder = ListBuilder.new\n    list_builder.instance_eval(&block) if block_given?\n    @elements << \"<ul>#{list_builder.build}</ul>\"\n    self\n  end\n  \n  def build\n    @elements.join('\\n')\n  end\n  \n  private\n  \n  def create_element(tag, content, attributes)\n    attrs = attributes.map { |k, v| %Q(#{k}=\"#{v}\") }.join(' ')\n    attrs = \" #{attrs}\" unless attrs.empty?\n    \"<#{tag}#{attrs}>#{content}</#{tag}>\"\n  end\nend\n\nclass ListBuilder\n  def initialize\n    @items = []\n  end\n  \n  def li(text)\n    @items << \"<li>#{text}</li>\"\n    self\n  end\n  \n  def build\n    @items.join('\\n')\n  end\nend\n\n# Query builder pattern\nclass QueryBuilder\n  def initialize(table)\n    @table = table\n    @select_fields = ['*']\n    @where_conditions = []\n    @order_by = nil\n    @limit_value = nil\n    @joins = []\n  end\n  \n  def select(*fields)\n    @select_fields = fields unless fields.empty?\n    self\n  end\n  \n  def where(conditions)\n    @where_conditions << conditions\n    self\n  end\n  \n  def join(table, on)\n    @joins << { table: table, on: on }\n    self\n  end\n  \n  def order(field, direction = :asc)\n    @order_by = { field: field, direction: direction }\n    self\n  end\n  \n  def limit(value)\n    @limit_value = value\n    self\n  end\n  \n  def build\n    sql = \"SELECT #{@select_fields.join(', ')} FROM #{@table}\"\n    \n    @joins.each do |join|\n      sql += \" JOIN #{join[:table]} ON #{join[:on]}\"\n    end\n    \n    unless @where_conditions.empty?\n      where_clause = @where_conditions.map { |c| build_where_clause(c) }.join(' AND ')\n      sql += \" WHERE #{where_clause}\"\n    end\n    \n    if @order_by\n      sql += \" ORDER BY #{@order_by[:field]} #{@order_by[:direction].upcase}\"\n    end\n    \n    sql += \" LIMIT #{@limit_value}\" if @limit_value\n    \n    sql\n  end\n  \n  private\n  \n  def build_where_clause(conditions)\n    if conditions.is_a?(Hash)\n      conditions.map { |k, v| \"#{k} = '#{v}'\" }.join(' AND ')\n    else\n      conditions\n    end\n  end\nend\n\n# Configuration builder\nclass ConfigBuilder\n  def initialize\n    @config = {}\n  end\n  \n  def database(&block)\n    db_builder = DatabaseConfigBuilder.new\n    db_builder.instance_eval(&block) if block_given?\n    @config[:database] = db_builder.build\n    self\n  end\n  \n  def server(&block)\n    server_builder = ServerConfigBuilder.new\n    server_builder.instance_eval(&block) if block_given?\n    @config[:server] = server_builder.build\n    self\n  end\n  \n  def build\n    @config\n  end\nend\n\nclass DatabaseConfigBuilder\n  def initialize\n    @config = {}\n  end\n  \n  def host(value)\n    @config[:host] = value\n    self\n  end\n  \n  def port(value)\n    @config[:port] = value\n    self\n  end\n  \n  def username(value)\n    @config[:username] = value\n    self\n  end\n  \n  def password(value)\n    @config[:password] = value\n    self\n  end\n  \n  def build\n    @config\n  end\nend"
    },
    "duck_typing": {
      "description": "Relies on object behavior rather than explicit type checking.",
      "whenToUse": "When you want flexible, polymorphic code that responds to methods rather than types.",
      "example": "# Duck typing with respond_to?\nclass FileProcessor\n  def process(source)\n    if source.respond_to?(:read)\n      # It's file-like, we can read from it\n      content = source.read\n      process_content(content)\n    elsif source.respond_to?(:to_s)\n      # Convert to string and process\n      process_content(source.to_s)\n    else\n      raise ArgumentError, \"Source must be readable or convertible to string\"\n    end\n  end\n  \n  private\n  \n  def process_content(content)\n    # Process the content\n    content.upcase\n  end\nend\n\n# Duck typing for collections\nclass DataAggregator\n  def aggregate(collection)\n    return 0 if collection.nil?\n    \n    if collection.respond_to?(:inject)\n      # It's enumerable-like\n      collection.inject(0) { |sum, item| sum + extract_value(item) }\n    elsif collection.respond_to?(:to_a)\n      # Convert to array first\n      aggregate(collection.to_a)\n    else\n      # Single value\n      extract_value(collection)\n    end\n  end\n  \n  private\n  \n  def extract_value(item)\n    case\n    when item.respond_to?(:value)\n      item.value\n    when item.respond_to?(:to_i)\n      item.to_i\n    else\n      0\n    end\n  end\nend\n\n# Duck typing for logging\nclass Application\n  attr_writer :logger\n  \n  def logger\n    @logger ||= NullLogger.new\n  end\n  \n  def run\n    logger.info \"Application starting\"\n    \n    begin\n      perform_work\n      logger.info \"Application completed successfully\"\n    rescue => e\n      logger.error \"Application failed: #{e.message}\"\n      raise\n    end\n  end\n  \n  private\n  \n  def perform_work\n    # Application logic\n  end\nend\n\nclass NullLogger\n  def info(message); end\n  def error(message); end\n  def debug(message); end\nend\n\n# Protocol-like duck typing\nmodule Printable\n  def self.print(object)\n    if object.respond_to?(:to_print)\n      object.to_print\n    elsif object.respond_to?(:to_s)\n      object.to_s\n    else\n      object.inspect\n    end\n  end\nend\n\nclass Document\n  attr_reader :title, :content\n  \n  def initialize(title, content)\n    @title = title\n    @content = content\n  end\n  \n  def to_print\n    \"Document: #{@title}\\n#{@content}\"\n  end\nend\n\nclass Image\n  attr_reader :path\n  \n  def initialize(path)\n    @path = path\n  end\n  \n  def to_print\n    \"Image: #{@path}\"\n  end\nend\n\n# Polymorphic duck typing\nclass NotificationService\n  def notify(recipient, message)\n    # Works with any object that has a receive_notification method\n    if recipient.respond_to?(:receive_notification)\n      recipient.receive_notification(message)\n    else\n      raise NoMethodError, \"Recipient must implement receive_notification\"\n    end\n  end\n  \n  def broadcast(recipients, message)\n    recipients.each do |recipient|\n      notify(recipient, message)\n    rescue NoMethodError => e\n      # Log error and continue\n      puts \"Failed to notify recipient: #{e.message}\"\n    end\n  end\nend"
    },
    "metaprogramming": {
      "description": "Writes code that writes or manipulates code at runtime.",
      "whenToUse": "When you need dynamic method creation, DSLs, or runtime code generation.",
      "example": "# Dynamic method creation\nclass DynamicModel\n  def self.attr_accessor_with_history(*attrs)\n    attrs.each do |attr|\n      # Create getter\n      define_method(attr) do\n        instance_variable_get(\"@#{attr}\")\n      end\n      \n      # Create setter with history\n      define_method(\"#{attr}=\") do |value|\n        # Initialize history array if needed\n        history_var = \"@#{attr}_history\"\n        history = instance_variable_get(history_var) || []\n        \n        # Add current value to history\n        current = instance_variable_get(\"@#{attr}\")\n        history << current if current\n        \n        # Set new value and update history\n        instance_variable_set(\"@#{attr}\", value)\n        instance_variable_set(history_var, history)\n      end\n      \n      # Create history getter\n      define_method(\"#{attr}_history\") do\n        instance_variable_get(\"@#{attr}_history\") || []\n      end\n    end\n  end\nend\n\n# Method missing pattern\nclass FlexibleHash\n  def initialize(hash = {})\n    @attributes = hash\n  end\n  \n  def method_missing(method_name, *args, &block)\n    method_string = method_name.to_s\n    \n    if method_string.end_with?('=')\n      # Setter method\n      attr_name = method_string.chomp('=')\n      @attributes[attr_name.to_sym] = args.first\n    elsif method_string.end_with?('?')\n      # Query method\n      attr_name = method_string.chomp('?')\n      !!@attributes[attr_name.to_sym]\n    elsif @attributes.key?(method_name)\n      # Getter method\n      @attributes[method_name]\n    else\n      super\n    end\n  end\n  \n  def respond_to_missing?(method_name, include_private = false)\n    method_string = method_name.to_s\n    attr_name = method_string.chomp('=').chomp('?').to_sym\n    \n    @attributes.key?(attr_name) || super\n  end\nend\n\n# Class macro pattern\nmodule Validatable\n  def self.included(base)\n    base.extend(ClassMethods)\n  end\n  \n  module ClassMethods\n    def validates_presence_of(*attrs)\n      attrs.each do |attr|\n        define_method(\"validate_#{attr}_presence\") do\n          value = send(attr)\n          if value.nil? || value.to_s.strip.empty?\n            errors << \"#{attr} can't be blank\"\n          end\n        end\n      end\n      \n      # Add to validations list\n      validations.concat(attrs.map { |attr| \"validate_#{attr}_presence\" })\n    end\n    \n    def validates_format_of(attr, options = {})\n      pattern = options[:with]\n      message = options[:message] || \"is invalid\"\n      \n      define_method(\"validate_#{attr}_format\") do\n        value = send(attr)\n        unless value.to_s =~ pattern\n          errors << \"#{attr} #{message}\"\n        end\n      end\n      \n      validations << \"validate_#{attr}_format\"\n    end\n    \n    def validations\n      @validations ||= []\n    end\n  end\n  \n  def valid?\n    @errors = []\n    self.class.validations.each do |validation|\n      send(validation) if respond_to?(validation)\n    end\n    errors.empty?\n  end\n  \n  def errors\n    @errors ||= []\n  end\nend\n\n# DSL creation with metaprogramming\nclass Router\n  def initialize(&block)\n    @routes = {}\n    instance_eval(&block) if block_given?\n  end\n  \n  def get(path, options = {})\n    add_route(:get, path, options)\n  end\n  \n  def post(path, options = {})\n    add_route(:post, path, options)\n  end\n  \n  def resources(name, options = {}, &block)\n    resource_routes = [\n      [:get, \"/#{name}\", { action: :index }],\n      [:get, \"/#{name}/new\", { action: :new }],\n      [:post, \"/#{name}\", { action: :create }],\n      [:get, \"/#{name}/:id\", { action: :show }],\n      [:get, \"/#{name}/:id/edit\", { action: :edit }],\n      [:put, \"/#{name}/:id\", { action: :update }],\n      [:delete, \"/#{name}/:id\", { action: :destroy }]\n    ]\n    \n    resource_routes.each do |method, path, opts|\n      add_route(method, path, options.merge(opts))\n    end\n    \n    if block_given?\n      nested_router = self.class.new(&block)\n      # Handle nested routes\n    end\n  end\n  \n  private\n  \n  def add_route(method, path, options)\n    @routes[method] ||= {}\n    @routes[method][path] = options\n  end\nend"
    },
    "observer": {
      "description": "Implements publish-subscribe pattern for event handling.",
      "whenToUse": "When objects need to be notified of state changes in other objects.",
      "example": "# Simple observer pattern\nmodule Observable\n  def add_observer(observer)\n    observers << observer\n  end\n  \n  def remove_observer(observer)\n    observers.delete(observer)\n  end\n  \n  def notify_observers(event, *args)\n    observers.each do |observer|\n      if observer.respond_to?(\"on_#{event}\")\n        observer.send(\"on_#{event}\", self, *args)\n      elsif observer.respond_to?(:update)\n        observer.update(event, self, *args)\n      end\n    end\n  end\n  \n  private\n  \n  def observers\n    @observers ||= []\n  end\nend\n\nclass StockPrice\n  include Observable\n  \n  attr_reader :symbol, :price\n  \n  def initialize(symbol, initial_price)\n    @symbol = symbol\n    @price = initial_price\n  end\n  \n  def price=(new_price)\n    old_price = @price\n    @price = new_price\n    \n    if old_price != new_price\n      notify_observers(:price_changed, old_price, new_price)\n    end\n  end\nend\n\nclass StockDisplay\n  def initialize(name)\n    @name = name\n  end\n  \n  def on_price_changed(stock, old_price, new_price)\n    change = new_price - old_price\n    direction = change > 0 ? '↑' : '↓'\n    \n    puts \"[#{@name}] #{stock.symbol}: $#{new_price} #{direction} ($#{change.round(2)})\"\n  end\nend\n\n# Event emitter pattern\nclass EventEmitter\n  def initialize\n    @listeners = Hash.new { |h, k| h[k] = [] }\n  end\n  \n  def on(event, &block)\n    @listeners[event] << block\n    \n    # Return unsubscribe proc\n    -> { @listeners[event].delete(block) }\n  end\n  \n  def once(event, &block)\n    unsubscribe = nil\n    \n    wrapper = proc do |*args|\n      block.call(*args)\n      unsubscribe.call\n    end\n    \n    unsubscribe = on(event, &wrapper)\n  end\n  \n  def emit(event, *args)\n    @listeners[event].each do |listener|\n      listener.call(*args)\n    end\n  end\n  \n  def off(event, listener = nil)\n    if listener\n      @listeners[event].delete(listener)\n    else\n      @listeners[event].clear\n    end\n  end\n  \n  def listeners(event)\n    @listeners[event].dup\n  end\nend\n\n# Observable with filters\nclass FilterableObservable\n  include Observable\n  \n  def add_observer(observer, options = {})\n    observer_config = {\n      observer: observer,\n      events: options[:events] || :all,\n      filter: options[:filter]\n    }\n    \n    observers << observer_config\n  end\n  \n  def notify_observers(event, *args)\n    observers.each do |config|\n      observer = config[:observer]\n      \n      # Check if observer is interested in this event\n      next unless interested_in_event?(config, event)\n      \n      # Apply filter if provided\n      next if config[:filter] && !config[:filter].call(event, *args)\n      \n      # Notify observer\n      if observer.respond_to?(\"on_#{event}\")\n        observer.send(\"on_#{event}\", self, *args)\n      elsif observer.respond_to?(:update)\n        observer.update(event, self, *args)\n      end\n    end\n  end\n  \n  private\n  \n  def interested_in_event?(config, event)\n    events = config[:events]\n    events == :all || \n      (events.is_a?(Array) && events.include?(event)) ||\n      events == event\n  end\nend"
    },
    "strategy": {
      "description": "Encapsulates algorithms and makes them interchangeable.",
      "whenToUse": "When you have multiple ways to perform a task and want to switch between them.",
      "example": "# Payment strategy\nclass PaymentProcessor\n  attr_accessor :strategy\n  \n  def initialize(strategy)\n    @strategy = strategy\n  end\n  \n  def process_payment(amount, details)\n    unless @strategy.respond_to?(:process)\n      raise NoMethodError, \"Payment strategy must implement 'process' method\"\n    end\n    \n    @strategy.process(amount, details)\n  end\nend\n\nclass CreditCardPayment\n  def process(amount, details)\n    validate_credit_card(details)\n    \n    # Process payment\n    puts \"Processing $#{amount} via credit card ending in #{details[:card_number][-4..]}\"\n    \n    { success: true, transaction_id: generate_transaction_id }\n  end\n  \n  private\n  \n  def validate_credit_card(details)\n    raise ArgumentError, \"Invalid card number\" unless details[:card_number] =~ /^\\d{16}$/\n    raise ArgumentError, \"Invalid CVV\" unless details[:cvv] =~ /^\\d{3,4}$/\n  end\n  \n  def generate_transaction_id\n    \"CC#{Time.now.to_i}#{rand(1000)}\"\n  end\nend\n\nclass PayPalPayment\n  def process(amount, details)\n    validate_paypal(details)\n    \n    puts \"Processing $#{amount} via PayPal account #{details[:email]}\"\n    \n    { success: true, transaction_id: generate_transaction_id }\n  end\n  \n  private\n  \n  def validate_paypal(details)\n    raise ArgumentError, \"Invalid email\" unless details[:email] =~ /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n  end\n  \n  def generate_transaction_id\n    \"PP#{Time.now.to_i}#{rand(1000)}\"\n  end\nend\n\n# Sorting strategy\nclass DataSorter\n  def initialize(strategy = :default)\n    @strategy = strategy\n  end\n  \n  def sort(data)\n    case @strategy\n    when :bubble\n      bubble_sort(data.dup)\n    when :quick\n      quick_sort(data.dup)\n    when :merge\n      merge_sort(data.dup)\n    when Proc\n      @strategy.call(data.dup)\n    else\n      data.sort\n    end\n  end\n  \n  def strategy=(new_strategy)\n    @strategy = new_strategy\n  end\n  \n  private\n  \n  def bubble_sort(arr)\n    n = arr.length\n    loop do\n      swapped = false\n      (n - 1).times do |i|\n        if arr[i] > arr[i + 1]\n          arr[i], arr[i + 1] = arr[i + 1], arr[i]\n          swapped = true\n        end\n      end\n      break unless swapped\n    end\n    arr\n  end\n  \n  def quick_sort(arr)\n    return arr if arr.length <= 1\n    \n    pivot = arr.delete_at(arr.length / 2)\n    left = arr.select { |x| x < pivot }\n    right = arr.select { |x| x >= pivot }\n    \n    quick_sort(left) + [pivot] + quick_sort(right)\n  end\n  \n  def merge_sort(arr)\n    return arr if arr.length <= 1\n    \n    mid = arr.length / 2\n    left = merge_sort(arr[0...mid])\n    right = merge_sort(arr[mid..])\n    \n    merge(left, right)\n  end\n  \n  def merge(left, right)\n    result = []\n    until left.empty? || right.empty?\n      result << (left.first <= right.first ? left.shift : right.shift)\n    end\n    result + left + right\n  end\nend\n\n# Compression strategy\nclass FileCompressor\n  def initialize(strategy)\n    @strategy = strategy\n  end\n  \n  def compress(file_path)\n    data = File.read(file_path)\n    compressed = @strategy.compress(data)\n    \n    output_path = \"#{file_path}.#{@strategy.extension}\"\n    File.write(output_path, compressed)\n    \n    output_path\n  end\nend\n\nclass ZipCompression\n  def compress(data)\n    # Simulate compression\n    Zlib::Deflate.deflate(data)\n  end\n  \n  def extension\n    'zip'\n  end\nend\n\nclass GzipCompression\n  def compress(data)\n    # Simulate compression\n    Zlib::Deflate.deflate(data)\n  end\n  \n  def extension\n    'gz'\n  end\nend"
    }
  }
}