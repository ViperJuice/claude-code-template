{
  "language": "zig",
  "patterns": {
    "comptime_interface": {
      "description": "Comptime interfaces use Zig's compile-time evaluation to create generic, type-safe interfaces without runtime overhead, similar to traits or type classes",
      "whenToUse": "Use when you need generic programming with zero runtime cost, want to define common interfaces for different types, or implement compile-time polymorphism",
      "example": "const std = @import(\"std\");\n\n// Define a comptime interface for comparison\npub fn Comparable(comptime T: type) type {\n    return struct {\n        pub fn compare(a: T, b: T) i32 {\n            if (@hasDecl(T, \"compare\")) {\n                return T.compare(a, b);\n            } else if (@typeInfo(T) == .Int or @typeInfo(T) == .Float) {\n                if (a < b) return -1;\n                if (a > b) return 1;\n                return 0;\n            } else {\n                @compileError(\"Type \" ++ @typeName(T) ++ \" does not implement compare\");\n            }\n        }\n    };\n}\n\n// Generic sort function using the interface\npub fn sort(comptime T: type, items: []T) void {\n    const cmp = Comparable(T);\n    \n    for (items, 0..) |_, i| {\n        for (items[i+1..], i+1..) |_, j| {\n            if (cmp.compare(items[j], items[i]) < 0) {\n                std.mem.swap(T, &items[i], &items[j]);\n            }\n        }\n    }\n}\n\n// Custom type implementing the interface\nconst Person = struct {\n    name: []const u8,\n    age: u32,\n    \n    pub fn compare(a: Person, b: Person) i32 {\n        // Compare by age\n        if (a.age < b.age) return -1;\n        if (a.age > b.age) return 1;\n        return 0;\n    }\n};\n\n// Iterator interface pattern\npub fn Iterator(comptime T: type) type {\n    return struct {\n        const Self = @This();\n        \n        nextFn: fn (self: *Self) ?T,\n        \n        pub fn next(self: *Self) ?T {\n            return self.nextFn(self);\n        }\n    };\n}\n\n// Range iterator implementation\npub fn RangeIterator(comptime T: type) type {\n    return struct {\n        const Self = @This();\n        \n        current: T,\n        end: T,\n        step: T,\n        iter: Iterator(T),\n        \n        pub fn init(start: T, end: T, step: T) Self {\n            var self = Self{\n                .current = start,\n                .end = end,\n                .step = step,\n                .iter = undefined,\n            };\n            self.iter = Iterator(T){ .nextFn = next };\n            return self;\n        }\n        \n        fn next(iter: *Iterator(T)) ?T {\n            const self = @fieldParentPtr(Self, \"iter\", iter);\n            if (self.current >= self.end) return null;\n            const value = self.current;\n            self.current += self.step;\n            return value;\n        }\n    };\n}\n\n// Usage example\ntest \"comptime interfaces\" {\n    var numbers = [_]i32{ 5, 2, 8, 1, 9 };\n    sort(i32, &numbers);\n    \n    var people = [_]Person{\n        .{ .name = \"Alice\", .age = 30 },\n        .{ .name = \"Bob\", .age = 25 },\n        .{ .name = \"Charlie\", .age = 35 },\n    };\n    sort(Person, &people);\n    \n    var range = RangeIterator(i32).init(0, 10, 2);\n    while (range.iter.next()) |value| {\n        std.debug.print(\"{}\\n\", .{value});\n    }\n}"
    },
    "error_handling": {
      "description": "Zig's error handling uses error sets and error unions to provide explicit, composable error handling without hidden control flow or exceptions",
      "whenToUse": "Use for all fallible operations, when you need explicit error propagation, want to handle different error types, or need to ensure all errors are handled",
      "example": "const std = @import(\"std\");\n\n// Define custom error sets\nconst FileError = error{\n    NotFound,\n    PermissionDenied,\n    DiskFull,\n};\n\nconst NetworkError = error{\n    ConnectionRefused,\n    Timeout,\n    InvalidResponse,\n};\n\n// Combine error sets\nconst AppError = FileError || NetworkError || error{InvalidInput};\n\n// Function returning error union\nfn readConfig(path: []const u8) !Config {\n    const file = std.fs.cwd().openFile(path, .{}) catch |err| switch (err) {\n        error.FileNotFound => return error.NotFound,\n        error.AccessDenied => return error.PermissionDenied,\n        else => return err,\n    };\n    defer file.close();\n    \n    var buffer: [1024]u8 = undefined;\n    const size = try file.read(&buffer);\n    \n    return parseConfig(buffer[0..size]) catch error.InvalidInput;\n}\n\n// Error handling patterns\nfn processFile(path: []const u8) !void {\n    // Pattern 1: try - propagate error up\n    const config = try readConfig(path);\n    \n    // Pattern 2: catch with specific handling\n    const data = readData(config.dataPath) catch |err| switch (err) {\n        error.NotFound => {\n            std.log.warn(\"Data file not found, using defaults\", .{});\n            return getDefaultData();\n        },\n        error.PermissionDenied => {\n            std.log.err(\"Permission denied for data file\", .{});\n            return err;\n        },\n        else => return err,\n    };\n    \n    // Pattern 3: catch with default value\n    const timeout = config.timeout catch 5000;\n    \n    // Pattern 4: errdefer for cleanup on error\n    const resource = try allocateResource();\n    errdefer resource.deinit();\n    \n    try processData(data, resource);\n}\n\n// Error payload pattern\nconst ValidationError = error{InvalidFormat};\n\nconst ValidationResult = struct {\n    value: ?i32,\n    message: []const u8,\n};\n\nfn validateAndParse(input: []const u8) ValidationError!ValidationResult {\n    if (input.len == 0) {\n        return ValidationResult{\n            .value = null,\n            .message = \"Input cannot be empty\",\n        };\n    }\n    \n    const value = std.fmt.parseInt(i32, input, 10) catch {\n        return ValidationResult{\n            .value = null,\n            .message = \"Invalid integer format\",\n        };\n    };\n    \n    if (value < 0 or value > 100) {\n        return ValidationResult{\n            .value = null,\n            .message = \"Value must be between 0 and 100\",\n        };\n    }\n    \n    return ValidationResult{\n        .value = value,\n        .message = \"Valid\",\n    };\n}\n\n// Error wrapping pattern\nfn DatabaseError(comptime T: type) type {\n    return struct {\n        const Self = @This();\n        \n        err: T,\n        query: []const u8,\n        timestamp: i64,\n        \n        pub fn init(err: T, query: []const u8) Self {\n            return .{\n                .err = err,\n                .query = query,\n                .timestamp = std.time.timestamp(),\n            };\n        }\n        \n        pub fn log(self: Self) void {\n            std.log.err(\"Database error at {}: {} - Query: {s}\", .{\n                self.timestamp,\n                self.err,\n                self.query,\n            });\n        }\n    };\n}\n\n// Ensure all errors handled at compile time\nfn mustHandleAllErrors(value: anyerror!i32) i32 {\n    return value catch |err| switch (err) {\n        error.OutOfMemory => return -1,\n        error.InvalidInput => return -2,\n        // Compile error if any error is not handled\n        else => @panic(\"Unhandled error\"),\n    };\n}"
    },
    "allocator_pattern": {
      "description": "Zig's allocator pattern provides explicit memory management with customizable allocation strategies, enabling fine-grained control over memory usage",
      "whenToUse": "Use for all dynamic memory allocation, when implementing custom memory management strategies, building memory-safe abstractions, or optimizing memory usage patterns",
      "example": "const std = @import(\"std\");\n\n// Basic allocator usage\nfn createBuffer(allocator: std.mem.Allocator, size: usize) ![]u8 {\n    const buffer = try allocator.alloc(u8, size);\n    errdefer allocator.free(buffer);\n    \n    // Initialize buffer\n    std.mem.set(u8, buffer, 0);\n    return buffer;\n}\n\n// Arena allocator pattern for batch allocation\nfn processDataWithArena(data: []const u8) !void {\n    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena.deinit(); // Free all memory at once\n    \n    const allocator = arena.allocator();\n    \n    // All allocations use the arena\n    const temp1 = try allocator.alloc(u8, 1024);\n    const temp2 = try allocator.alloc(u32, 256);\n    const result = try allocator.create(Result);\n    \n    // No need to free individual allocations\n    // Everything is freed when arena.deinit() is called\n}\n\n// Custom allocator wrapper for tracking\nconst TrackingAllocator = struct {\n    parent_allocator: std.mem.Allocator,\n    bytes_allocated: usize,\n    allocation_count: usize,\n    \n    const Self = @This();\n    \n    pub fn init(parent: std.mem.Allocator) Self {\n        return .{\n            .parent_allocator = parent,\n            .bytes_allocated = 0,\n            .allocation_count = 0,\n        };\n    }\n    \n    pub fn allocator(self: *Self) std.mem.Allocator {\n        return std.mem.Allocator{\n            .ptr = self,\n            .vtable = &.{\n                .alloc = alloc,\n                .resize = resize,\n                .free = free,\n            },\n        };\n    }\n    \n    fn alloc(ctx: *anyopaque, len: usize, ptr_align: u29, len_align: u29, ret_addr: usize) ?[*]u8 {\n        const self = @ptrCast(*Self, @alignCast(@alignOf(Self), ctx));\n        const result = self.parent_allocator.rawAlloc(len, ptr_align, len_align, ret_addr);\n        if (result) |ptr| {\n            self.bytes_allocated += len;\n            self.allocation_count += 1;\n        }\n        return result;\n    }\n    \n    fn resize(ctx: *anyopaque, buf: []u8, buf_align: u29, new_len: usize, len_align: u29, ret_addr: usize) bool {\n        const self = @ptrCast(*Self, @alignCast(@alignOf(Self), ctx));\n        const result = self.parent_allocator.rawResize(buf, buf_align, new_len, len_align, ret_addr);\n        if (result) {\n            self.bytes_allocated = self.bytes_allocated - buf.len + new_len;\n        }\n        return result;\n    }\n    \n    fn free(ctx: *anyopaque, buf: []u8, buf_align: u29, ret_addr: usize) void {\n        const self = @ptrCast(*Self, @alignCast(@alignOf(Self), ctx));\n        self.parent_allocator.rawFree(buf, buf_align, ret_addr);\n        self.bytes_allocated -= buf.len;\n        self.allocation_count -= 1;\n    }\n};\n\n// Fixed buffer allocator for embedded/kernel\nfn embeddedFunction() !void {\n    var buffer: [4096]u8 = undefined;\n    var fba = std.heap.FixedBufferAllocator.init(&buffer);\n    const allocator = fba.allocator();\n    \n    // All allocations come from the fixed buffer\n    const data = try allocator.alloc(u32, 100);\n    defer allocator.free(data);\n    \n    // No heap allocations\n}\n\n// Pool allocator pattern\npub fn PoolAllocator(comptime T: type, comptime pool_size: usize) type {\n    return struct {\n        const Self = @This();\n        \n        pool: [pool_size]T,\n        used: [pool_size]bool,\n        \n        pub fn init() Self {\n            return .{\n                .pool = undefined,\n                .used = [_]bool{false} ** pool_size,\n            };\n        }\n        \n        pub fn alloc(self: *Self) ?*T {\n            for (self.used, 0..) |used, i| {\n                if (!used) {\n                    self.used[i] = true;\n                    return &self.pool[i];\n                }\n            }\n            return null;\n        }\n        \n        pub fn free(self: *Self, ptr: *T) void {\n            const index = (@ptrToInt(ptr) - @ptrToInt(&self.pool)) / @sizeOf(T);\n            self.used[index] = false;\n        }\n    };\n}"
    },
    "defer_pattern": {
      "description": "Defer statements execute code at scope exit in reverse order, providing deterministic resource cleanup and enabling RAII-like patterns",
      "whenToUse": "Use for resource cleanup, ensuring paired operations (open/close, lock/unlock), temporary state changes, or implementing scope guards",
      "example": "const std = @import(\"std\");\n\n// Basic defer for resource cleanup\nfn processFile(path: []const u8) !void {\n    const file = try std.fs.cwd().openFile(path, .{});\n    defer file.close(); // Guaranteed to run when scope exits\n    \n    const contents = try file.readToEndAlloc(allocator, 1024 * 1024);\n    defer allocator.free(contents);\n    \n    try processContents(contents);\n}\n\n// Multiple defers execute in reverse order\nfn complexOperation() !void {\n    std.debug.print(\"Starting\\n\", .{});\n    defer std.debug.print(\"Finished\\n\", .{}); // Runs last\n    \n    const resource1 = try acquireResource1();\n    defer resource1.release(); // Runs third\n    \n    const resource2 = try acquireResource2();\n    defer resource2.release(); // Runs second\n    \n    const resource3 = try acquireResource3();\n    defer resource3.release(); // Runs first\n    \n    try doWork(resource1, resource2, resource3);\n}\n\n// Errdefer for error-specific cleanup\nfn createComplexObject(allocator: std.mem.Allocator) !*ComplexObject {\n    const obj = try allocator.create(ComplexObject);\n    errdefer allocator.destroy(obj); // Only runs if function returns error\n    \n    obj.buffer = try allocator.alloc(u8, 1024);\n    errdefer allocator.free(obj.buffer);\n    \n    obj.handle = try openHandle();\n    errdefer closeHandle(obj.handle);\n    \n    try obj.initialize();\n    return obj;\n}\n\n// Defer with loops and conditionals\nfn processItems(items: []Item) !void {\n    for (items) |*item| {\n        if (item.needsProcessing()) {\n            item.lock();\n            defer item.unlock(); // Runs at end of if-block\n            \n            try item.process();\n        }\n    }\n}\n\n// State restoration pattern\nfn withTemporaryState(obj: *Object, temp_state: State) !void {\n    const original_state = obj.state;\n    obj.state = temp_state;\n    defer obj.state = original_state; // Restore original state\n    \n    try obj.performOperation();\n}\n\n// Scope guard pattern\nconst ScopeGuard = struct {\n    cleanup_fn: fn () void,\n    \n    pub fn init(cleanup: fn () void) ScopeGuard {\n        return .{ .cleanup_fn = cleanup };\n    }\n    \n    pub fn deinit(self: ScopeGuard) void {\n        self.cleanup_fn();\n    }\n};\n\nfn withScopeGuard() !void {\n    const guard = ScopeGuard.init(cleanupFunction);\n    defer guard.deinit();\n    \n    try riskyOperation();\n}\n\n// Transaction pattern with defer\nconst Transaction = struct {\n    committed: bool = false,\n    \n    pub fn begin() Transaction {\n        beginTransactionImpl();\n        return .{};\n    }\n    \n    pub fn commit(self: *Transaction) void {\n        commitTransactionImpl();\n        self.committed = true;\n    }\n    \n    pub fn deinit(self: Transaction) void {\n        if (!self.committed) {\n            rollbackTransactionImpl();\n        }\n    }\n};\n\nfn performTransaction() !void {\n    var txn = Transaction.begin();\n    defer txn.deinit(); // Rollback if not committed\n    \n    try updateDatabase();\n    try validateChanges();\n    \n    txn.commit(); // Mark as committed\n}\n\n// Mutex lock pattern\nfn criticalSection(mutex: *std.Thread.Mutex) !void {\n    mutex.lock();\n    defer mutex.unlock();\n    \n    // Critical section code here\n    try modifySharedResource();\n}"
    },
    "comptime_validation": {
      "description": "Comptime validation uses Zig's compile-time execution to validate constraints, generate code, and ensure correctness without runtime overhead",
      "whenToUse": "Use when validating API constraints, generating lookup tables, ensuring type safety, creating zero-cost abstractions, or building compile-time checked DSLs",
      "example": "const std = @import(\"std\");\n\n// Compile-time parameter validation\npub fn FixedArray(comptime T: type, comptime size: usize) type {\n    comptime {\n        if (size == 0) {\n            @compileError(\"Array size must be greater than 0\");\n        }\n        if (size > 1024 * 1024) {\n            @compileError(\"Array size too large, maximum is 1MB elements\");\n        }\n    }\n    \n    return struct {\n        items: [size]T,\n        \n        pub fn init(default_value: T) @This() {\n            return .{ .items = [_]T{default_value} ** size };\n        }\n    };\n}\n\n// Compile-time string validation\npub fn SqlQuery(comptime query: []const u8) type {\n    comptime {\n        // Basic SQL injection prevention\n        if (std.mem.indexOf(u8, query, \"--\") != null) {\n            @compileError(\"SQL comments not allowed in queries\");\n        }\n        if (std.mem.indexOf(u8, query, \";\") != null) {\n            @compileError(\"Multiple statements not allowed\");\n        }\n        \n        // Validate placeholders\n        var placeholder_count: usize = 0;\n        for (query) |char| {\n            if (char == '?') placeholder_count += 1;\n        }\n        \n        return struct {\n            const param_count = placeholder_count;\n            const query_string = query;\n            \n            pub fn execute(params: [param_count][]const u8) void {\n                // Execute query with exact number of parameters\n                _ = params;\n            }\n        };\n    }\n}\n\n// Compile-time lookup table generation\nconst CrcTable = blk: {\n    var table: [256]u32 = undefined;\n    \n    for (&table, 0..) |*entry, i| {\n        var crc = @intCast(u32, i);\n        var j: u8 = 0;\n        while (j < 8) : (j += 1) {\n            if (crc & 1 == 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n        entry.* = crc;\n    }\n    \n    break :blk table;\n};\n\n// Compile-time type validation\npub fn validateStruct(comptime T: type) void {\n    const info = @typeInfo(T);\n    if (info != .Struct) {\n        @compileError(\"Expected struct type, got \" ++ @typeName(T));\n    }\n    \n    inline for (info.Struct.fields) |field| {\n        if (field.default_value == null) {\n            @compileError(\"Field '\" ++ field.name ++ \"' must have a default value\");\n        }\n    }\n}\n\n// Compile-time perfect hash generation\npub fn PerfectHash(comptime keys: []const []const u8) type {\n    comptime {\n        // Validate uniqueness\n        for (keys, 0..) |key1, i| {\n            for (keys[i + 1..]) |key2| {\n                if (std.mem.eql(u8, key1, key2)) {\n                    @compileError(\"Duplicate key: \" ++ key1);\n                }\n            }\n        }\n        \n        // Generate hash parameters\n        const size = keys.len * 2;\n        var table: [size]?usize = [_]?usize{null} ** size;\n        \n        // Simple perfect hash construction\n        for (keys, 0..) |key, value| {\n            const hash = hashString(key) % size;\n            if (table[hash] != null) {\n                @compileError(\"Hash collision, increase table size\");\n            }\n            table[hash] = value;\n        }\n        \n        return struct {\n            pub fn get(key: []const u8) ?usize {\n                const hash = hashString(key) % size;\n                if (table[hash]) |idx| {\n                    if (std.mem.eql(u8, keys[idx], key)) {\n                        return idx;\n                    }\n                }\n                return null;\n            }\n        };\n    }\n}\n\n// Compile-time configuration validation\nconst Config = struct {\n    port: u16,\n    threads: u32,\n    buffer_size: usize,\n};\n\npub fn validateConfig(comptime config: Config) Config {\n    comptime {\n        if (config.port == 0) {\n            @compileError(\"Port cannot be 0\");\n        }\n        if (config.threads == 0 or config.threads > 256) {\n            @compileError(\"Threads must be between 1 and 256\");\n        }\n        if (config.buffer_size < 1024) {\n            @compileError(\"Buffer size must be at least 1024 bytes\");\n        }\n    }\n    return config;\n}\n\n// Usage\nconst app_config = validateConfig(.{\n    .port = 8080,\n    .threads = 4,\n    .buffer_size = 4096,\n});"
    },
    "resource_acquisition": {
      "description": "Resource acquisition patterns in Zig ensure proper initialization and cleanup of resources using init/deinit conventions and ownership transfer",
      "whenToUse": "Use when managing system resources, implementing RAII-like patterns, ensuring cleanup happens, or building resource-safe APIs",
      "example": "const std = @import(\"std\");\n\n// Basic resource pattern with init/deinit\nconst File = struct {\n    handle: std.fs.File,\n    allocator: std.mem.Allocator,\n    buffer: []u8,\n    \n    const Self = @This();\n    \n    pub fn init(allocator: std.mem.Allocator, path: []const u8) !Self {\n        const handle = try std.fs.cwd().openFile(path, .{});\n        errdefer handle.close();\n        \n        const buffer = try allocator.alloc(u8, 4096);\n        errdefer allocator.free(buffer);\n        \n        return Self{\n            .handle = handle,\n            .allocator = allocator,\n            .buffer = buffer,\n        };\n    }\n    \n    pub fn deinit(self: *Self) void {\n        self.handle.close();\n        self.allocator.free(self.buffer);\n        self.* = undefined; // Prevent use after free\n    }\n};\n\n// Ownership transfer pattern\nconst OwnedBuffer = struct {\n    data: []u8,\n    allocator: std.mem.Allocator,\n    \n    const Self = @This();\n    \n    // Takes ownership of data\n    pub fn fromOwned(allocator: std.mem.Allocator, data: []u8) Self {\n        return Self{\n            .data = data,\n            .allocator = allocator,\n        };\n    }\n    \n    // Creates a copy, caller owns the data\n    pub fn fromCopy(allocator: std.mem.Allocator, data: []const u8) !Self {\n        const owned = try allocator.dupe(u8, data);\n        return Self.fromOwned(allocator, owned);\n    }\n    \n    // Transfer ownership to caller\n    pub fn release(self: *Self) []u8 {\n        const data = self.data;\n        self.* = undefined;\n        return data;\n    }\n    \n    pub fn deinit(self: *Self) void {\n        self.allocator.free(self.data);\n        self.* = undefined;\n    }\n};\n\n// Handle pattern for opaque resources\nconst Handle = opaque {\n    pub fn acquire(config: Config) !*Handle {\n        // Simulate external resource acquisition\n        const ptr = try allocator.create(InternalState);\n        errdefer allocator.destroy(ptr);\n        \n        try ptr.initialize(config);\n        return @ptrCast(*Handle, ptr);\n    }\n    \n    pub fn release(self: *Handle) void {\n        const ptr = @ptrCast(*InternalState, self);\n        ptr.deinitialize();\n        allocator.destroy(ptr);\n    }\n    \n    pub fn use(self: *Handle) !void {\n        const ptr = @ptrCast(*InternalState, self);\n        try ptr.doWork();\n    }\n};\n\n// Shared resource with reference counting\nconst SharedResource = struct {\n    data: *ResourceData,\n    \n    const Self = @This();\n    \n    const ResourceData = struct {\n        ref_count: std.atomic.Atomic(usize),\n        allocator: std.mem.Allocator,\n        value: []u8,\n        \n        fn deinit(self: *ResourceData) void {\n            self.allocator.free(self.value);\n            self.allocator.destroy(self);\n        }\n    };\n    \n    pub fn init(allocator: std.mem.Allocator, size: usize) !Self {\n        const data = try allocator.create(ResourceData);\n        errdefer allocator.destroy(data);\n        \n        data.* = ResourceData{\n            .ref_count = std.atomic.Atomic(usize).init(1),\n            .allocator = allocator,\n            .value = try allocator.alloc(u8, size),\n        };\n        \n        return Self{ .data = data };\n    }\n    \n    pub fn clone(self: Self) Self {\n        _ = self.data.ref_count.fetchAdd(1, .SeqCst);\n        return self;\n    }\n    \n    pub fn deinit(self: *Self) void {\n        const old_count = self.data.ref_count.fetchSub(1, .SeqCst);\n        if (old_count == 1) {\n            self.data.deinit();\n        }\n        self.* = undefined;\n    }\n};\n\n// Pool pattern for resource reuse\npub fn ResourcePool(comptime Resource: type) type {\n    return struct {\n        const Self = @This();\n        \n        available: std.ArrayList(*Resource),\n        allocator: std.mem.Allocator,\n        \n        pub fn init(allocator: std.mem.Allocator) Self {\n            return Self{\n                .available = std.ArrayList(*Resource).init(allocator),\n                .allocator = allocator,\n            };\n        }\n        \n        pub fn deinit(self: *Self) void {\n            for (self.available.items) |resource| {\n                resource.deinit();\n                self.allocator.destroy(resource);\n            }\n            self.available.deinit();\n        }\n        \n        pub fn acquire(self: *Self) !*Resource {\n            if (self.available.popOrNull()) |resource| {\n                try resource.reset();\n                return resource;\n            }\n            \n            const resource = try self.allocator.create(Resource);\n            resource.* = try Resource.init(self.allocator);\n            return resource;\n        }\n        \n        pub fn release(self: *Self, resource: *Resource) !void {\n            try self.available.append(resource);\n        }\n    };\n}"
    },
    "generic_iteration": {
      "description": "Generic iteration patterns in Zig use comptime type resolution and duck typing to create flexible, reusable iteration interfaces",
      "whenToUse": "Use when building generic algorithms that work with different container types, implementing custom iterators, or creating composable iteration primitives",
      "example": "const std = @import(\"std\");\n\n// Generic iterator interface using duck typing\npub fn Iterator(comptime Item: type) type {\n    return struct {\n        const Self = @This();\n        \n        // Function pointer for polymorphism\n        nextFn: *const fn (self: *Self) ?Item,\n        \n        pub fn next(self: *Self) ?Item {\n            return self.nextFn(self);\n        }\n    };\n}\n\n// Slice iterator\npub fn SliceIterator(comptime T: type) type {\n    return struct {\n        slice: []const T,\n        index: usize,\n        iterator: Iterator(T),\n        \n        const Self = @This();\n        \n        pub fn init(slice: []const T) Self {\n            return Self{\n                .slice = slice,\n                .index = 0,\n                .iterator = Iterator(T){ .nextFn = next },\n            };\n        }\n        \n        fn next(iterator: *Iterator(T)) ?T {\n            const self = @fieldParentPtr(Self, \"iterator\", iterator);\n            if (self.index >= self.slice.len) return null;\n            const item = self.slice[self.index];\n            self.index += 1;\n            return item;\n        }\n    };\n}\n\n// Generic algorithm working with any iterator\npub fn fold(comptime T: type, comptime R: type, iter: *Iterator(T), init: R, f: fn (R, T) R) R {\n    var result = init;\n    while (iter.next()) |item| {\n        result = f(result, item);\n    }\n    return result;\n}\n\n// Iterator combinators\npub fn MapIterator(comptime T: type, comptime U: type) type {\n    return struct {\n        source: *Iterator(T),\n        mapFn: fn (T) U,\n        iterator: Iterator(U),\n        \n        const Self = @This();\n        \n        pub fn init(source: *Iterator(T), mapFn: fn (T) U) Self {\n            return Self{\n                .source = source,\n                .mapFn = mapFn,\n                .iterator = Iterator(U){ .nextFn = next },\n            };\n        }\n        \n        fn next(iterator: *Iterator(U)) ?U {\n            const self = @fieldParentPtr(Self, \"iterator\", iterator);\n            if (self.source.next()) |item| {\n                return self.mapFn(item);\n            }\n            return null;\n        }\n    };\n}\n\npub fn FilterIterator(comptime T: type) type {\n    return struct {\n        source: *Iterator(T),\n        predicate: fn (T) bool,\n        iterator: Iterator(T),\n        \n        const Self = @This();\n        \n        pub fn init(source: *Iterator(T), predicate: fn (T) bool) Self {\n            return Self{\n                .source = source,\n                .predicate = predicate,\n                .iterator = Iterator(T){ .nextFn = next },\n            };\n        }\n        \n        fn next(iterator: *Iterator(T)) ?T {\n            const self = @fieldParentPtr(Self, \"iterator\", iterator);\n            while (self.source.next()) |item| {\n                if (self.predicate(item)) {\n                    return item;\n                }\n            }\n            return null;\n        }\n    };\n}\n\n// Comptime iterator for type lists\npub fn TypeIterator(comptime types: []const type) type {\n    return struct {\n        comptime index: usize = 0,\n        \n        const Self = @This();\n        \n        pub fn next(comptime self: *Self) ?type {\n            if (self.index >= types.len) return null;\n            const T = types[self.index];\n            self.index += 1;\n            return T;\n        }\n    };\n}\n\n// Generic container iteration\npub fn iterateAny(container: anytype) IteratorFor(@TypeOf(container)) {\n    const T = @TypeOf(container);\n    \n    // Check for iterator method\n    if (@hasDecl(T, \"iterator\")) {\n        return container.iterator();\n    }\n    \n    // Check if it's a slice\n    if (@typeInfo(T) == .Pointer) {\n        const ptr_info = @typeInfo(T).Pointer;\n        if (ptr_info.size == .Slice) {\n            return SliceIterator(ptr_info.child).init(container).iterator;\n        }\n    }\n    \n    // Check for custom iteration\n    if (@hasField(T, \"items\")) {\n        return SliceIterator(@TypeOf(container.items[0])).init(container.items).iterator;\n    }\n    \n    @compileError(\"Type \" ++ @typeName(T) ++ \" is not iterable\");\n}\n\n// Lazy evaluation with iterators\npub fn LazyRange(comptime T: type) type {\n    return struct {\n        start: T,\n        end: T,\n        step: T,\n        current: T,\n        iterator: Iterator(T),\n        \n        const Self = @This();\n        \n        pub fn init(start: T, end: T, step: T) Self {\n            return Self{\n                .start = start,\n                .end = end,\n                .step = step,\n                .current = start,\n                .iterator = Iterator(T){ .nextFn = next },\n            };\n        }\n        \n        fn next(iterator: *Iterator(T)) ?T {\n            const self = @fieldParentPtr(Self, \"iterator\", iterator);\n            if (self.step > 0 and self.current >= self.end) return null;\n            if (self.step < 0 and self.current <= self.end) return null;\n            \n            const value = self.current;\n            self.current += self.step;\n            return value;\n        }\n    };\n}\n\n// Usage example\ntest \"generic iteration\" {\n    var numbers = [_]i32{ 1, 2, 3, 4, 5 };\n    var slice_iter = SliceIterator(i32).init(&numbers);\n    \n    const sum = fold(i32, i32, &slice_iter.iterator, 0, struct {\n        fn add(a: i32, b: i32) i32 { return a + b; }\n    }.add);\n    \n    std.testing.expect(sum == 15);\n}"
    },
    "type_erasure": {
      "description": "Type erasure patterns in Zig use vtables, function pointers, or opaque types to create runtime polymorphism while maintaining type safety",
      "whenToUse": "Use when you need runtime polymorphism, plugin systems, dependency injection, or want to hide implementation details while maintaining a stable ABI",
      "example": "const std = @import(\"std\");\n\n// Interface pattern with vtable\npub const Writer = struct {\n    ptr: *anyopaque,\n    writeFn: *const fn (ptr: *anyopaque, data: []const u8) anyerror!void,\n    \n    const Self = @This();\n    \n    pub fn write(self: Self, data: []const u8) !void {\n        return self.writeFn(self.ptr, data);\n    }\n    \n    // Helper to create from any type with write method\n    pub fn init(pointer: anytype) Self {\n        const T = @TypeOf(pointer);\n        const ptr_info = @typeInfo(T);\n        \n        std.debug.assert(ptr_info == .Pointer);\n        std.debug.assert(ptr_info.Pointer.size == .One);\n        \n        const gen = struct {\n            fn writeImpl(ptr: *anyopaque, data: []const u8) anyerror!void {\n                const self = @ptrCast(T, @alignCast(@alignOf(ptr_info.Pointer.child), ptr));\n                return self.write(data);\n            }\n        };\n        \n        return Self{\n            .ptr = pointer,\n            .writeFn = gen.writeImpl,\n        };\n    }\n};\n\n// Concrete implementations\nconst FileWriter = struct {\n    file: std.fs.File,\n    \n    pub fn write(self: *FileWriter, data: []const u8) !void {\n        _ = try self.file.write(data);\n    }\n};\n\nconst BufferWriter = struct {\n    buffer: []u8,\n    pos: usize = 0,\n    \n    pub fn write(self: *BufferWriter, data: []const u8) !void {\n        if (self.pos + data.len > self.buffer.len) {\n            return error.NoSpaceLeft;\n        }\n        std.mem.copy(u8, self.buffer[self.pos..], data);\n        self.pos += data.len;\n    }\n};\n\n// Generic interface with multiple methods\npub fn Interface(comptime VTable: type) type {\n    return struct {\n        ptr: *anyopaque,\n        vtable: *const VTable,\n        \n        const Self = @This();\n        \n        pub fn init(pointer: anytype, vtable: *const VTable) Self {\n            return Self{\n                .ptr = pointer,\n                .vtable = vtable,\n            };\n        }\n    };\n}\n\n// Example: Shape interface\nconst ShapeVTable = struct {\n    area: *const fn (ptr: *anyopaque) f64,\n    perimeter: *const fn (ptr: *anyopaque) f64,\n    name: *const fn (ptr: *anyopaque) []const u8,\n};\n\nconst Shape = Interface(ShapeVTable);\n\nconst Circle = struct {\n    radius: f64,\n    \n    fn area(ptr: *anyopaque) f64 {\n        const self = @ptrCast(*Circle, @alignCast(@alignOf(Circle), ptr));\n        return std.math.pi * self.radius * self.radius;\n    }\n    \n    fn perimeter(ptr: *anyopaque) f64 {\n        const self = @ptrCast(*Circle, @alignCast(@alignOf(Circle), ptr));\n        return 2 * std.math.pi * self.radius;\n    }\n    \n    fn name(_: *anyopaque) []const u8 {\n        return \"Circle\";\n    }\n    \n    const vtable = ShapeVTable{\n        .area = area,\n        .perimeter = perimeter,\n        .name = name,\n    };\n    \n    pub fn shape(self: *Circle) Shape {\n        return Shape.init(self, &vtable);\n    }\n};\n\nconst Rectangle = struct {\n    width: f64,\n    height: f64,\n    \n    fn area(ptr: *anyopaque) f64 {\n        const self = @ptrCast(*Rectangle, @alignCast(@alignOf(Rectangle), ptr));\n        return self.width * self.height;\n    }\n    \n    fn perimeter(ptr: *anyopaque) f64 {\n        const self = @ptrCast(*Rectangle, @alignCast(@alignOf(Rectangle), ptr));\n        return 2 * (self.width + self.height);\n    }\n    \n    fn name(_: *anyopaque) []const u8 {\n        return \"Rectangle\";\n    }\n    \n    const vtable = ShapeVTable{\n        .area = area,\n        .perimeter = perimeter,\n        .name = name,\n    };\n    \n    pub fn shape(self: *Rectangle) Shape {\n        return Shape.init(self, &vtable);\n    }\n};\n\n// Any type container\nconst Any = struct {\n    ptr: *anyopaque,\n    type_id: @Type(.Int),\n    deinit: ?*const fn (ptr: *anyopaque, allocator: std.mem.Allocator) void,\n    \n    pub fn init(comptime T: type, value: *T) Any {\n        return .{\n            .ptr = value,\n            .type_id = typeId(T),\n            .deinit = if (@hasDecl(T, \"deinit\")) getDeinit(T) else null,\n        };\n    }\n    \n    pub fn cast(self: Any, comptime T: type) ?*T {\n        if (self.type_id != typeId(T)) return null;\n        return @ptrCast(*T, @alignCast(@alignOf(T), self.ptr));\n    }\n    \n    pub fn destroy(self: Any, allocator: std.mem.Allocator) void {\n        if (self.deinit) |deinitFn| {\n            deinitFn(self.ptr, allocator);\n        }\n    }\n    \n    fn typeId(comptime T: type) @Type(.Int) {\n        return @intCast(@Type(.Int), @ptrToInt(&struct {\n            var x: u8 = 0;\n        }.x));\n    }\n    \n    fn getDeinit(comptime T: type) *const fn (*anyopaque, std.mem.Allocator) void {\n        return struct {\n            fn deinit(ptr: *anyopaque, allocator: std.mem.Allocator) void {\n                const self = @ptrCast(*T, @alignCast(@alignOf(T), ptr));\n                self.deinit();\n                allocator.destroy(self);\n            }\n        }.deinit;\n    }\n};\n\n// Usage\npub fn processShapes(shapes: []Shape) void {\n    for (shapes) |shape| {\n        std.debug.print(\"{s}: area={d:.2}, perimeter={d:.2}\\n\", .{\n            shape.vtable.name(shape.ptr),\n            shape.vtable.area(shape.ptr),\n            shape.vtable.perimeter(shape.ptr),\n        });\n    }\n}"
    }
  }
}