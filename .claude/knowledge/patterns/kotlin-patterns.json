{
  "language": "kotlin",
  "patterns": {
    "sealed_class": {
      "description": "Represents restricted class hierarchies with exhaustive when expressions.",
      "whenToUse": "For type-safe state management, API results, or any closed set of types.",
      "example": "// Sealed class for API results\nsealed class Result<out T> {\n    data class Success<T>(val data: T) : Result<T>()\n    data class Error(val exception: Exception) : Result<Nothing>()\n    object Loading : Result<Nothing>()\n}\n\n// Usage with exhaustive when\nfun <T> handleResult(result: Result<T>) {\n    when (result) {\n        is Result.Success -> println(\"Success: ${result.data}\")\n        is Result.Error -> println(\"Error: ${result.exception.message}\")\n        Result.Loading -> println(\"Loading...\")\n    }\n}\n\n// Sealed class for UI states\nsealed class ViewState {\n    object Idle : ViewState()\n    object Loading : ViewState()\n    data class Success(val data: List<Item>) : ViewState()\n    data class Error(val message: String) : ViewState()\n    \n    fun isLoading() = this is Loading\n    fun hasError() = this is Error\n}\n\n// Sealed interface (Kotlin 1.5+)\nsealed interface Event {\n    data class Click(val id: String) : Event\n    data class LongPress(val id: String, val duration: Long) : Event\n    object Refresh : Event\n    \n    sealed class Navigation : Event {\n        data class Forward(val destination: String) : Navigation()\n        object Back : Navigation()\n        data class DeepLink(val url: String) : Navigation()\n    }\n}\n\n// Advanced sealed class with methods\nsealed class PaymentMethod {\n    abstract fun processPayment(amount: Double): PaymentResult\n    \n    data class CreditCard(\n        val number: String,\n        val cvv: String,\n        val expiry: String\n    ) : PaymentMethod() {\n        override fun processPayment(amount: Double): PaymentResult {\n            // Process credit card payment\n            return PaymentResult.Success(transactionId = \"CC-${System.currentTimeMillis()}\")\n        }\n    }\n    \n    data class PayPal(\n        val email: String,\n        val token: String\n    ) : PaymentMethod() {\n        override fun processPayment(amount: Double): PaymentResult {\n            // Process PayPal payment\n            return PaymentResult.Success(transactionId = \"PP-${System.currentTimeMillis()}\")\n        }\n    }\n    \n    object Cash : PaymentMethod() {\n        override fun processPayment(amount: Double): PaymentResult {\n            return PaymentResult.Success(transactionId = \"CASH-${System.currentTimeMillis()}\")\n        }\n    }\n}\n\nsealed class PaymentResult {\n    data class Success(val transactionId: String) : PaymentResult()\n    data class Failure(val reason: String) : PaymentResult()\n    object Cancelled : PaymentResult()\n}"
    },
    "dsl_builder": {
      "description": "Creates domain-specific languages using Kotlin's syntax features.",
      "whenToUse": "When you want to create expressive, type-safe APIs for configuration or construction.",
      "example": "// HTML DSL\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nabstract class Tag(val name: String) {\n    val children = mutableListOf<Tag>()\n    val attributes = mutableMapOf<String, String>()\n    \n    protected fun <T : Tag> initTag(tag: T, init: T.() -> Unit): T {\n        tag.init()\n        children.add(tag)\n        return tag\n    }\n    \n    override fun toString(): String {\n        val attrs = if (attributes.isEmpty()) \"\" \n            else attributes.map { (k, v) -> \" $k=\\\"$v\\\"\" }.joinToString(\"\")\n        return \"<$name$attrs>${children.joinToString(\"\")}</$name>\"\n    }\n}\n\nclass HTML : Tag(\"html\") {\n    fun head(init: Head.() -> Unit) = initTag(Head(), init)\n    fun body(init: Body.() -> Unit) = initTag(Body(), init)\n}\n\nclass Head : Tag(\"head\") {\n    fun title(init: Title.() -> Unit) = initTag(Title(), init)\n}\n\nclass Title : Tag(\"title\") {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass Body : Tag(\"body\") {\n    fun h1(init: H1.() -> Unit) = initTag(H1(), init)\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun div(init: Div.() -> Unit) = initTag(Div(), init)\n}\n\nclass H1 : Tag(\"h1\") {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass P : Tag(\"p\") {\n    operator fun String.unaryPlus() {\n        children.add(TextElement(this))\n    }\n}\n\nclass Div : Tag(\"div\") {\n    fun p(init: P.() -> Unit) = initTag(P(), init)\n    fun div(init: Div.() -> Unit) = initTag(Div(), init)\n}\n\nclass TextElement(val text: String) : Tag(\"\") {\n    override fun toString() = text\n}\n\nfun html(init: HTML.() -> Unit): HTML {\n    val html = HTML()\n    html.init()\n    return html\n}\n\n// Usage\nval document = html {\n    head {\n        title { +\"My Page\" }\n    }\n    body {\n        h1 { +\"Welcome\" }\n        div {\n            attributes[\"class\"] = \"container\"\n            p { +\"This is a paragraph\" }\n            p { +\"Another paragraph\" }\n        }\n    }\n}\n\n// HTTP Request DSL\nclass HttpRequestBuilder {\n    var url: String = \"\"\n    var method: HttpMethod = HttpMethod.GET\n    private val headers = mutableMapOf<String, String>()\n    private val params = mutableMapOf<String, String>()\n    var body: Any? = null\n    \n    fun header(name: String, value: String) {\n        headers[name] = value\n    }\n    \n    fun param(name: String, value: String) {\n        params[name] = value\n    }\n    \n    fun headers(block: MutableMap<String, String>.() -> Unit) {\n        headers.block()\n    }\n    \n    fun params(block: MutableMap<String, String>.() -> Unit) {\n        params.block()\n    }\n    \n    fun build(): HttpRequest {\n        return HttpRequest(url, method, headers.toMap(), params.toMap(), body)\n    }\n}\n\ndata class HttpRequest(\n    val url: String,\n    val method: HttpMethod,\n    val headers: Map<String, String>,\n    val params: Map<String, String>,\n    val body: Any?\n)\n\nenum class HttpMethod { GET, POST, PUT, DELETE }\n\ninline fun httpRequest(block: HttpRequestBuilder.() -> Unit): HttpRequest {\n    return HttpRequestBuilder().apply(block).build()\n}\n\n// Usage\nval request = httpRequest {\n    url = \"https://api.example.com/users\"\n    method = HttpMethod.POST\n    \n    headers {\n        put(\"Content-Type\", \"application/json\")\n        put(\"Authorization\", \"Bearer token123\")\n    }\n    \n    body = mapOf(\n        \"name\" to \"John Doe\",\n        \"email\" to \"john@example.com\"\n    )\n}\n\n// Configuration DSL\n@DslMarker\nannotation class ConfigDsl\n\n@ConfigDsl\nclass ServerConfig {\n    var host: String = \"localhost\"\n    var port: Int = 8080\n    var ssl: SslConfig? = null\n    \n    fun ssl(block: SslConfig.() -> Unit) {\n        ssl = SslConfig().apply(block)\n    }\n}\n\n@ConfigDsl\nclass SslConfig {\n    var keyStore: String = \"\"\n    var keyStorePassword: String = \"\"\n    var trustStore: String = \"\"\n    var trustStorePassword: String = \"\"\n}\n\n@ConfigDsl\nclass DatabaseConfig {\n    var url: String = \"\"\n    var username: String = \"\"\n    var password: String = \"\"\n    var maxConnections: Int = 10\n}\n\n@ConfigDsl\nclass AppConfig {\n    var name: String = \"MyApp\"\n    var version: String = \"1.0.0\"\n    var server: ServerConfig? = null\n    var database: DatabaseConfig? = null\n    \n    fun server(block: ServerConfig.() -> Unit) {\n        server = ServerConfig().apply(block)\n    }\n    \n    fun database(block: DatabaseConfig.() -> Unit) {\n        database = DatabaseConfig().apply(block)\n    }\n}\n\nfun configure(block: AppConfig.() -> Unit): AppConfig {\n    return AppConfig().apply(block)\n}\n\n// Usage\nval config = configure {\n    name = \"MyApplication\"\n    version = \"2.0.0\"\n    \n    server {\n        host = \"0.0.0.0\"\n        port = 443\n        \n        ssl {\n            keyStore = \"/path/to/keystore.jks\"\n            keyStorePassword = \"secret\"\n        }\n    }\n    \n    database {\n        url = \"jdbc:postgresql://localhost:5432/mydb\"\n        username = \"dbuser\"\n        password = \"dbpass\"\n        maxConnections = 20\n    }\n}"
    },
    "coroutines": {
      "description": "Handles asynchronous programming with lightweight coroutines.",
      "whenToUse": "For non-blocking I/O, concurrent operations, and reactive programming.",
      "example": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n// Repository with coroutines\nclass UserRepository {\n    suspend fun getUser(id: String): User {\n        return withContext(Dispatchers.IO) {\n            // Simulate network call\n            delay(1000)\n            User(id, \"User $id\", \"user$id@example.com\")\n        }\n    }\n    \n    suspend fun getUsers(): List<User> {\n        return withContext(Dispatchers.IO) {\n            delay(1500)\n            (1..10).map { User(\"$it\", \"User $it\", \"user$it@example.com\") }\n        }\n    }\n    \n    fun getUsersFlow(): Flow<List<User>> = flow {\n        while (true) {\n            emit(getUsers())\n            delay(5000) // Refresh every 5 seconds\n        }\n    }.flowOn(Dispatchers.IO)\n}\n\ndata class User(val id: String, val name: String, val email: String)\n\n// ViewModel with coroutines\nclass UserViewModel(private val repository: UserRepository) {\n    private val _uiState = MutableStateFlow(UiState())\n    val uiState: StateFlow<UiState> = _uiState.asStateFlow()\n    \n    private val viewModelScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n    \n    fun loadUser(id: String) {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n            \n            try {\n                val user = repository.getUser(id)\n                _uiState.update { \n                    it.copy(isLoading = false, user = user, error = null)\n                }\n            } catch (e: Exception) {\n                _uiState.update { \n                    it.copy(isLoading = false, error = e.message)\n                }\n            }\n        }\n    }\n    \n    fun observeUsers() {\n        repository.getUsersFlow()\n            .catch { e -> \n                _uiState.update { it.copy(error = e.message) }\n            }\n            .onEach { users ->\n                _uiState.update { it.copy(users = users) }\n            }\n            .launchIn(viewModelScope)\n    }\n    \n    fun cleanup() {\n        viewModelScope.cancel()\n    }\n}\n\ndata class UiState(\n    val isLoading: Boolean = false,\n    val user: User? = null,\n    val users: List<User> = emptyList(),\n    val error: String? = null\n)\n\n// Concurrent operations\nsuspend fun performConcurrentOperations() {\n    coroutineScope {\n        val deferred1 = async { fetchDataFromApi1() }\n        val deferred2 = async { fetchDataFromApi2() }\n        val deferred3 = async { fetchDataFromApi3() }\n        \n        val results = awaitAll(deferred1, deferred2, deferred3)\n        println(\"All results: $results\")\n    }\n}\n\nsuspend fun fetchDataFromApi1(): String {\n    delay(1000)\n    return \"Data from API 1\"\n}\n\nsuspend fun fetchDataFromApi2(): String {\n    delay(1500)\n    return \"Data from API 2\"\n}\n\nsuspend fun fetchDataFromApi3(): String {\n    delay(800)\n    return \"Data from API 3\"\n}\n\n// Channel example\nclass EventBus {\n    private val _events = Channel<Event>(Channel.UNLIMITED)\n    val events = _events.receiveAsFlow()\n    \n    suspend fun sendEvent(event: Event) {\n        _events.send(event)\n    }\n}\n\nsealed class Event {\n    data class UserLoggedIn(val userId: String) : Event()\n    data class UserLoggedOut(val userId: String) : Event()\n    data class DataUpdated(val data: Any) : Event()\n}\n\n// Flow operators\nfun demonstrateFlowOperators() {\n    val numbers = (1..10).asFlow()\n    \n    runBlocking {\n        numbers\n            .filter { it % 2 == 0 }\n            .map { it * it }\n            .take(3)\n            .collect { println(it) }\n    }\n    \n    // State management with flows\n    val stateFlow = MutableStateFlow(0)\n    \n    // Combine multiple flows\n    val flow1 = flowOf(1, 2, 3)\n    val flow2 = flowOf(\"A\", \"B\", \"C\")\n    \n    runBlocking {\n        flow1.zip(flow2) { num, letter ->\n            \"$num$letter\"\n        }.collect { println(it) }\n    }\n}\n\n// Error handling with coroutines\nsuspend fun safeApiCall(): Result<String> {\n    return try {\n        coroutineScope {\n            val data = withTimeout(5000) {\n                // API call\n                delay(1000)\n                \"Success data\"\n            }\n            Result.success(data)\n        }\n    } catch (e: TimeoutCancellationException) {\n        Result.failure(Exception(\"Request timed out\"))\n    } catch (e: Exception) {\n        Result.failure(e)\n    }\n}"
    },
    "extension_functions": {
      "description": "Adds new functionality to existing classes without inheritance.",
      "whenToUse": "To extend third-party classes, create DSLs, or add utility functions.",
      "example": "// String extensions\nfun String.isEmail(): Boolean {\n    return this.matches(Regex(\"^[A-Za-z0-9+_.-]+@([A-Za-z0-9.-]+\\\\.[A-Za-z]{2,})$\"))\n}\n\nfun String.capitalizeWords(): String {\n    return this.split(\" \").joinToString(\" \") { word ->\n        word.lowercase().replaceFirstChar { it.uppercase() }\n    }\n}\n\nfun String?.orEmpty(): String = this ?: \"\"\n\nfun String.truncate(maxLength: Int, suffix: String = \"...\"): String {\n    return if (this.length <= maxLength) this\n    else this.take(maxLength - suffix.length) + suffix\n}\n\n// Collection extensions\nfun <T> List<T>.second(): T? = if (size >= 2) this[1] else null\n\nfun <T> List<T>.third(): T? = if (size >= 3) this[2] else null\n\nfun <T> Collection<T>.ifEmpty(defaultValue: () -> Collection<T>): Collection<T> {\n    return if (isEmpty()) defaultValue() else this\n}\n\nfun <T> MutableList<T>.swap(index1: Int, index2: Int) {\n    val tmp = this[index1]\n    this[index1] = this[index2]\n    this[index2] = tmp\n}\n\nfun <T> List<T>.randomOrNull(): T? {\n    return if (isEmpty()) null else random()\n}\n\n// Map extensions\nfun <K, V> Map<K, V>.getOrThrow(key: K, message: String? = null): V {\n    return get(key) ?: throw NoSuchElementException(\n        message ?: \"Key $key not found in map\"\n    )\n}\n\nfun <K, V> MutableMap<K, V>.putIfAbsentOrUpdate(\n    key: K, \n    value: V, \n    update: (V) -> V\n): V {\n    return if (containsKey(key)) {\n        val updated = update(getValue(key))\n        put(key, updated)\n        updated\n    } else {\n        put(key, value)\n        value\n    }\n}\n\n// Date extensions\nimport java.time.LocalDateTime\nimport java.time.format.DateTimeFormatter\n\nfun LocalDateTime.toReadableString(): String {\n    return format(DateTimeFormatter.ofPattern(\"MMM dd, yyyy 'at' HH:mm\"))\n}\n\nfun LocalDateTime.isToday(): Boolean {\n    return toLocalDate() == LocalDateTime.now().toLocalDate()\n}\n\nfun LocalDateTime.daysUntil(other: LocalDateTime): Long {\n    return java.time.Duration.between(this, other).toDays()\n}\n\n// Scope function extensions\ninline fun <T> T.applyIf(condition: Boolean, block: T.() -> Unit): T {\n    return if (condition) {\n        this.apply(block)\n    } else {\n        this\n    }\n}\n\ninline fun <T, R> T.letIf(condition: Boolean, block: (T) -> R): R? {\n    return if (condition) block(this) else null\n}\n\ninline fun <T> T.alsoIf(condition: Boolean, block: (T) -> Unit): T {\n    if (condition) block(this)\n    return this\n}\n\n// Android View extensions\n/*\nfun View.visible() {\n    visibility = View.VISIBLE\n}\n\nfun View.invisible() {\n    visibility = View.INVISIBLE\n}\n\nfun View.gone() {\n    visibility = View.GONE\n}\n\nfun View.isVisible() = visibility == View.VISIBLE\n\nfun View.onClick(action: (View) -> Unit) {\n    setOnClickListener(action)\n}\n*/\n\n// Nullable extensions\nfun <T : Any> T?.requireNotNull(lazyMessage: () -> String): T {\n    return this ?: throw IllegalArgumentException(lazyMessage())\n}\n\nfun <T> T?.ifNull(block: () -> Unit): T? {\n    if (this == null) block()\n    return this\n}\n\n// Result extensions\ninline fun <T, R> Result<T>.mapCatching(transform: (T) -> R): Result<R> {\n    return when {\n        isSuccess -> {\n            try {\n                Result.success(transform(getOrThrow()))\n            } catch (e: Exception) {\n                Result.failure(e)\n            }\n        }\n        else -> Result.failure(exceptionOrNull()!!)\n    }\n}\n\nfun <T> Result<T>.onFailureReturn(default: T): T {\n    return getOrElse { default }\n}\n\n// Higher-order function extensions\nfun <T> (() -> T).memoize(): () -> T {\n    var result: T? = null\n    return {\n        if (result == null) {\n            result = this()\n        }\n        result!!\n    }\n}\n\nfun <T, R> ((T) -> R).curry(): (T) -> () -> R = { t -> { this(t) } }"
    },
    "singleton": {
      "description": "Ensures a class has only one instance using object declaration.",
      "whenToUse": "For managing shared resources, configuration, or services.",
      "example": "// Object declaration (simplest singleton)\nobject DatabaseManager {\n    private var connection: Connection? = null\n    \n    fun connect(url: String, username: String, password: String) {\n        if (connection == null) {\n            connection = DriverManager.getConnection(url, username, password)\n            println(\"Database connected\")\n        }\n    }\n    \n    fun executeQuery(sql: String): ResultSet? {\n        return connection?.createStatement()?.executeQuery(sql)\n    }\n    \n    fun disconnect() {\n        connection?.close()\n        connection = null\n        println(\"Database disconnected\")\n    }\n}\n\n// Singleton with parameters (using class)\nclass ConfigManager private constructor(private val configFile: String) {\n    private val properties = Properties()\n    \n    init {\n        loadConfig()\n    }\n    \n    private fun loadConfig() {\n        // Load configuration from file\n        println(\"Loading config from $configFile\")\n    }\n    \n    fun getProperty(key: String): String? = properties.getProperty(key)\n    \n    fun setProperty(key: String, value: String) {\n        properties.setProperty(key, value)\n    }\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: ConfigManager? = null\n        \n        fun getInstance(configFile: String = \"config.properties\"): ConfigManager {\n            return INSTANCE ?: synchronized(this) {\n                INSTANCE ?: ConfigManager(configFile).also { INSTANCE = it }\n            }\n        }\n    }\n}\n\n// Thread-safe singleton with lazy initialization\nclass Logger private constructor() {\n    private val logs = mutableListOf<LogEntry>()\n    \n    fun log(level: LogLevel, message: String) {\n        val entry = LogEntry(\n            timestamp = System.currentTimeMillis(),\n            level = level,\n            message = message,\n            thread = Thread.currentThread().name\n        )\n        synchronized(logs) {\n            logs.add(entry)\n        }\n        println(\"[${entry.level}] ${entry.timestamp}: ${entry.message}\")\n    }\n    \n    fun info(message: String) = log(LogLevel.INFO, message)\n    fun warning(message: String) = log(LogLevel.WARNING, message)\n    fun error(message: String) = log(LogLevel.ERROR, message)\n    \n    companion object {\n        val instance: Logger by lazy { Logger() }\n    }\n    \n    data class LogEntry(\n        val timestamp: Long,\n        val level: LogLevel,\n        val message: String,\n        val thread: String\n    )\n    \n    enum class LogLevel { INFO, WARNING, ERROR }\n}\n\n// Singleton with interface\ninterface Cache<K, V> {\n    fun put(key: K, value: V)\n    fun get(key: K): V?\n    fun remove(key: K)\n    fun clear()\n}\n\nobject MemoryCache : Cache<String, Any> {\n    private val cache = mutableMapOf<String, Any>()\n    \n    override fun put(key: String, value: Any) {\n        cache[key] = value\n    }\n    \n    override fun get(key: String): Any? = cache[key]\n    \n    override fun remove(key: String) {\n        cache.remove(key)\n    }\n    \n    override fun clear() {\n        cache.clear()\n    }\n    \n    fun size() = cache.size\n}\n\n// Companion object as factory\nclass NetworkClient private constructor(\n    private val baseUrl: String,\n    private val timeout: Int\n) {\n    fun makeRequest(endpoint: String): String {\n        // Make network request\n        return \"Response from $baseUrl$endpoint\"\n    }\n    \n    companion object Factory {\n        private var instance: NetworkClient? = null\n        \n        fun create(baseUrl: String, timeout: Int = 30): NetworkClient {\n            if (instance == null) {\n                instance = NetworkClient(baseUrl, timeout)\n            }\n            return instance!!\n        }\n        \n        fun getInstance(): NetworkClient {\n            return instance ?: throw IllegalStateException(\n                \"NetworkClient not initialized. Call create() first.\"\n            )\n        }\n    }\n}\n\n// Enum singleton\nenum class AppTheme(val primaryColor: String, val backgroundColor: String) {\n    LIGHT(\"#000000\", \"#FFFFFF\"),\n    DARK(\"#FFFFFF\", \"#000000\");\n    \n    companion object {\n        private var current: AppTheme = LIGHT\n        \n        fun getCurrent() = current\n        \n        fun setCurrent(theme: AppTheme) {\n            current = theme\n        }\n        \n        fun toggle() {\n            current = if (current == LIGHT) DARK else LIGHT\n        }\n    }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step using apply, also, or dedicated builder classes.",
      "whenToUse": "When creating objects with many parameters or complex initialization logic.",
      "example": "// Data class with builder\ndata class User private constructor(\n    val id: String,\n    val name: String,\n    val email: String,\n    val age: Int?,\n    val address: Address?,\n    val phoneNumbers: List<String>,\n    val preferences: UserPreferences\n) {\n    class Builder {\n        private var id: String = \"\"\n        private var name: String = \"\"\n        private var email: String = \"\"\n        private var age: Int? = null\n        private var address: Address? = null\n        private val phoneNumbers = mutableListOf<String>()\n        private var preferences: UserPreferences = UserPreferences()\n        \n        fun id(id: String) = apply { this.id = id }\n        fun name(name: String) = apply { this.name = name }\n        fun email(email: String) = apply { this.email = email }\n        fun age(age: Int) = apply { this.age = age }\n        fun address(address: Address) = apply { this.address = address }\n        fun phoneNumber(number: String) = apply { phoneNumbers.add(number) }\n        fun phoneNumbers(numbers: List<String>) = apply { phoneNumbers.addAll(numbers) }\n        fun preferences(init: UserPreferences.Builder.() -> Unit) = apply {\n            preferences = UserPreferences.Builder().apply(init).build()\n        }\n        \n        fun build(): User {\n            require(id.isNotEmpty()) { \"User ID is required\" }\n            require(name.isNotEmpty()) { \"User name is required\" }\n            require(email.isNotEmpty()) { \"User email is required\" }\n            require(email.contains(\"@\")) { \"Invalid email format\" }\n            \n            return User(id, name, email, age, address, phoneNumbers.toList(), preferences)\n        }\n    }\n    \n    companion object {\n        fun builder() = Builder()\n    }\n}\n\ndata class Address(\n    val street: String,\n    val city: String,\n    val zipCode: String,\n    val country: String\n)\n\ndata class UserPreferences(\n    val newsletter: Boolean = false,\n    val notifications: Boolean = true,\n    val theme: String = \"light\"\n) {\n    class Builder {\n        private var newsletter: Boolean = false\n        private var notifications: Boolean = true\n        private var theme: String = \"light\"\n        \n        fun newsletter(enabled: Boolean) = apply { newsletter = enabled }\n        fun notifications(enabled: Boolean) = apply { notifications = enabled }\n        fun theme(theme: String) = apply { this.theme = theme }\n        \n        fun build() = UserPreferences(newsletter, notifications, theme)\n    }\n}\n\n// Usage\nval user = User.builder()\n    .id(\"123\")\n    .name(\"John Doe\")\n    .email(\"john@example.com\")\n    .age(30)\n    .address(Address(\"123 Main St\", \"City\", \"12345\", \"USA\"))\n    .phoneNumber(\"+1234567890\")\n    .preferences {\n        newsletter(true)\n        theme(\"dark\")\n    }\n    .build()\n\n// Fluent builder with type safety\nclass SqlQueryBuilder {\n    private var selectColumns = mutableListOf<String>()\n    private var fromTable: String? = null\n    private var whereConditions = mutableListOf<String>()\n    private var orderByColumns = mutableListOf<Pair<String, OrderDirection>>()\n    private var limitValue: Int? = null\n    \n    fun select(vararg columns: String) = apply {\n        selectColumns.addAll(columns)\n    }\n    \n    fun from(table: String) = apply {\n        fromTable = table\n    }\n    \n    fun where(condition: String) = apply {\n        whereConditions.add(condition)\n    }\n    \n    fun where(column: String, operator: String, value: Any) = apply {\n        whereConditions.add(\"$column $operator '$value'\")\n    }\n    \n    fun orderBy(column: String, direction: OrderDirection = OrderDirection.ASC) = apply {\n        orderByColumns.add(column to direction)\n    }\n    \n    fun limit(value: Int) = apply {\n        limitValue = value\n    }\n    \n    fun build(): String {\n        require(fromTable != null) { \"FROM table must be specified\" }\n        require(selectColumns.isNotEmpty()) { \"SELECT columns must be specified\" }\n        \n        return buildString {\n            append(\"SELECT \")\n            append(selectColumns.joinToString(\", \"))\n            append(\" FROM \")\n            append(fromTable)\n            \n            if (whereConditions.isNotEmpty()) {\n                append(\" WHERE \")\n                append(whereConditions.joinToString(\" AND \"))\n            }\n            \n            if (orderByColumns.isNotEmpty()) {\n                append(\" ORDER BY \")\n                append(orderByColumns.joinToString(\", \") { (col, dir) -> \n                    \"$col ${dir.name}\"\n                })\n            }\n            \n            limitValue?.let { append(\" LIMIT $it\") }\n        }\n    }\n    \n    enum class OrderDirection { ASC, DESC }\n}\n\n// Generic builder pattern\nabstract class Builder<T> {\n    abstract fun build(): T\n    \n    protected fun validate(condition: Boolean, message: String) {\n        if (!condition) {\n            throw IllegalStateException(message)\n        }\n    }\n}\n\nclass EmailBuilder : Builder<Email>() {\n    private var from: String? = null\n    private val to = mutableListOf<String>()\n    private val cc = mutableListOf<String>()\n    private val bcc = mutableListOf<String>()\n    private var subject: String? = null\n    private var body: String? = null\n    private val attachments = mutableListOf<Attachment>()\n    \n    fun from(address: String) = apply { from = address }\n    fun to(address: String) = apply { to.add(address) }\n    fun cc(address: String) = apply { cc.add(address) }\n    fun bcc(address: String) = apply { bcc.add(address) }\n    fun subject(text: String) = apply { subject = text }\n    fun body(text: String) = apply { body = text }\n    fun attach(file: Attachment) = apply { attachments.add(file) }\n    \n    override fun build(): Email {\n        validate(from != null, \"From address is required\")\n        validate(to.isNotEmpty(), \"At least one recipient is required\")\n        validate(subject != null, \"Subject is required\")\n        validate(body != null, \"Body is required\")\n        \n        return Email(\n            from = from!!,\n            to = to.toList(),\n            cc = cc.toList(),\n            bcc = bcc.toList(),\n            subject = subject!!,\n            body = body!!,\n            attachments = attachments.toList()\n        )\n    }\n}\n\ndata class Email(\n    val from: String,\n    val to: List<String>,\n    val cc: List<String>,\n    val bcc: List<String>,\n    val subject: String,\n    val body: String,\n    val attachments: List<Attachment>\n)\n\ndata class Attachment(val filename: String, val data: ByteArray)"
    },
    "factory": {
      "description": "Creates objects without specifying their exact types using companion objects or functions.",
      "whenToUse": "When object creation logic is complex or needs to be decided at runtime.",
      "example": "// Simple factory using companion object\ninterface Vehicle {\n    fun drive()\n    fun getFuelType(): String\n}\n\nclass Car(private val model: String) : Vehicle {\n    override fun drive() = println(\"Driving car: $model\")\n    override fun getFuelType() = \"Gasoline\"\n}\n\nclass ElectricCar(private val model: String) : Vehicle {\n    override fun drive() = println(\"Driving electric car: $model\")\n    override fun getFuelType() = \"Electricity\"\n}\n\nclass Motorcycle(private val model: String) : Vehicle {\n    override fun drive() = println(\"Riding motorcycle: $model\")\n    override fun getFuelType() = \"Gasoline\"\n}\n\nclass VehicleFactory {\n    companion object {\n        fun createVehicle(type: VehicleType, model: String): Vehicle {\n            return when (type) {\n                VehicleType.CAR -> Car(model)\n                VehicleType.ELECTRIC_CAR -> ElectricCar(model)\n                VehicleType.MOTORCYCLE -> Motorcycle(model)\n            }\n        }\n        \n        fun createVehicleFromConfig(config: VehicleConfig): Vehicle {\n            return when {\n                config.isElectric && config.wheels == 4 -> ElectricCar(config.model)\n                config.wheels == 4 -> Car(config.model)\n                config.wheels == 2 -> Motorcycle(config.model)\n                else -> throw IllegalArgumentException(\"Unsupported vehicle configuration\")\n            }\n        }\n    }\n}\n\nenum class VehicleType {\n    CAR, ELECTRIC_CAR, MOTORCYCLE\n}\n\ndata class VehicleConfig(\n    val model: String,\n    val wheels: Int,\n    val isElectric: Boolean\n)\n\n// Abstract factory pattern\ninterface UIFactory {\n    fun createButton(): Button\n    fun createTextField(): TextField\n    fun createCheckbox(): Checkbox\n}\n\ninterface Button {\n    fun click()\n}\n\ninterface TextField {\n    fun setText(text: String)\n    fun getText(): String\n}\n\ninterface Checkbox {\n    fun check()\n    fun uncheck()\n    fun isChecked(): Boolean\n}\n\n// Material Design implementation\nclass MaterialUIFactory : UIFactory {\n    override fun createButton() = MaterialButton()\n    override fun createTextField() = MaterialTextField()\n    override fun createCheckbox() = MaterialCheckbox()\n}\n\nclass MaterialButton : Button {\n    override fun click() = println(\"Material button clicked\")\n}\n\nclass MaterialTextField : TextField {\n    private var text = \"\"\n    override fun setText(text: String) { this.text = text }\n    override fun getText() = text\n}\n\nclass MaterialCheckbox : Checkbox {\n    private var checked = false\n    override fun check() { checked = true }\n    override fun uncheck() { checked = false }\n    override fun isChecked() = checked\n}\n\n// iOS implementation\nclass IOSUIFactory : UIFactory {\n    override fun createButton() = IOSButton()\n    override fun createTextField() = IOSTextField()\n    override fun createCheckbox() = IOSCheckbox()\n}\n\nclass IOSButton : Button {\n    override fun click() = println(\"iOS button tapped\")\n}\n\nclass IOSTextField : TextField {\n    private var text = \"\"\n    override fun setText(text: String) { this.text = text }\n    override fun getText() = text\n}\n\nclass IOSCheckbox : Checkbox {\n    private var checked = false\n    override fun check() { checked = true }\n    override fun uncheck() { checked = false }\n    override fun isChecked() = checked\n}\n\n// Factory method pattern\nabstract class Document {\n    abstract fun open()\n    abstract fun save()\n    abstract fun close()\n}\n\nclass PDFDocument : Document() {\n    override fun open() = println(\"Opening PDF document\")\n    override fun save() = println(\"Saving PDF document\")\n    override fun close() = println(\"Closing PDF document\")\n}\n\nclass WordDocument : Document() {\n    override fun open() = println(\"Opening Word document\")\n    override fun save() = println(\"Saving Word document\")\n    override fun close() = println(\"Closing Word document\")\n}\n\nclass SpreadsheetDocument : Document() {\n    override fun open() = println(\"Opening Spreadsheet document\")\n    override fun save() = println(\"Saving Spreadsheet document\")\n    override fun close() = println(\"Closing Spreadsheet document\")\n}\n\nabstract class Application {\n    abstract fun createDocument(): Document\n    \n    fun newDocument() {\n        val doc = createDocument()\n        doc.open()\n        documents.add(doc)\n    }\n    \n    private val documents = mutableListOf<Document>()\n}\n\nclass PDFApplication : Application() {\n    override fun createDocument() = PDFDocument()\n}\n\nclass WordApplication : Application() {\n    override fun createDocument() = WordDocument()\n}\n\n// Generic factory with registration\nclass GenericFactory<T> {\n    private val creators = mutableMapOf<String, () -> T>()\n    \n    fun register(key: String, creator: () -> T) {\n        creators[key] = creator\n    }\n    \n    fun create(key: String): T {\n        return creators[key]?.invoke()\n            ?: throw IllegalArgumentException(\"No creator registered for key: $key\")\n    }\n    \n    fun createOrNull(key: String): T? {\n        return creators[key]?.invoke()\n    }\n}\n\n// Usage\nval shapeFactory = GenericFactory<Shape>()\nshapeFactory.register(\"circle\") { Circle(5.0) }\nshapeFactory.register(\"rectangle\") { Rectangle(10.0, 20.0) }\nshapeFactory.register(\"triangle\") { Triangle(3.0, 4.0, 5.0) }\n\ninterface Shape {\n    fun area(): Double\n}\n\nclass Circle(private val radius: Double) : Shape {\n    override fun area() = Math.PI * radius * radius\n}\n\nclass Rectangle(private val width: Double, private val height: Double) : Shape {\n    override fun area() = width * height\n}\n\nclass Triangle(private val a: Double, private val b: Double, private val c: Double) : Shape {\n    override fun area(): Double {\n        val s = (a + b + c) / 2\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c))\n    }\n}"
    },
    "strategy": {
      "description": "Encapsulates algorithms and makes them interchangeable using interfaces or function types.",
      "whenToUse": "When you have multiple ways to perform a task and want to switch between them.",
      "example": "// Strategy interface\ninterface PaymentStrategy {\n    fun pay(amount: Double): PaymentResult\n}\n\n// Concrete strategies\nclass CreditCardPayment(\n    private val cardNumber: String,\n    private val cvv: String,\n    private val expiryDate: String\n) : PaymentStrategy {\n    override fun pay(amount: Double): PaymentResult {\n        println(\"Processing $$amount via Credit Card ending in ${cardNumber.takeLast(4)}\")\n        // Process payment\n        return PaymentResult.Success(\"CC-${System.currentTimeMillis()}\")\n    }\n}\n\nclass PayPalPayment(\n    private val email: String,\n    private val password: String\n) : PaymentStrategy {\n    override fun pay(amount: Double): PaymentResult {\n        println(\"Processing $$amount via PayPal account: $email\")\n        // Process payment\n        return PaymentResult.Success(\"PP-${System.currentTimeMillis()}\")\n    }\n}\n\nclass CryptoPayment(\n    private val walletAddress: String,\n    private val cryptocurrency: String\n) : PaymentStrategy {\n    override fun pay(amount: Double): PaymentResult {\n        println(\"Processing $$amount in $cryptocurrency to wallet: $walletAddress\")\n        // Process payment\n        return PaymentResult.Success(\"CRYPTO-${System.currentTimeMillis()}\")\n    }\n}\n\nsealed class PaymentResult {\n    data class Success(val transactionId: String) : PaymentResult()\n    data class Failure(val reason: String) : PaymentResult()\n}\n\n// Context\nclass ShoppingCart {\n    private val items = mutableListOf<CartItem>()\n    private var paymentStrategy: PaymentStrategy? = null\n    \n    fun addItem(item: CartItem) {\n        items.add(item)\n    }\n    \n    fun setPaymentStrategy(strategy: PaymentStrategy) {\n        paymentStrategy = strategy\n    }\n    \n    fun checkout(): PaymentResult {\n        val strategy = paymentStrategy \n            ?: return PaymentResult.Failure(\"No payment method selected\")\n            \n        val total = items.sumOf { it.price * it.quantity }\n        return strategy.pay(total)\n    }\n}\n\ndata class CartItem(val name: String, val price: Double, val quantity: Int)\n\n// Strategy with function types\nclass TextProcessor {\n    fun process(\n        text: String,\n        strategy: (String) -> String\n    ): String {\n        return strategy(text)\n    }\n}\n\n// Predefined strategies\nval upperCaseStrategy: (String) -> String = { it.uppercase() }\nval lowerCaseStrategy: (String) -> String = { it.lowercase() }\nval reverseStrategy: (String) -> String = { it.reversed() }\nval trimStrategy: (String) -> String = { it.trim() }\n\n// Compression strategy example\ninterface CompressionStrategy {\n    fun compress(data: ByteArray): ByteArray\n    fun decompress(data: ByteArray): ByteArray\n    val fileExtension: String\n}\n\nclass ZipCompression : CompressionStrategy {\n    override fun compress(data: ByteArray): ByteArray {\n        // ZIP compression implementation\n        println(\"Compressing with ZIP\")\n        return data // Simplified\n    }\n    \n    override fun decompress(data: ByteArray): ByteArray {\n        // ZIP decompression implementation\n        println(\"Decompressing ZIP\")\n        return data // Simplified\n    }\n    \n    override val fileExtension = \".zip\"\n}\n\nclass GzipCompression : CompressionStrategy {\n    override fun compress(data: ByteArray): ByteArray {\n        // GZIP compression implementation\n        println(\"Compressing with GZIP\")\n        return data // Simplified\n    }\n    \n    override fun decompress(data: ByteArray): ByteArray {\n        // GZIP decompression implementation\n        println(\"Decompressing GZIP\")\n        return data // Simplified\n    }\n    \n    override val fileExtension = \".gz\"\n}\n\nclass FileCompressor(private var strategy: CompressionStrategy) {\n    fun setStrategy(strategy: CompressionStrategy) {\n        this.strategy = strategy\n    }\n    \n    fun compressFile(filename: String, data: ByteArray): String {\n        val compressed = strategy.compress(data)\n        val outputFilename = filename + strategy.fileExtension\n        // Save compressed data to file\n        println(\"Saved compressed file: $outputFilename\")\n        return outputFilename\n    }\n    \n    fun decompressFile(filename: String, data: ByteArray): ByteArray {\n        return strategy.decompress(data)\n    }\n}\n\n// Strategy with sealed classes\nsealed class SortingStrategy<T : Comparable<T>> {\n    abstract fun sort(list: List<T>): List<T>\n    \n    object BubbleSort : SortingStrategy<Int>() {\n        override fun sort(list: List<Int>): List<Int> {\n            val result = list.toMutableList()\n            for (i in 0 until result.size) {\n                for (j in 0 until result.size - i - 1) {\n                    if (result[j] > result[j + 1]) {\n                        val temp = result[j]\n                        result[j] = result[j + 1]\n                        result[j + 1] = temp\n                    }\n                }\n            }\n            return result\n        }\n    }\n    \n    object QuickSort : SortingStrategy<Int>() {\n        override fun sort(list: List<Int>): List<Int> {\n            if (list.size <= 1) return list\n            \n            val pivot = list[list.size / 2]\n            val less = list.filter { it < pivot }\n            val equal = list.filter { it == pivot }\n            val greater = list.filter { it > pivot }\n            \n            return sort(less) + equal + sort(greater)\n        }\n    }\n    \n    data class CustomSort<T : Comparable<T>>(\n        val comparator: Comparator<T>\n    ) : SortingStrategy<T>() {\n        override fun sort(list: List<T>): List<T> {\n            return list.sortedWith(comparator)\n        }\n    }\n}"
    }
  }
}