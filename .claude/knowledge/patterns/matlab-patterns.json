{
  "language": "matlab",
  "patterns": {
    "handle_class": {
      "description": "Classes that inherit from handle for reference semantics and in-place modification.",
      "whenToUse": "For objects that need to be modified in place, like GUI components or shared resources.",
      "example": "classdef DataLogger < handle\n    % Handle class for logging data with shared state\n    \n    properties (Access = private)\n        data = [];\n        timestamps = [];\n        maxEntries = 1000;\n    end\n    \n    properties (SetObservable)\n        currentValue = 0;\n    end\n    \n    events\n        DataLogged\n        BufferFull\n    end\n    \n    methods\n        function obj = DataLogger(maxEntries)\n            if nargin > 0\n                obj.maxEntries = maxEntries;\n            end\n        end\n        \n        function log(obj, value)\n            % Add new data point\n            obj.currentValue = value;\n            obj.data(end+1) = value;\n            obj.timestamps(end+1) = now;\n            \n            % Notify listeners\n            notify(obj, 'DataLogged');\n            \n            % Check buffer size\n            if length(obj.data) > obj.maxEntries\n                obj.data(1) = [];\n                obj.timestamps(1) = [];\n                notify(obj, 'BufferFull');\n            end\n        end\n        \n        function stats = getStatistics(obj)\n            stats.mean = mean(obj.data);\n            stats.std = std(obj.data);\n            stats.min = min(obj.data);\n            stats.max = max(obj.data);\n        end\n        \n        function h = plot(obj)\n            h = figure;\n            plot(obj.timestamps, obj.data);\n            datetick('x', 'HH:MM:SS');\n            xlabel('Time');\n            ylabel('Value');\n            title('Logged Data');\n        end\n    end\nend\n\n% Usage\nlogger = DataLogger(100);\naddlistener(logger, 'DataLogged', @(src, evt) disp('New data logged'));\n\nfor i = 1:10\n    logger.log(rand() * 100);\n    pause(0.1);\nend\n\nstats = logger.getStatistics();"
    },
    "value_class": {
      "description": "Classes with value semantics where assignment creates independent copies.",
      "whenToUse": "For immutable data structures and mathematical objects.",
      "example": "classdef Point\n    % Value class for 2D/3D points\n    \n    properties (SetAccess = immutable)\n        x\n        y\n        z\n    end\n    \n    methods\n        function obj = Point(x, y, z)\n            % Constructor with validation\n            arguments\n                x (1,1) double {mustBeFinite}\n                y (1,1) double {mustBeFinite}\n                z (1,1) double {mustBeFinite} = 0\n            end\n            \n            obj.x = x;\n            obj.y = y;\n            obj.z = z;\n        end\n        \n        function d = distance(obj, other)\n            arguments\n                obj\n                other (1,1) Point\n            end\n            \n            d = sqrt((obj.x - other.x)^2 + ...\n                     (obj.y - other.y)^2 + ...\n                     (obj.z - other.z)^2);\n        end\n        \n        function newPoint = plus(obj, other)\n            % Overload + operator\n            if isa(other, 'Point')\n                newPoint = Point(obj.x + other.x, ...\n                                 obj.y + other.y, ...\n                                 obj.z + other.z);\n            else\n                error('Can only add Point objects');\n            end\n        end\n        \n        function newPoint = times(obj, scalar)\n            % Overload * operator\n            arguments\n                obj\n                scalar (1,1) double\n            end\n            \n            newPoint = Point(obj.x * scalar, ...\n                             obj.y * scalar, ...\n                             obj.z * scalar);\n        end\n        \n        function disp(obj)\n            % Custom display\n            fprintf('Point(%.2f, %.2f, %.2f)\\n', obj.x, obj.y, obj.z);\n        end\n    end\n    \n    methods (Static)\n        function p = origin()\n            p = Point(0, 0, 0);\n        end\n        \n        function p = random(bounds)\n            arguments\n                bounds (1,2) double = [-1, 1]\n            end\n            \n            range = bounds(2) - bounds(1);\n            p = Point(bounds(1) + rand() * range, ...\n                      bounds(1) + rand() * range, ...\n                      bounds(1) + rand() * range);\n        end\n    end\nend"
    },
    "function_argument_validation": {
      "description": "Use arguments block for robust input validation and default values.",
      "whenToUse": "For all functions that need input validation and clear interfaces.",
      "example": "function results = processData(data, options)\n    % Process data with comprehensive validation\n    arguments\n        data (:,:) double {mustBeFinite, mustBeNonempty}\n        options.Method {mustBeMember(options.Method, ...\n            {'mean', 'median', 'mode'})} = 'mean'\n        options.WindowSize (1,1) double {mustBePositive, ...\n            mustBeInteger} = 10\n        options.Normalize (1,1) logical = true\n        options.OutputFormat {mustBeMember(options.OutputFormat, ...\n            {'struct', 'table', 'array'})} = 'struct'\n        options.Verbose (1,1) logical = false\n    end\n    \n    if options.Verbose\n        fprintf('Processing %d x %d data matrix...\\n', size(data));\n        fprintf('Method: %s, Window: %d\\n', ...\n            options.Method, options.WindowSize);\n    end\n    \n    % Normalize if requested\n    if options.Normalize\n        data = (data - mean(data, 'all')) / std(data, 0, 'all');\n    end\n    \n    % Process based on method\n    switch options.Method\n        case 'mean'\n            processed = movmean(data, options.WindowSize);\n        case 'median'\n            processed = movmedian(data, options.WindowSize);\n        case 'mode'\n            % Custom implementation for mode\n            processed = arrayfun(@(i) mode(data(max(1,i-options.WindowSize/2):...\n                min(end,i+options.WindowSize/2))), 1:numel(data));\n            processed = reshape(processed, size(data));\n    end\n    \n    % Format output\n    switch options.OutputFormat\n        case 'struct'\n            results.data = processed;\n            results.method = options.Method;\n            results.timestamp = datetime('now');\n            results.inputSize = size(data);\n        case 'table'\n            results = array2table(processed);\n            results.Properties.Description = sprintf('Processed with %s', ...\n                options.Method);\n        case 'array'\n            results = processed;\n    end\nend\n\n% Usage examples\ndata = randn(100, 10);\n\n% Default options\nresult1 = processData(data);\n\n% Custom options\nresult2 = processData(data, 'Method', 'median', ...\n                      'WindowSize', 5, ...\n                      'OutputFormat', 'table', ...\n                      'Verbose', true);"
    },
    "singleton": {
      "description": "Ensure only one instance of a class exists throughout the application.",
      "whenToUse": "For application configuration, resource managers, or shared state.",
      "example": "classdef (Sealed) ConfigManager < handle\n    % Singleton pattern for application configuration\n    \n    properties (Access = private)\n        settings = struct();\n        configFile = 'app_config.mat';\n    end\n    \n    methods (Access = private)\n        function obj = ConfigManager()\n            % Private constructor\n            obj.loadConfig();\n        end\n    end\n    \n    methods (Static)\n        function obj = getInstance()\n            persistent instance\n            if isempty(instance) || ~isvalid(instance)\n                instance = ConfigManager();\n            end\n            obj = instance;\n        end\n    end\n    \n    methods\n        function value = get(obj, key, defaultValue)\n            arguments\n                obj\n                key char\n                defaultValue = []\n            end\n            \n            if isfield(obj.settings, key)\n                value = obj.settings.(key);\n            else\n                value = defaultValue;\n            end\n        end\n        \n        function set(obj, key, value)\n            obj.settings.(key) = value;\n            obj.saveConfig();\n        end\n        \n        function reset(obj)\n            obj.settings = struct();\n            obj.saveConfig();\n        end\n        \n        function loadConfig(obj)\n            if exist(obj.configFile, 'file')\n                loaded = load(obj.configFile);\n                if isfield(loaded, 'settings')\n                    obj.settings = loaded.settings;\n                end\n            end\n        end\n        \n        function saveConfig(obj)\n            settings = obj.settings;\n            save(obj.configFile, 'settings');\n        end\n    end\nend\n\n% Usage\nconfig = ConfigManager.getInstance();\nconfig.set('database.host', 'localhost');\nconfig.set('database.port', 5432);\nconfig.set('app.debug', true);\n\n% Access from anywhere\nconfig2 = ConfigManager.getInstance();\ndbHost = config2.get('database.host', 'default_host');"
    },
    "observer": {
      "description": "Implement event-driven programming with listeners and notifications.",
      "whenToUse": "For decoupled communication between objects, especially in GUIs.",
      "example": "classdef DataModel < handle\n    % Observable data model\n    \n    properties (SetObservable)\n        data = [];\n        selectedIndex = 1;\n    end\n    \n    properties (Access = private)\n        listeners = {};\n    end\n    \n    events\n        DataChanged\n        SelectionChanged\n        DataCleared\n    end\n    \n    methods\n        function obj = DataModel(initialData)\n            if nargin > 0\n                obj.data = initialData;\n            end\n        end\n        \n        function addData(obj, newData)\n            obj.data = [obj.data; newData];\n            eventData = DataChangedEventData('add', newData, size(obj.data, 1));\n            notify(obj, 'DataChanged', eventData);\n        end\n        \n        function updateData(obj, index, newValue)\n            oldValue = obj.data(index, :);\n            obj.data(index, :) = newValue;\n            eventData = DataChangedEventData('update', newValue, index, oldValue);\n            notify(obj, 'DataChanged', eventData);\n        end\n        \n        function clearData(obj)\n            obj.data = [];\n            obj.selectedIndex = 1;\n            notify(obj, 'DataCleared');\n        end\n        \n        function select(obj, index)\n            if index > 0 && index <= size(obj.data, 1)\n                oldIndex = obj.selectedIndex;\n                obj.selectedIndex = index;\n                notify(obj, 'SelectionChanged', ...\n                    SelectionEventData(index, oldIndex));\n            end\n        end\n    end\nend\n\n% Custom event data classes\nclassdef DataChangedEventData < event.EventData\n    properties\n        Action\n        Data\n        Index\n        OldData\n    end\n    \n    methods\n        function obj = DataChangedEventData(action, data, index, oldData)\n            obj.Action = action;\n            obj.Data = data;\n            obj.Index = index;\n            if nargin > 3\n                obj.OldData = oldData;\n            end\n        end\n    end\nend\n\n% View class that observes the model\nclassdef DataView < handle\n    properties (Access = private)\n        model\n        figure\n        table\n        listeners\n    end\n    \n    methods\n        function obj = DataView(dataModel)\n            obj.model = dataModel;\n            obj.createUI();\n            obj.attachListeners();\n        end\n        \n        function createUI(obj)\n            obj.figure = figure('Name', 'Data Viewer');\n            obj.table = uitable(obj.figure, ...\n                'Data', obj.model.data, ...\n                'Position', [20 20 360 300]);\n        end\n        \n        function attachListeners(obj)\n            obj.listeners{1} = addlistener(obj.model, 'DataChanged', ...\n                @(src, evt) obj.onDataChanged(evt));\n            obj.listeners{2} = addlistener(obj.model, 'DataCleared', ...\n                @(src, evt) obj.onDataCleared());\n        end\n        \n        function onDataChanged(obj, eventData)\n            obj.table.Data = obj.model.data;\n            fprintf('%s: Data %s at index %d\\n', ...\n                datestr(now), eventData.Action, eventData.Index);\n        end\n        \n        function onDataCleared(obj)\n            obj.table.Data = [];\n            disp('Data cleared');\n        end\n    end\nend"
    },
    "template_method": {
      "description": "Define algorithm skeleton in base class with customizable steps in subclasses.",
      "whenToUse": "When multiple classes share the same algorithm structure but differ in implementation details.",
      "example": "classdef (Abstract) DataProcessor < handle\n    % Template method pattern for data processing pipeline\n    \n    properties (Access = protected)\n        rawData\n        processedData\n        results\n    end\n    \n    methods\n        function obj = DataProcessor()\n            % Constructor\n        end\n        \n        function results = process(obj, data)\n            % Template method defining the algorithm structure\n            fprintf('Starting %s processing...\\n', class(obj));\n            \n            % Step 1: Validate input\n            obj.validateInput(data);\n            \n            % Step 2: Preprocess\n            obj.rawData = data;\n            obj.preprocess();\n            \n            % Step 3: Core processing (abstract)\n            obj.processedData = obj.performProcessing();\n            \n            % Step 4: Postprocess\n            obj.postprocess();\n            \n            % Step 5: Generate results\n            obj.results = obj.generateResults();\n            \n            % Step 6: Cleanup\n            obj.cleanup();\n            \n            results = obj.results;\n            fprintf('Processing complete.\\n');\n        end\n    end\n    \n    methods (Access = protected)\n        function validateInput(obj, data)\n            % Default validation - can be overridden\n            if isempty(data)\n                error('Input data cannot be empty');\n            end\n        end\n        \n        function preprocess(obj)\n            % Default preprocessing - can be overridden\n            fprintf('Preprocessing data...\\n');\n        end\n        \n        function postprocess(obj)\n            % Default postprocessing - can be overridden\n            fprintf('Postprocessing results...\\n');\n        end\n        \n        function cleanup(obj)\n            % Default cleanup - can be overridden\n            obj.rawData = [];\n            obj.processedData = [];\n        end\n    end\n    \n    methods (Abstract, Access = protected)\n        % Must be implemented by subclasses\n        processedData = performProcessing(obj)\n        results = generateResults(obj)\n    end\nend\n\n% Concrete implementation\nclassdef StatisticalProcessor < DataProcessor\n    properties (Access = private)\n        statistics\n    end\n    \n    methods (Access = protected)\n        function processedData = performProcessing(obj)\n            % Implement statistical processing\n            data = obj.rawData;\n            \n            % Remove outliers\n            q1 = quantile(data, 0.25);\n            q3 = quantile(data, 0.75);\n            iqr = q3 - q1;\n            lowerBound = q1 - 1.5 * iqr;\n            upperBound = q3 + 1.5 * iqr;\n            \n            processedData = data(data >= lowerBound & data <= upperBound);\n            \n            % Calculate statistics\n            obj.statistics.mean = mean(processedData);\n            obj.statistics.std = std(processedData);\n            obj.statistics.median = median(processedData);\n        end\n        \n        function results = generateResults(obj)\n            results.processedData = obj.processedData;\n            results.statistics = obj.statistics;\n            results.outlierCount = length(obj.rawData) - length(obj.processedData);\n        end\n        \n        function preprocess(obj)\n            % Override to add specific preprocessing\n            preprocess@DataProcessor(obj);\n            fprintf('Checking for NaN values...\\n');\n            obj.rawData = obj.rawData(~isnan(obj.rawData));\n        end\n    end\nend"
    },
    "factory": {
      "description": "Create objects without specifying their exact classes.",
      "whenToUse": "When object creation logic is complex or when you need to decouple object creation from usage.",
      "example": "classdef PlotFactory\n    % Factory for creating different types of plots\n    \n    methods (Static)\n        function plotter = createPlotter(plotType, varargin)\n            % Factory method\n            switch lower(plotType)\n                case 'line'\n                    plotter = LinePlotter(varargin{:});\n                case 'scatter'\n                    plotter = ScatterPlotter(varargin{:});\n                case 'histogram'\n                    plotter = HistogramPlotter(varargin{:});\n                case 'heatmap'\n                    plotter = HeatmapPlotter(varargin{:});\n                case 'surface'\n                    plotter = SurfacePlotter(varargin{:});\n                otherwise\n                    error('Unknown plot type: %s', plotType);\n            end\n        end\n        \n        function plotter = createFromData(data)\n            % Intelligent factory that chooses plot type based on data\n            [rows, cols] = size(data);\n            \n            if rows == 1 || cols == 1\n                % Vector data - use line plot\n                plotter = LinePlotter('LineWidth', 2);\n            elseif rows == 2 && cols > 2\n                % 2D points - use scatter\n                plotter = ScatterPlotter('MarkerSize', 8);\n            elseif rows > 10 && cols > 10\n                % Matrix - use heatmap\n                plotter = HeatmapPlotter('Colormap', 'jet');\n            else\n                % Default to line plot\n                plotter = LinePlotter();\n            end\n        end\n    end\nend\n\n% Base plotter class\nclassdef (Abstract) BasePlotter < handle\n    properties (Access = protected)\n        figureHandle\n        axesHandle\n        options\n    end\n    \n    methods\n        function obj = BasePlotter(varargin)\n            obj.options = obj.parseOptions(varargin{:});\n        end\n        \n        function fig = plot(obj, data, varargin)\n            obj.figureHandle = figure();\n            obj.axesHandle = axes(obj.figureHandle);\n            \n            % Call specific plotting method\n            obj.createPlot(data, varargin{:});\n            \n            % Apply common formatting\n            obj.applyFormatting();\n            \n            fig = obj.figureHandle;\n        end\n    end\n    \n    methods (Access = protected)\n        function opts = parseOptions(obj, varargin)\n            % Parse options common to all plotters\n            p = inputParser;\n            p.addParameter('Title', '', @ischar);\n            p.addParameter('XLabel', '', @ischar);\n            p.addParameter('YLabel', '', @ischar);\n            p.addParameter('Grid', true, @islogical);\n            p.parse(varargin{:});\n            opts = p.Results;\n        end\n        \n        function applyFormatting(obj)\n            title(obj.axesHandle, obj.options.Title);\n            xlabel(obj.axesHandle, obj.options.XLabel);\n            ylabel(obj.axesHandle, obj.options.YLabel);\n            if obj.options.Grid\n                grid(obj.axesHandle, 'on');\n            end\n        end\n    end\n    \n    methods (Abstract, Access = protected)\n        createPlot(obj, data, varargin)\n    end\nend\n\n% Concrete plotter implementation\nclassdef LinePlotter < BasePlotter\n    methods\n        function obj = LinePlotter(varargin)\n            obj@BasePlotter(varargin{:});\n        end\n    end\n    \n    methods (Access = protected)\n        function opts = parseOptions(obj, varargin)\n            opts = parseOptions@BasePlotter(obj, varargin{:});\n            \n            % Add line-specific options\n            p = inputParser;\n            p.KeepUnmatched = true;\n            p.addParameter('LineWidth', 1, @isnumeric);\n            p.addParameter('LineStyle', '-', @ischar);\n            p.addParameter('Color', 'b', @(x) true);\n            p.parse(varargin{:});\n            \n            opts = [opts, p.Results];\n        end\n        \n        function createPlot(obj, data, varargin)\n            if isvector(data)\n                h = plot(obj.axesHandle, data);\n            else\n                h = plot(obj.axesHandle, data(:,1), data(:,2));\n            end\n            \n            % Apply line-specific formatting\n            if isfield(obj.options, 'LineWidth')\n                h.LineWidth = obj.options.LineWidth;\n            end\n            if isfield(obj.options, 'Color')\n                h.Color = obj.options.Color;\n            end\n        end\n    end\nend\n\n% Usage\ndata = randn(100, 1);\nplotter = PlotFactory.createPlotter('line', ...\n    'Title', 'Random Data', ...\n    'LineWidth', 2);\nplotter.plot(data);\n\n% Automatic selection\nmatrixData = randn(50, 50);\nautoPlotter = PlotFactory.createFromData(matrixData);\nautoPlotter.plot(matrixData);"
    },
    "builder": {
      "description": "Construct complex objects step by step with fluent interface.",
      "whenToUse": "For creating objects with many optional parameters or complex initialization.",
      "example": "classdef FigureBuilder < handle\n    % Builder pattern for creating complex figures\n    \n    properties (Access = private)\n        figureHandle\n        currentAxes\n        subplotGrid = [1, 1]\n        currentSubplot = 1\n    end\n    \n    methods\n        function obj = FigureBuilder()\n            obj.figureHandle = figure();\n            obj.currentAxes = axes(obj.figureHandle);\n        end\n        \n        function obj = setSize(obj, width, height)\n            obj.figureHandle.Position(3:4) = [width, height];\n        end\n        \n        function obj = setTitle(obj, titleText)\n            obj.figureHandle.Name = titleText;\n        end\n        \n        function obj = setColormap(obj, cmapName)\n            colormap(obj.figureHandle, cmapName);\n        end\n        \n        function obj = addSubplots(obj, rows, cols)\n            obj.subplotGrid = [rows, cols];\n            obj.currentSubplot = 1;\n        end\n        \n        function obj = nextSubplot(obj)\n            if obj.currentSubplot <= prod(obj.subplotGrid)\n                obj.currentAxes = subplot(obj.subplotGrid(1), ...\n                                          obj.subplotGrid(2), ...\n                                          obj.currentSubplot, ...\n                                          'Parent', obj.figureHandle);\n                obj.currentSubplot = obj.currentSubplot + 1;\n            else\n                warning('All subplots have been used');\n            end\n        end\n        \n        function obj = plot(obj, x, y, varargin)\n            plot(obj.currentAxes, x, y, varargin{:});\n        end\n        \n        function obj = scatter(obj, x, y, varargin)\n            scatter(obj.currentAxes, x, y, varargin{:});\n        end\n        \n        function obj = histogram(obj, data, varargin)\n            histogram(obj.currentAxes, data, varargin{:});\n        end\n        \n        function obj = setAxisLabels(obj, xLabel, yLabel)\n            xlabel(obj.currentAxes, xLabel);\n            ylabel(obj.currentAxes, yLabel);\n        end\n        \n        function obj = setAxisLimits(obj, xlims, ylims)\n            if ~isempty(xlims)\n                xlim(obj.currentAxes, xlims);\n            end\n            if ~isempty(ylims)\n                ylim(obj.currentAxes, ylims);\n            end\n        end\n        \n        function obj = addLegend(obj, labels, varargin)\n            legend(obj.currentAxes, labels, varargin{:});\n        end\n        \n        function obj = enableGrid(obj, state)\n            grid(obj.currentAxes, state);\n        end\n        \n        function fig = build(obj)\n            % Finalize and return the figure\n            fig = obj.figureHandle;\n        end\n    end\n    \n    methods (Static)\n        function demo()\n            % Demonstrate the builder pattern\n            x = linspace(0, 2*pi, 100);\n            \n            fig = FigureBuilder() ...\n                .setSize(800, 600) ...\n                .setTitle('Multi-Plot Figure') ...\n                .addSubplots(2, 2) ...\n                .plot(x, sin(x), 'LineWidth', 2) ...\n                .setAxisLabels('X', 'sin(X)') ...\n                .enableGrid('on') ...\n                .nextSubplot() ...\n                .plot(x, cos(x), 'r--', 'LineWidth', 2) ...\n                .setAxisLabels('X', 'cos(X)') ...\n                .enableGrid('on') ...\n                .nextSubplot() ...\n                .scatter(rand(50,1)*2*pi, rand(50,1)*2-1) ...\n                .setAxisLabels('X', 'Random') ...\n                .nextSubplot() ...\n                .histogram(randn(1000,1)) ...\n                .setAxisLabels('Value', 'Count') ...\n                .build();\n        end\n    end\nend\n\n% Alternative builder for report generation\nclassdef ReportBuilder < handle\n    properties (Access = private)\n        sections = {}\n        metadata = struct()\n        outputFormat = 'html'\n    end\n    \n    methods\n        function obj = ReportBuilder()\n        end\n        \n        function obj = setTitle(obj, title)\n            obj.metadata.title = title;\n        end\n        \n        function obj = setAuthor(obj, author)\n            obj.metadata.author = author;\n        end\n        \n        function obj = setFormat(obj, format)\n            obj.outputFormat = format;\n        end\n        \n        function obj = addSection(obj, title, content)\n            section.title = title;\n            section.content = content;\n            section.type = 'text';\n            obj.sections{end+1} = section;\n        end\n        \n        function obj = addFigure(obj, figHandle, caption)\n            section.title = caption;\n            section.content = figHandle;\n            section.type = 'figure';\n            obj.sections{end+1} = section;\n        end\n        \n        function obj = addTable(obj, data, caption)\n            section.title = caption;\n            section.content = data;\n            section.type = 'table';\n            obj.sections{end+1} = section;\n        end\n        \n        function obj = addCode(obj, code, language)\n            section.title = sprintf('Code (%s)', language);\n            section.content = code;\n            section.type = 'code';\n            obj.sections{end+1} = section;\n        end\n        \n        function report = build(obj)\n            % Generate the report\n            report = obj.generateReport();\n        end\n    end\n    \n    methods (Access = private)\n        function report = generateReport(obj)\n            switch obj.outputFormat\n                case 'html'\n                    report = obj.generateHTML();\n                case 'pdf'\n                    report = obj.generatePDF();\n                case 'markdown'\n                    report = obj.generateMarkdown();\n                otherwise\n                    error('Unknown format: %s', obj.outputFormat);\n            end\n        end\n        \n        function html = generateHTML(obj)\n            % Simple HTML generation\n            html = sprintf('<html><head><title>%s</title></head><body>\\n', ...\n                obj.metadata.title);\n            html = [html sprintf('<h1>%s</h1>\\n', obj.metadata.title)];\n            \n            for i = 1:length(obj.sections)\n                section = obj.sections{i};\n                switch section.type\n                    case 'text'\n                        html = [html sprintf('<h2>%s</h2>\\n<p>%s</p>\\n', ...\n                            section.title, section.content)];\n                    case 'code'\n                        html = [html sprintf('<h3>%s</h3>\\n<pre>%s</pre>\\n', ...\n                            section.title, section.content)];\n                end\n            end\n            \n            html = [html '</body></html>'];\n        end\n    end\nend"
    }
  }
}