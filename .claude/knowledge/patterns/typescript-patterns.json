{
  "language": "typescript",
  "patterns": {
    "module": {
      "description": "Encapsulates code into self-contained units with public/private members.",
      "whenToUse": "When organizing code into reusable, maintainable units with clear boundaries.",
      "example": "// Module pattern using namespace\nnamespace UserModule {\n  let users: User[] = [];\n  \n  export interface User {\n    id: number;\n    name: string;\n    email: string;\n  }\n  \n  export function addUser(user: User): void {\n    users.push(user);\n  }\n  \n  export function getUser(id: number): User | undefined {\n    return users.find(u => u.id === id);\n  }\n  \n  function validateEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n}\n\n// Modern ES module pattern\nexport interface Config {\n  apiUrl: string;\n  timeout: number;\n}\n\nconst defaultConfig: Config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000\n};\n\nexport class ApiClient {\n  constructor(private config: Config = defaultConfig) {}\n  \n  async get<T>(endpoint: string): Promise<T> {\n    const response = await fetch(`${this.config.apiUrl}${endpoint}`);\n    return response.json();\n  }\n}"
    },
    "singleton": {
      "description": "Ensures a class has only one instance and provides global access to it.",
      "whenToUse": "When you need exactly one instance (configuration, logging, global state management).",
      "example": "class ConfigurationManager {\n  private static instance: ConfigurationManager;\n  private config: Map<string, any> = new Map();\n  \n  private constructor() {\n    // Private constructor prevents external instantiation\n  }\n  \n  static getInstance(): ConfigurationManager {\n    if (!ConfigurationManager.instance) {\n      ConfigurationManager.instance = new ConfigurationManager();\n    }\n    return ConfigurationManager.instance;\n  }\n  \n  set(key: string, value: any): void {\n    this.config.set(key, value);\n  }\n  \n  get<T>(key: string): T | undefined {\n    return this.config.get(key);\n  }\n}\n\n// Alternative: Using module pattern for singleton\nconst Logger = (() => {\n  let instance: ILogger | null = null;\n  \n  interface ILogger {\n    log(message: string): void;\n    error(message: string): void;\n  }\n  \n  class LoggerImpl implements ILogger {\n    log(message: string): void {\n      console.log(`[LOG] ${new Date().toISOString()}: ${message}`);\n    }\n    \n    error(message: string): void {\n      console.error(`[ERROR] ${new Date().toISOString()}: ${message}`);\n    }\n  }\n  \n  return {\n    getInstance(): ILogger {\n      if (!instance) {\n        instance = new LoggerImpl();\n      }\n      return instance;\n    }\n  };\n})();"
    },
    "factory": {
      "description": "Creates objects without specifying their exact classes, using a common interface.",
      "whenToUse": "When object creation logic is complex or when you need to decide object types at runtime.",
      "example": "interface Vehicle {\n  drive(): void;\n  getType(): string;\n}\n\nclass Car implements Vehicle {\n  drive(): void {\n    console.log('Driving a car');\n  }\n  \n  getType(): string {\n    return 'Car';\n  }\n}\n\nclass Motorcycle implements Vehicle {\n  drive(): void {\n    console.log('Riding a motorcycle');\n  }\n  \n  getType(): string {\n    return 'Motorcycle';\n  }\n}\n\nclass Truck implements Vehicle {\n  drive(): void {\n    console.log('Driving a truck');\n  }\n  \n  getType(): string {\n    return 'Truck';\n  }\n}\n\n// Factory with type safety\ntype VehicleType = 'car' | 'motorcycle' | 'truck';\n\nclass VehicleFactory {\n  static createVehicle(type: VehicleType): Vehicle {\n    switch (type) {\n      case 'car':\n        return new Car();\n      case 'motorcycle':\n        return new Motorcycle();\n      case 'truck':\n        return new Truck();\n      default:\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unknown vehicle type: ${type}`);\n    }\n  }\n}\n\n// Abstract factory pattern\ninterface UIFactory {\n  createButton(): Button;\n  createInput(): Input;\n}\n\ninterface Button {\n  render(): void;\n}\n\ninterface Input {\n  render(): void;\n}\n\nclass MaterialUIFactory implements UIFactory {\n  createButton(): Button {\n    return new MaterialButton();\n  }\n  \n  createInput(): Input {\n    return new MaterialInput();\n  }\n}"
    },
    "observer": {
      "description": "Defines a one-to-many relationship between objects for event notification.",
      "whenToUse": "When changes to one object require updating multiple dependent objects.",
      "example": "interface Observer<T> {\n  update(data: T): void;\n}\n\ninterface Subject<T> {\n  attach(observer: Observer<T>): void;\n  detach(observer: Observer<T>): void;\n  notify(data: T): void;\n}\n\nclass EventManager<T> implements Subject<T> {\n  private observers: Observer<T>[] = [];\n  \n  attach(observer: Observer<T>): void {\n    const isExist = this.observers.includes(observer);\n    if (isExist) {\n      return console.log('Observer has been attached already');\n    }\n    this.observers.push(observer);\n  }\n  \n  detach(observer: Observer<T>): void {\n    const observerIndex = this.observers.indexOf(observer);\n    if (observerIndex === -1) {\n      return console.log('Observer not found');\n    }\n    this.observers.splice(observerIndex, 1);\n  }\n  \n  notify(data: T): void {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\n// Type-safe event emitter\ntype EventMap = {\n  'user:login': { userId: string; timestamp: Date };\n  'user:logout': { userId: string };\n  'data:update': { id: string; changes: any };\n};\n\nclass TypedEventEmitter {\n  private events: Map<keyof EventMap, Function[]> = new Map();\n  \n  on<K extends keyof EventMap>(\n    event: K,\n    listener: (data: EventMap[K]) => void\n  ): void {\n    if (!this.events.has(event)) {\n      this.events.set(event, []);\n    }\n    this.events.get(event)!.push(listener);\n  }\n  \n  emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {\n    const listeners = this.events.get(event);\n    if (listeners) {\n      listeners.forEach(listener => listener(data));\n    }\n  }\n}"
    },
    "decorator": {
      "description": "Adds new functionality to objects dynamically without altering their structure.",
      "whenToUse": "When you want to add behavior to objects at runtime or create composable behaviors.",
      "example": "// Method decorator\nfunction log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = function(...args: any[]) {\n    console.log(`Calling ${propertyKey} with args:`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`${propertyKey} returned:`, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\n// Class decorator\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n// Property decorator with metadata\nfunction validate(target: any, propertyKey: string) {\n  let value = target[propertyKey];\n  \n  const getter = () => value;\n  const setter = (newVal: any) => {\n    if (newVal < 0) {\n      throw new Error(`${propertyKey} cannot be negative`);\n    }\n    value = newVal;\n  };\n  \n  Object.defineProperty(target, propertyKey, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true\n  });\n}\n\n@sealed\nclass BankAccount {\n  @validate\n  balance: number = 0;\n  \n  @log\n  withdraw(amount: number): void {\n    if (amount > this.balance) {\n      throw new Error('Insufficient funds');\n    }\n    this.balance -= amount;\n  }\n}\n\n// Composition-based decorator pattern\ninterface Coffee {\n  getCost(): number;\n  getDescription(): string;\n}\n\nclass SimpleCoffee implements Coffee {\n  getCost(): number {\n    return 10;\n  }\n  \n  getDescription(): string {\n    return 'Simple coffee';\n  }\n}\n\nclass CoffeeDecorator implements Coffee {\n  constructor(protected coffee: Coffee) {}\n  \n  getCost(): number {\n    return this.coffee.getCost();\n  }\n  \n  getDescription(): string {\n    return this.coffee.getDescription();\n  }\n}\n\nclass MilkDecorator extends CoffeeDecorator {\n  getCost(): number {\n    return super.getCost() + 2;\n  }\n  \n  getDescription(): string {\n    return super.getDescription() + ', milk';\n  }\n}"
    },
    "strategy": {
      "description": "Defines a family of algorithms and makes them interchangeable at runtime.",
      "whenToUse": "When you have multiple ways to perform a task and want to switch between them dynamically.",
      "example": "interface PaymentStrategy {\n  pay(amount: number): Promise<boolean>;\n  validatePaymentDetails(): boolean;\n}\n\nclass CreditCardPayment implements PaymentStrategy {\n  constructor(\n    private cardNumber: string,\n    private cvv: string,\n    private expiryDate: string\n  ) {}\n  \n  async pay(amount: number): Promise<boolean> {\n    if (!this.validatePaymentDetails()) {\n      return false;\n    }\n    console.log(`Paid ${amount} using Credit Card`);\n    // Actual payment logic here\n    return true;\n  }\n  \n  validatePaymentDetails(): boolean {\n    return this.cardNumber.length === 16 && this.cvv.length === 3;\n  }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n  constructor(private email: string, private password: string) {}\n  \n  async pay(amount: number): Promise<boolean> {\n    if (!this.validatePaymentDetails()) {\n      return false;\n    }\n    console.log(`Paid ${amount} using PayPal`);\n    return true;\n  }\n  \n  validatePaymentDetails(): boolean {\n    return this.email.includes('@') && this.password.length > 0;\n  }\n}\n\nclass PaymentProcessor {\n  private strategy: PaymentStrategy;\n  \n  constructor(strategy: PaymentStrategy) {\n    this.strategy = strategy;\n  }\n  \n  setStrategy(strategy: PaymentStrategy): void {\n    this.strategy = strategy;\n  }\n  \n  async processPayment(amount: number): Promise<boolean> {\n    return await this.strategy.pay(amount);\n  }\n}\n\n// Generic strategy pattern\ninterface SortStrategy<T> {\n  sort(data: T[]): T[];\n}\n\nclass QuickSort<T> implements SortStrategy<T> {\n  sort(data: T[]): T[] {\n    // Quick sort implementation\n    return [...data].sort();\n  }\n}\n\nclass MergeSort<T> implements SortStrategy<T> {\n  sort(data: T[]): T[] {\n    // Merge sort implementation\n    return [...data].sort();\n  }\n}"
    },
    "builder": {
      "description": "Constructs complex objects step by step with a fluent interface.",
      "whenToUse": "When creating objects with many optional parameters or complex initialization.",
      "example": "class User {\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly email: string,\n    public readonly age?: number,\n    public readonly address?: Address,\n    public readonly preferences?: UserPreferences\n  ) {}\n}\n\ninterface Address {\n  street: string;\n  city: string;\n  country: string;\n  zipCode?: string;\n}\n\ninterface UserPreferences {\n  newsletter: boolean;\n  notifications: boolean;\n  theme: 'light' | 'dark';\n}\n\nclass UserBuilder {\n  private id: string;\n  private name: string;\n  private email: string;\n  private age?: number;\n  private address?: Address;\n  private preferences?: UserPreferences;\n  \n  constructor(id: string, name: string, email: string) {\n    this.id = id;\n    this.name = name;\n    this.email = email;\n  }\n  \n  withAge(age: number): UserBuilder {\n    this.age = age;\n    return this;\n  }\n  \n  withAddress(address: Address): UserBuilder {\n    this.address = address;\n    return this;\n  }\n  \n  withPreferences(preferences: UserPreferences): UserBuilder {\n    this.preferences = preferences;\n    return this;\n  }\n  \n  build(): User {\n    return new User(\n      this.id,\n      this.name,\n      this.email,\n      this.age,\n      this.address,\n      this.preferences\n    );\n  }\n}\n\n// Generic builder with type safety\ntype Builder<T> = {\n  [K in keyof T]-?: ((value: T[K]) => Builder<T>) & (() => T[K]);\n} & {\n  build(): T;\n};\n\nfunction createBuilder<T>(): Builder<T> {\n  const built: any = {};\n  \n  const builder = new Proxy(\n    {},\n    {\n      get(target, prop) {\n        if (prop === 'build') {\n          return () => built;\n        }\n        return (value?: any) => {\n          if (value !== undefined) {\n            built[prop] = value;\n            return builder;\n          }\n          return built[prop];\n        };\n      }\n    }\n  ) as Builder<T>;\n  \n  return builder;\n}"
    },
    "adapter": {
      "description": "Allows incompatible interfaces to work together by wrapping objects.",
      "whenToUse": "When you need to use an existing class with an incompatible interface.",
      "example": "// Legacy payment system\nclass LegacyPaymentSystem {\n  makePayment(amount: string, currency: string): void {\n    console.log(`Legacy payment: ${currency}${amount}`);\n  }\n}\n\n// Modern payment interface\ninterface PaymentProvider {\n  processPayment(amount: number, currency: Currency): Promise<PaymentResult>;\n}\n\ntype Currency = 'USD' | 'EUR' | 'GBP';\n\ninterface PaymentResult {\n  success: boolean;\n  transactionId: string;\n  timestamp: Date;\n}\n\n// Adapter\nclass LegacyPaymentAdapter implements PaymentProvider {\n  constructor(private legacySystem: LegacyPaymentSystem) {}\n  \n  async processPayment(amount: number, currency: Currency): Promise<PaymentResult> {\n    // Convert modern format to legacy format\n    const legacyAmount = amount.toFixed(2);\n    const legacyCurrency = this.convertCurrency(currency);\n    \n    try {\n      this.legacySystem.makePayment(legacyAmount, legacyCurrency);\n      \n      return {\n        success: true,\n        transactionId: this.generateTransactionId(),\n        timestamp: new Date()\n      };\n    } catch (error) {\n      return {\n        success: false,\n        transactionId: '',\n        timestamp: new Date()\n      };\n    }\n  }\n  \n  private convertCurrency(currency: Currency): string {\n    const currencyMap: Record<Currency, string> = {\n      'USD': '$',\n      'EUR': '€',\n      'GBP': '£'\n    };\n    return currencyMap[currency];\n  }\n  \n  private generateTransactionId(): string {\n    return `TXN${Date.now()}${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// Generic adapter for function signatures\ntype AsyncFunction<T, R> = (arg: T) => Promise<R>;\ntype SyncFunction<T, R> = (arg: T) => R;\n\nclass AsyncAdapter<T, R> {\n  constructor(private syncFn: SyncFunction<T, R>) {}\n  \n  async execute(arg: T): Promise<R> {\n    return Promise.resolve(this.syncFn(arg));\n  }\n}"
    }
  }
}