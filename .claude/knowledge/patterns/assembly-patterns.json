{
  "language": "assembly",
  "patterns": {
    "modular_structure": {
      "description": "Organize code into logical sections with clear segment definitions.",
      "whenToUse": "For maintainable assembly programs with clear separation of concerns.",
      "example": "; File: main.asm\n; Purpose: Main program entry point\n\nsection .data\n    ; Constants and initialized data\n    msg_hello    db 'Hello, World!', 0x0A, 0\n    msg_len      equ $ - msg_hello\n    buffer_size  equ 256\n\nsection .bss\n    ; Uninitialized data\n    input_buffer resb buffer_size\n    result       resd 1\n\nsection .text\n    ; External functions\n    extern print_string\n    extern read_input\n    \n    ; Export main entry point\n    global _start\n\n_start:\n    ; Initialize stack frame\n    push ebp\n    mov ebp, esp\n    \n    ; Call initialization routine\n    call init_program\n    \n    ; Main program logic\n    push msg_hello\n    call print_string\n    add esp, 4\n    \n    ; Clean up and exit\n    mov esp, ebp\n    pop ebp\n    \n    ; Exit syscall\n    mov eax, 1      ; sys_exit\n    xor ebx, ebx    ; exit code 0\n    int 0x80\n\n; Local functions\ninit_program:\n    push ebp\n    mov ebp, esp\n    ; Initialization code here\n    mov esp, ebp\n    pop ebp\n    ret"
    },
    "macro_abstraction": {
      "description": "Use macros for code reuse and abstraction of common patterns.",
      "whenToUse": "When you have repetitive code patterns or need to abstract platform-specific details.",
      "example": "; NASM macro examples\n\n; Simple macro for function prologue/epilogue\n%macro PROC_ENTER 0\n    push ebp\n    mov ebp, esp\n%endmacro\n\n%macro PROC_LEAVE 0\n    mov esp, ebp\n    pop ebp\n    ret\n%endmacro\n\n; Macro with parameters for system calls\n%macro SYSCALL 2\n    mov eax, %1     ; System call number\n    mov ebx, %2     ; First argument\n    int 0x80        ; Linux system call\n%endmacro\n\n; Conditional compilation macro\n%macro DEBUG_PRINT 1\n    %ifdef DEBUG\n        push eax\n        push %1\n        call debug_output\n        add esp, 4\n        pop eax\n    %endif\n%endmacro\n\n; Stack allocation macro\n%macro STACK_ALLOC 1\n    sub esp, %1\n%endmacro\n\n%macro STACK_FREE 1\n    add esp, %1\n%endmacro\n\n; Usage example\nmy_function:\n    PROC_ENTER\n    STACK_ALLOC 16      ; Allocate 16 bytes\n    \n    DEBUG_PRINT msg_debug\n    \n    ; Function body\n    mov dword [esp], 42\n    mov dword [esp+4], 100\n    \n    STACK_FREE 16       ; Free allocated space\n    PROC_LEAVE"
    },
    "calling_convention": {
      "description": "Standardized function calling conventions for parameter passing and stack management.",
      "whenToUse": "For interoperability with other code and maintaining consistent interfaces.",
      "example": "; cdecl calling convention (C standard)\n; Parameters pushed right-to-left\n; Caller cleans up stack\n; Return value in EAX\n\n; Function: int add(int a, int b)\nadd_numbers:\n    push ebp\n    mov ebp, esp\n    \n    ; Parameters at [ebp+8] and [ebp+12]\n    mov eax, [ebp+8]    ; First parameter (a)\n    add eax, [ebp+12]   ; Second parameter (b)\n    \n    mov esp, ebp\n    pop ebp\n    ret\n\n; Calling the function\ncaller:\n    push 20         ; Second argument\n    push 10         ; First argument\n    call add_numbers\n    add esp, 8      ; Clean up stack (2 * 4 bytes)\n    ; Result is now in EAX\n\n; stdcall convention (Windows API)\n; Parameters pushed right-to-left\n; Callee cleans up stack\nMessageBoxA:\n    push ebp\n    mov ebp, esp\n    \n    ; Access parameters\n    mov eax, [ebp+8]    ; hWnd\n    mov ebx, [ebp+12]   ; lpText\n    mov ecx, [ebp+16]   ; lpCaption\n    mov edx, [ebp+20]   ; uType\n    \n    ; Function implementation\n    \n    mov esp, ebp\n    pop ebp\n    ret 16              ; Clean up 4 parameters\n\n; Register-based convention (fastcall)\n; First 2-3 params in registers\n; Remaining on stack\nfast_multiply:\n    ; ECX = first param, EDX = second param\n    mov eax, ecx\n    imul eax, edx\n    ret"
    },
    "loop_optimization": {
      "description": "Efficient loop constructs with proper alignment and optimization.",
      "whenToUse": "For performance-critical loops and array processing.",
      "example": "; Optimized array processing\nsection .text\n\n; Function: sum_array(int* array, int count)\n; Returns sum in EAX\nsum_array:\n    push ebp\n    mov ebp, esp\n    push esi\n    push ecx\n    \n    mov esi, [ebp+8]    ; Array pointer\n    mov ecx, [ebp+12]   ; Count\n    xor eax, eax        ; Clear sum\n    \n    ; Check for empty array\n    test ecx, ecx\n    jz .done\n    \n    ; Align loop for optimal performance\n    align 16\n.loop:\n    add eax, [esi]\n    add esi, 4\n    dec ecx\n    jnz .loop\n    \n.done:\n    pop ecx\n    pop esi\n    mov esp, ebp\n    pop ebp\n    ret\n\n; Unrolled loop for better performance\nsum_array_unrolled:\n    push ebp\n    mov ebp, esp\n    push esi\n    push ecx\n    push edx\n    \n    mov esi, [ebp+8]    ; Array pointer\n    mov ecx, [ebp+12]   ; Count\n    xor eax, eax        ; Clear sum\n    \n    ; Process 4 elements at a time\n    mov edx, ecx\n    shr ecx, 2          ; Divide by 4\n    jz .handle_remainder\n    \n    align 16\n.unrolled_loop:\n    add eax, [esi]\n    add eax, [esi+4]\n    add eax, [esi+8]\n    add eax, [esi+12]\n    add esi, 16\n    dec ecx\n    jnz .unrolled_loop\n    \n.handle_remainder:\n    and edx, 3          ; Remainder (count % 4)\n    jz .done\n    \n.remainder_loop:\n    add eax, [esi]\n    add esi, 4\n    dec edx\n    jnz .remainder_loop\n    \n.done:\n    pop edx\n    pop ecx\n    pop esi\n    mov esp, ebp\n    pop ebp\n    ret"
    },
    "error_handling": {
      "description": "Consistent error checking and reporting mechanisms.",
      "whenToUse": "For robust code that handles edge cases and system call failures.",
      "example": "; Error handling patterns\n\nsection .data\n    err_file_not_found  db 'Error: File not found', 0x0A, 0\n    err_out_of_memory   db 'Error: Out of memory', 0x0A, 0\n    err_invalid_param   db 'Error: Invalid parameter', 0x0A, 0\n\nsection .text\n\n; Function with error checking\n; Returns: 0 on success, negative error code on failure\nopen_file:\n    push ebp\n    mov ebp, esp\n    push ebx\n    \n    ; Get filename parameter\n    mov ebx, [ebp+8]\n    \n    ; Validate parameter\n    test ebx, ebx\n    jz .invalid_param\n    \n    ; Open file (Linux syscall)\n    mov eax, 5          ; sys_open\n    mov ecx, 0          ; O_RDONLY\n    mov edx, 0          ; mode (ignored for O_RDONLY)\n    int 0x80\n    \n    ; Check for error\n    test eax, eax\n    js .open_failed     ; Jump if sign flag set (negative)\n    \n    ; Success - file descriptor in EAX\n    jmp .done\n    \n.invalid_param:\n    mov eax, -1         ; Error code for invalid parameter\n    jmp .done\n    \n.open_failed:\n    ; EAX already contains negative error code\n    \n.done:\n    pop ebx\n    mov esp, ebp\n    pop ebp\n    ret\n\n; Centralized error handler\nhandle_error:\n    push ebp\n    mov ebp, esp\n    push eax\n    \n    mov eax, [ebp+8]    ; Error code\n    \n    cmp eax, -1\n    je .print_invalid_param\n    cmp eax, -2\n    je .print_file_not_found\n    cmp eax, -12\n    je .print_out_of_memory\n    \n    ; Unknown error\n    jmp .done\n    \n.print_invalid_param:\n    push err_invalid_param\n    call print_string\n    add esp, 4\n    jmp .done\n    \n.print_file_not_found:\n    push err_file_not_found\n    call print_string\n    add esp, 4\n    jmp .done\n    \n.print_out_of_memory:\n    push err_out_of_memory\n    call print_string\n    add esp, 4\n    \n.done:\n    pop eax\n    mov esp, ebp\n    pop ebp\n    ret"
    },
    "data_alignment": {
      "description": "Proper data alignment for optimal memory access and cache performance.",
      "whenToUse": "For performance-critical data structures and SIMD operations.",
      "example": "; Data alignment patterns\n\nsection .data\n    ; Align data for optimal access\n    align 4\n    dword_value     dd 0x12345678\n    \n    align 8\n    qword_value     dq 0x123456789ABCDEF0\n    \n    ; Structure with proper padding\n    align 16\n    my_struct:\n        .field1     dd 0        ; 4 bytes\n        .field2     dd 0        ; 4 bytes\n        .field3     dq 0        ; 8 bytes\n        ; Total: 16 bytes (aligned)\n    \n    ; Array aligned for SIMD operations\n    align 32\n    float_array     times 8 dd 0.0     ; 8 floats for AVX\n\nsection .bss\n    ; Aligned buffer allocation\n    align 4096              ; Page alignment\n    large_buffer    resb 1048576        ; 1MB buffer\n    \n    align 64                ; Cache line alignment\n    cache_aligned   resb 256\n\nsection .text\n\n; Function using aligned data\nprocess_aligned_data:\n    push ebp\n    mov ebp, esp\n    \n    ; SSE example with aligned data\n    movaps xmm0, [float_array]      ; Aligned move\n    movaps xmm1, [float_array+16]\n    addps xmm0, xmm1                ; Packed single addition\n    movaps [float_array], xmm0      ; Store result\n    \n    mov esp, ebp\n    pop ebp\n    ret\n\n; Dynamic alignment\nallocate_aligned:\n    push ebp\n    mov ebp, esp\n    push ebx\n    \n    ; Allocate extra space for alignment\n    mov eax, [ebp+8]    ; Requested size\n    add eax, 15         ; Add alignment-1\n    push eax\n    call malloc\n    add esp, 4\n    \n    ; Align the returned pointer\n    mov ebx, eax\n    add ebx, 15         ; Add alignment-1\n    and ebx, -16        ; Clear lower 4 bits (align to 16)\n    \n    ; Store original pointer before aligned address\n    mov [ebx-4], eax\n    mov eax, ebx        ; Return aligned pointer\n    \n    pop ebx\n    mov esp, ebp\n    pop ebp\n    ret"
    },
    "state_machine": {
      "description": "Implement state machines using jump tables for efficient control flow.",
      "whenToUse": "For parsers, protocol handlers, and complex control logic.",
      "example": "; State machine implementation\n\nsection .data\n    ; State definitions\n    STATE_INIT      equ 0\n    STATE_READY     equ 1\n    STATE_RUNNING   equ 2\n    STATE_ERROR     equ 3\n    STATE_DONE      equ 4\n    \n    ; Jump table for state handlers\n    align 4\n    state_table:\n        dd handle_init\n        dd handle_ready\n        dd handle_running\n        dd handle_error\n        dd handle_done\n    \n    ; Current state\n    current_state   dd STATE_INIT\n\nsection .text\n\n; Main state machine dispatcher\nstate_machine_run:\n    push ebp\n    mov ebp, esp\n    push ebx\n    push esi\n    \n.dispatch_loop:\n    ; Get current state\n    mov eax, [current_state]\n    \n    ; Bounds check\n    cmp eax, STATE_DONE\n    ja .invalid_state\n    \n    ; Call state handler via jump table\n    mov ebx, [state_table + eax*4]\n    call ebx\n    \n    ; Check if done\n    cmp dword [current_state], STATE_DONE\n    jne .dispatch_loop\n    \n    xor eax, eax        ; Success\n    jmp .done\n    \n.invalid_state:\n    mov eax, -1         ; Error\n    \n.done:\n    pop esi\n    pop ebx\n    mov esp, ebp\n    pop ebp\n    ret\n\n; State handlers\nhandle_init:\n    ; Initialize resources\n    ; ...\n    ; Transition to ready\n    mov dword [current_state], STATE_READY\n    ret\n\nhandle_ready:\n    ; Check for start condition\n    ; ...\n    ; Transition to running\n    mov dword [current_state], STATE_RUNNING\n    ret\n\nhandle_running:\n    ; Process data\n    ; ...\n    ; Check for completion or error\n    ; mov dword [current_state], STATE_DONE\n    ret\n\nhandle_error:\n    ; Handle error condition\n    ; ...\n    ; Attempt recovery or transition to done\n    mov dword [current_state], STATE_DONE\n    ret\n\nhandle_done:\n    ; Cleanup\n    ret\n\n; Parser state machine example\nparse_number:\n    push ebp\n    mov ebp, esp\n    push esi\n    push edi\n    push ebx\n    \n    mov esi, [ebp+8]    ; Input string\n    xor edi, edi        ; Result accumulator\n    xor ebx, ebx        ; State\n    \n.parse_loop:\n    movzx eax, byte [esi]\n    test al, al\n    jz .done\n    \n    ; Digit check\n    sub al, '0'\n    cmp al, 9\n    ja .error\n    \n    ; Accumulate digit\n    imul edi, 10\n    add edi, eax\n    inc esi\n    jmp .parse_loop\n    \n.error:\n    mov edi, -1\n    \n.done:\n    mov eax, edi\n    pop ebx\n    pop edi\n    pop esi\n    mov esp, ebp\n    pop ebp\n    ret"
    }
  }
}