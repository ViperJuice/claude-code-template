{
  "language": "perl",
  "patterns": {
    "moose_class": {
      "description": "Use Moose for modern object-oriented programming with automatic accessors and type constraints.",
      "whenToUse": "For complex object hierarchies and when you need robust OO features.",
      "example": "package Person;\nuse Moose;\nuse Moose::Util::TypeConstraints;\n\n# Define custom types\nsubtype 'PositiveInt',\n    as 'Int',\n    where { $_ > 0 },\n    message { \"The number $_ is not a positive integer\" };\n\nsubtype 'Email',\n    as 'Str',\n    where { /^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$/ },\n    message { \"$_ is not a valid email address\" };\n\n# Attributes with type constraints\nhas 'name' => (\n    is       => 'ro',\n    isa      => 'Str',\n    required => 1,\n);\n\nhas 'age' => (\n    is       => 'rw',\n    isa      => 'PositiveInt',\n    trigger  => sub {\n        my ($self, $new_age) = @_;\n        print \"Age updated to $new_age\\n\";\n    },\n);\n\nhas 'email' => (\n    is        => 'rw',\n    isa       => 'Email',\n    predicate => 'has_email',\n    clearer   => 'clear_email',\n);\n\nhas 'friends' => (\n    is      => 'ro',\n    isa     => 'ArrayRef[Person]',\n    default => sub { [] },\n    traits  => ['Array'],\n    handles => {\n        add_friend    => 'push',\n        friend_count  => 'count',\n        get_friend    => 'get',\n        all_friends   => 'elements',\n    },\n);\n\n# Lazy attribute with builder\nhas 'id' => (\n    is      => 'ro',\n    isa     => 'Str',\n    lazy    => 1,\n    builder => '_build_id',\n);\n\nsub _build_id {\n    my $self = shift;\n    return sprintf(\"%s-%d-%d\", \n        lc($self->name =~ s/\\s+/_/gr),\n        $self->age || 0,\n        time());\n}\n\n# Method modifiers\nbefore 'age' => sub {\n    my ($self, $new_age) = @_;\n    return unless defined $new_age;\n    warn \"Age change from \" . ($self->age // 'undefined') . \" to $new_age\";\n};\n\naround 'email' => sub {\n    my $orig = shift;\n    my $self = shift;\n    \n    if (@_) {\n        my $email = shift;\n        # Additional validation\n        $email = lc($email);\n        return $self->$orig($email);\n    }\n    return $self->$orig();\n};\n\n# Methods\nsub introduce {\n    my $self = shift;\n    my $intro = sprintf(\"Hi, I'm %s, %d years old\", \n        $self->name, \n        $self->age // 0);\n    $intro .= \" (\" . $self->email . \")\" if $self->has_email;\n    return $intro;\n}\n\n# Role composition\npackage Employable;\nuse Moose::Role;\n\nhas 'company' => (\n    is        => 'rw',\n    isa       => 'Str',\n    predicate => 'is_employed',\n);\n\nhas 'salary' => (\n    is  => 'rw',\n    isa => 'Num',\n);\n\nsub work {\n    my $self = shift;\n    return \"Working at \" . $self->company if $self->is_employed;\n    return \"Currently unemployed\";\n}\n\n# Apply role\npackage Employee;\nuse Moose;\nextends 'Person';\nwith 'Employable';\n\n# Override parent method\noverride 'introduce' => sub {\n    my $self = shift;\n    my $intro = super();\n    $intro .= \", working at \" . $self->company if $self->is_employed;\n    return $intro;\n};\n\n__PACKAGE__->meta->make_immutable;\n1;"
    },
    "factory_pattern": {
      "description": "Create objects without specifying their exact class using factory methods.",
      "whenToUse": "When you need platform-independent code or want to defer object instantiation decisions.",
      "example": "package DatabaseFactory;\nuse strict;\nuse warnings;\n\n# Factory method\nsub create_connection {\n    my ($class, $config) = @_;\n    \n    my $driver = $config->{driver} || die \"No database driver specified\";\n    \n    my $connection_class = \"Database::$driver\";\n    \n    # Load the appropriate module\n    eval \"require $connection_class\" or die \"Cannot load $connection_class: $@\";\n    \n    return $connection_class->new($config);\n}\n\n# Base database class\npackage Database::Base;\nuse strict;\nuse warnings;\n\nsub new {\n    my ($class, $config) = @_;\n    return bless {\n        host     => $config->{host} || 'localhost',\n        port     => $config->{port},\n        database => $config->{database},\n        username => $config->{username},\n        password => $config->{password},\n    }, $class;\n}\n\nsub connect { die \"Subclass must implement connect()\" }\nsub disconnect { die \"Subclass must implement disconnect()\" }\nsub execute { die \"Subclass must implement execute()\" }\n\n# MySQL implementation\npackage Database::MySQL;\nuse strict;\nuse warnings;\nuse base 'Database::Base';\nuse DBI;\n\nsub new {\n    my ($class, $config) = @_;\n    my $self = $class->SUPER::new($config);\n    $self->{port} ||= 3306;\n    return $self;\n}\n\nsub connect {\n    my $self = shift;\n    \n    my $dsn = sprintf(\"DBI:mysql:database=%s;host=%s;port=%d\",\n        $self->{database}, $self->{host}, $self->{port});\n    \n    $self->{dbh} = DBI->connect(\n        $dsn,\n        $self->{username},\n        $self->{password},\n        { RaiseError => 1, AutoCommit => 1 }\n    ) or die \"Cannot connect: $DBI::errstr\";\n    \n    return $self;\n}\n\nsub disconnect {\n    my $self = shift;\n    $self->{dbh}->disconnect if $self->{dbh};\n}\n\nsub execute {\n    my ($self, $query, @params) = @_;\n    my $sth = $self->{dbh}->prepare($query);\n    $sth->execute(@params);\n    return $sth;\n}\n\n# PostgreSQL implementation\npackage Database::PostgreSQL;\nuse strict;\nuse warnings;\nuse base 'Database::Base';\nuse DBI;\n\nsub new {\n    my ($class, $config) = @_;\n    my $self = $class->SUPER::new($config);\n    $self->{port} ||= 5432;\n    return $self;\n}\n\nsub connect {\n    my $self = shift;\n    \n    my $dsn = sprintf(\"DBI:Pg:dbname=%s;host=%s;port=%d\",\n        $self->{database}, $self->{host}, $self->{port});\n    \n    $self->{dbh} = DBI->connect(\n        $dsn,\n        $self->{username},\n        $self->{password},\n        { RaiseError => 1, AutoCommit => 1 }\n    ) or die \"Cannot connect: $DBI::errstr\";\n    \n    return $self;\n}\n\n# ... similar disconnect and execute methods\n\n# Usage\nmy $db = DatabaseFactory->create_connection({\n    driver   => 'MySQL',\n    host     => 'localhost',\n    database => 'myapp',\n    username => 'user',\n    password => 'pass',\n});\n\n$db->connect();\nmy $sth = $db->execute(\"SELECT * FROM users WHERE age > ?\", 18);\nwhile (my $row = $sth->fetchrow_hashref) {\n    print \"$row->{name}: $row->{age}\\n\";\n}\n$db->disconnect();"
    },
    "template_method": {
      "description": "Define algorithm skeleton in base class with customizable steps in subclasses.",
      "whenToUse": "When you have similar algorithms with varying implementations of specific steps.",
      "example": "package DataProcessor;\nuse strict;\nuse warnings;\n\n# Template method pattern\nsub process {\n    my ($self, $input_file) = @_;\n    \n    # Template method defining the algorithm\n    my $data = $self->read_data($input_file);\n    my $validated = $self->validate_data($data);\n    my $transformed = $self->transform_data($validated);\n    my $result = $self->analyze_data($transformed);\n    $self->output_results($result);\n    \n    return $result;\n}\n\n# Default implementations (can be overridden)\nsub read_data {\n    my ($self, $file) = @_;\n    open my $fh, '<', $file or die \"Cannot read $file: $!\";\n    my @data = <$fh>;\n    close $fh;\n    return \\@data;\n}\n\nsub validate_data {\n    my ($self, $data) = @_;\n    # Default: remove empty lines\n    return [grep { /\\S/ } @$data];\n}\n\n# Abstract methods (must be implemented by subclasses)\nsub transform_data { die \"Subclass must implement transform_data()\" }\nsub analyze_data { die \"Subclass must implement analyze_data()\" }\n\nsub output_results {\n    my ($self, $results) = @_;\n    # Default: print to STDOUT\n    print \"Results:\\n\";\n    print \"$_\\n\" for @$results;\n}\n\n# Concrete implementation for CSV processing\npackage CSVProcessor;\nuse strict;\nuse warnings;\nuse base 'DataProcessor';\nuse Text::CSV;\n\nsub new {\n    my $class = shift;\n    return bless {\n        csv => Text::CSV->new({ binary => 1 }),\n        headers => [],\n    }, $class;\n}\n\nsub read_data {\n    my ($self, $file) = @_;\n    \n    open my $fh, '<', $file or die \"Cannot read $file: $!\";\n    \n    # Read headers\n    my $header_line = <$fh>;\n    $self->{csv}->parse($header_line);\n    $self->{headers} = [$self->{csv}->fields()];\n    \n    # Read data rows\n    my @data;\n    while (my $line = <$fh>) {\n        $self->{csv}->parse($line);\n        my @fields = $self->{csv}->fields();\n        \n        # Create hash with headers as keys\n        my %row;\n        @row{@{$self->{headers}}} = @fields;\n        push @data, \\%row;\n    }\n    \n    close $fh;\n    return \\@data;\n}\n\nsub validate_data {\n    my ($self, $data) = @_;\n    \n    # Remove rows with missing required fields\n    my @valid;\n    for my $row (@$data) {\n        next unless $row->{id} && $row->{name};\n        push @valid, $row;\n    }\n    \n    return \\@valid;\n}\n\nsub transform_data {\n    my ($self, $data) = @_;\n    \n    # Transform specific fields\n    for my $row (@$data) {\n        $row->{name} = uc($row->{name});\n        $row->{value} = sprintf(\"%.2f\", $row->{value} || 0);\n    }\n    \n    return $data;\n}\n\nsub analyze_data {\n    my ($self, $data) = @_;\n    \n    my %summary = (\n        total_records => scalar(@$data),\n        total_value => 0,\n        unique_names => {},\n    );\n    \n    for my $row (@$data) {\n        $summary{total_value} += $row->{value};\n        $summary{unique_names}{$row->{name}} = 1;\n    }\n    \n    $summary{unique_count} = keys %{$summary{unique_names}};\n    $summary{average_value} = $summary{total_value} / $summary{total_records}\n        if $summary{total_records} > 0;\n    \n    return \\%summary;\n}\n\nsub output_results {\n    my ($self, $results) = @_;\n    \n    print \"CSV Analysis Results:\\n\";\n    print \"-\" x 40, \"\\n\";\n    printf \"Total Records: %d\\n\", $results->{total_records};\n    printf \"Unique Names: %d\\n\", $results->{unique_count};\n    printf \"Total Value: %.2f\\n\", $results->{total_value};\n    printf \"Average Value: %.2f\\n\", $results->{average_value};\n}\n\n# Usage\nmy $processor = CSVProcessor->new();\n$processor->process('data.csv');"
    },
    "singleton": {
      "description": "Ensure a class has only one instance and provide global access to it.",
      "whenToUse": "For shared resources like configuration, logging, or connection pools.",
      "example": "package Logger;\nuse strict;\nuse warnings;\nuse POSIX qw(strftime);\n\n# Singleton implementation\n{\n    my $instance;\n    \n    sub new {\n        my $class = shift;\n        return $instance if $instance;\n        \n        my $self = bless {\n            log_file => shift || '/tmp/app.log',\n            level    => shift || 'INFO',\n            fh       => undef,\n        }, $class;\n        \n        $self->_init();\n        $instance = $self;\n        return $instance;\n    }\n    \n    sub instance {\n        my $class = shift;\n        return $instance || $class->new(@_);\n    }\n}\n\nsub _init {\n    my $self = shift;\n    open($self->{fh}, '>>', $self->{log_file})\n        or die \"Cannot open log file: $!\";\n    $self->{fh}->autoflush(1);\n}\n\nmy %levels = (\n    DEBUG => 0,\n    INFO  => 1,\n    WARN  => 2,\n    ERROR => 3,\n    FATAL => 4,\n);\n\nsub log {\n    my ($self, $level, $message) = @_;\n    \n    return if $levels{$level} < $levels{$self->{level}};\n    \n    my $timestamp = strftime(\"%Y-%m-%d %H:%M:%S\", localtime);\n    my $line = sprintf(\"[%s] %s: %s\\n\", $timestamp, $level, $message);\n    \n    print {$self->{fh}} $line;\n}\n\n# Convenience methods\nsub debug { shift->log('DEBUG', @_) }\nsub info  { shift->log('INFO', @_) }\nsub warn  { shift->log('WARN', @_) }\nsub error { shift->log('ERROR', @_) }\nsub fatal { shift->log('FATAL', @_) }\n\nsub set_level {\n    my ($self, $level) = @_;\n    die \"Invalid log level: $level\" unless exists $levels{$level};\n    $self->{level} = $level;\n}\n\nsub DESTROY {\n    my $self = shift;\n    close($self->{fh}) if $self->{fh};\n}\n\n# Alternative singleton using state (Perl 5.10+)\npackage ConfigManager;\nuse strict;\nuse warnings;\nuse feature 'state';\n\nsub instance {\n    state $instance = bless {\n        config => {},\n        file   => undef,\n    }, shift;\n    return $instance;\n}\n\nsub load {\n    my ($self, $file) = @_;\n    $self = $self->instance() unless ref $self;\n    \n    $self->{file} = $file;\n    \n    open my $fh, '<', $file or die \"Cannot read config: $!\";\n    while (<$fh>) {\n        chomp;\n        next if /^\\s*#/ || /^\\s*$/;\n        \n        if (/^\\s*([^=]+?)\\s*=\\s*(.+?)\\s*$/) {\n            $self->{config}{$1} = $2;\n        }\n    }\n    close $fh;\n    \n    return $self;\n}\n\nsub get {\n    my ($self, $key, $default) = @_;\n    $self = $self->instance() unless ref $self;\n    \n    return $self->{config}{$key} // $default;\n}\n\nsub set {\n    my ($self, $key, $value) = @_;\n    $self = $self->instance() unless ref $self;\n    \n    $self->{config}{$key} = $value;\n    $self->save() if $self->{file};\n}\n\nsub save {\n    my $self = shift;\n    return unless $self->{file};\n    \n    open my $fh, '>', $self->{file} or die \"Cannot write config: $!\";\n    for my $key (sort keys %{$self->{config}}) {\n        print $fh \"$key = $self->{config}{$key}\\n\";\n    }\n    close $fh;\n}\n\n# Usage\nmy $logger = Logger->instance('/var/log/myapp.log', 'DEBUG');\n$logger->info(\"Application started\");\n\n# Same instance from anywhere\nmy $logger2 = Logger->instance();\n$logger2->debug(\"This is the same logger instance\");\n\n# Config manager\nmy $config = ConfigManager->instance();\n$config->load('app.conf');\nmy $db_host = $config->get('database.host', 'localhost');"
    },
    "iterator": {
      "description": "Provide a way to access elements of a collection sequentially without exposing the underlying representation.",
      "whenToUse": "When you need to traverse complex data structures uniformly.",
      "example": "package Iterator;\nuse strict;\nuse warnings;\n\n# Abstract iterator\nsub new {\n    my $class = shift;\n    die \"$class is an abstract class\";\n}\n\nsub has_next { die \"Subclass must implement has_next()\" }\nsub next { die \"Subclass must implement next()\" }\nsub reset { die \"Subclass must implement reset()\" }\n\n# Array iterator\npackage ArrayIterator;\nuse strict;\nuse warnings;\nuse base 'Iterator';\n\nsub new {\n    my ($class, $array_ref) = @_;\n    return bless {\n        data  => $array_ref,\n        index => 0,\n    }, $class;\n}\n\nsub has_next {\n    my $self = shift;\n    return $self->{index} < @{$self->{data}};\n}\n\nsub next {\n    my $self = shift;\n    die \"No more elements\" unless $self->has_next();\n    return $self->{data}[$self->{index}++];\n}\n\nsub reset {\n    my $self = shift;\n    $self->{index} = 0;\n}\n\n# File iterator\npackage FileIterator;\nuse strict;\nuse warnings;\nuse base 'Iterator';\n\nsub new {\n    my ($class, $filename) = @_;\n    open my $fh, '<', $filename or die \"Cannot open $filename: $!\";\n    \n    return bless {\n        filename => $filename,\n        fh       => $fh,\n        buffer   => undef,\n        eof      => 0,\n    }, $class;\n}\n\nsub has_next {\n    my $self = shift;\n    \n    # Buffer next line if needed\n    if (!defined $self->{buffer} && !$self->{eof}) {\n        my $line = readline($self->{fh});\n        if (defined $line) {\n            chomp $line;\n            $self->{buffer} = $line;\n        } else {\n            $self->{eof} = 1;\n        }\n    }\n    \n    return defined $self->{buffer};\n}\n\nsub next {\n    my $self = shift;\n    die \"No more lines\" unless $self->has_next();\n    \n    my $line = $self->{buffer};\n    $self->{buffer} = undef;\n    return $line;\n}\n\nsub reset {\n    my $self = shift;\n    close $self->{fh};\n    open $self->{fh}, '<', $self->{filename} \n        or die \"Cannot reopen $self->{filename}: $!\";\n    $self->{buffer} = undef;\n    $self->{eof} = 0;\n}\n\nsub DESTROY {\n    my $self = shift;\n    close $self->{fh} if $self->{fh};\n}\n\n# Tree iterator\npackage TreeNode;\nuse strict;\nuse warnings;\n\nsub new {\n    my ($class, $value) = @_;\n    return bless {\n        value    => $value,\n        children => [],\n    }, $class;\n}\n\nsub add_child {\n    my ($self, $child) = @_;\n    push @{$self->{children}}, $child;\n}\n\npackage TreeIterator;\nuse strict;\nuse warnings;\nuse base 'Iterator';\n\nsub new {\n    my ($class, $root, $type) = @_;\n    $type ||= 'depth_first';\n    \n    my $self = bless {\n        root  => $root,\n        type  => $type,\n        stack => [$root],\n        visited => {},\n    }, $class;\n    \n    return $self;\n}\n\nsub has_next {\n    my $self = shift;\n    return @{$self->{stack}} > 0;\n}\n\nsub next {\n    my $self = shift;\n    die \"No more nodes\" unless $self->has_next();\n    \n    if ($self->{type} eq 'depth_first') {\n        my $node = pop @{$self->{stack}};\n        push @{$self->{stack}}, @{$node->{children}};\n        return $node->{value};\n    } elsif ($self->{type} eq 'breadth_first') {\n        my $node = shift @{$self->{stack}};\n        push @{$self->{stack}}, @{$node->{children}};\n        return $node->{value};\n    }\n}\n\nsub reset {\n    my $self = shift;\n    $self->{stack} = [$self->{root}];\n    $self->{visited} = {};\n}\n\n# Custom iterator with closure\nsub make_range_iterator {\n    my ($start, $end, $step) = @_;\n    $step ||= 1;\n    \n    my $current = $start;\n    \n    return {\n        has_next => sub { \n            return ($step > 0) ? ($current <= $end) : ($current >= $end);\n        },\n        next => sub {\n            die \"No more values\" unless \n                ($step > 0) ? ($current <= $end) : ($current >= $end);\n            my $value = $current;\n            $current += $step;\n            return $value;\n        },\n        reset => sub {\n            $current = $start;\n        },\n    };\n}\n\n# Usage examples\nmy $array_iter = ArrayIterator->new([1, 2, 3, 4, 5]);\nwhile ($array_iter->has_next()) {\n    print $array_iter->next(), \" \";\n}\nprint \"\\n\";\n\nmy $file_iter = FileIterator->new('data.txt');\nmy $line_num = 0;\nwhile ($file_iter->has_next()) {\n    printf \"%3d: %s\\n\", ++$line_num, $file_iter->next();\n}\n\n# Range iterator\nmy $range = make_range_iterator(1, 10, 2);\nwhile ($range->{has_next}->()) {\n    print $range->{next}->(), \" \";\n}\nprint \"\\n\";"
    },
    "strategy": {
      "description": "Define a family of algorithms, encapsulate each one, and make them interchangeable.",
      "whenToUse": "When you have multiple ways to perform a task and want to select at runtime.",
      "example": "package SortStrategy;\nuse strict;\nuse warnings;\n\n# Strategy interface\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub sort { die \"Subclass must implement sort()\" }\n\n# Concrete strategies\npackage BubbleSortStrategy;\nuse strict;\nuse warnings;\nuse base 'SortStrategy';\n\nsub sort {\n    my ($self, $data) = @_;\n    my @arr = @$data;  # Copy array\n    \n    for (my $i = 0; $i < @arr - 1; $i++) {\n        for (my $j = 0; $j < @arr - $i - 1; $j++) {\n            if ($arr[$j] > $arr[$j + 1]) {\n                @arr[$j, $j + 1] = @arr[$j + 1, $j];\n            }\n        }\n    }\n    \n    return \\@arr;\n}\n\npackage QuickSortStrategy;\nuse strict;\nuse warnings;\nuse base 'SortStrategy';\n\nsub sort {\n    my ($self, $data) = @_;\n    my @arr = @$data;\n    $self->_quicksort(\\@arr, 0, $#arr);\n    return \\@arr;\n}\n\nsub _quicksort {\n    my ($self, $arr, $low, $high) = @_;\n    \n    if ($low < $high) {\n        my $pi = $self->_partition($arr, $low, $high);\n        $self->_quicksort($arr, $low, $pi - 1);\n        $self->_quicksort($arr, $pi + 1, $high);\n    }\n}\n\nsub _partition {\n    my ($self, $arr, $low, $high) = @_;\n    \n    my $pivot = $arr->[$high];\n    my $i = $low - 1;\n    \n    for (my $j = $low; $j < $high; $j++) {\n        if ($arr->[$j] < $pivot) {\n            $i++;\n            @$arr[$i, $j] = @$arr[$j, $i];\n        }\n    }\n    \n    @$arr[$i + 1, $high] = @$arr[$high, $i + 1];\n    return $i + 1;\n}\n\npackage MergeSortStrategy;\nuse strict;\nuse warnings;\nuse base 'SortStrategy';\n\nsub sort {\n    my ($self, $data) = @_;\n    return $self->_merge_sort([@$data]);\n}\n\nsub _merge_sort {\n    my ($self, $arr) = @_;\n    \n    return $arr if @$arr <= 1;\n    \n    my $mid = int(@$arr / 2);\n    my @left = @$arr[0..$mid-1];\n    my @right = @$arr[$mid..$#$arr];\n    \n    return $self->_merge(\n        $self->_merge_sort(\\@left),\n        $self->_merge_sort(\\@right)\n    );\n}\n\nsub _merge {\n    my ($self, $left, $right) = @_;\n    my @result;\n    \n    while (@$left && @$right) {\n        if ($left->[0] <= $right->[0]) {\n            push @result, shift @$left;\n        } else {\n            push @result, shift @$right;\n        }\n    }\n    \n    push @result, @$left, @$right;\n    return \\@result;\n}\n\n# Context class\npackage DataProcessor;\nuse strict;\nuse warnings;\nuse Time::HiRes qw(time);\n\nsub new {\n    my ($class, $strategy) = @_;\n    return bless {\n        strategy => $strategy || BubbleSortStrategy->new(),\n        stats    => {},\n    }, $class;\n}\n\nsub set_strategy {\n    my ($self, $strategy) = @_;\n    $self->{strategy} = $strategy;\n}\n\nsub process {\n    my ($self, $data) = @_;\n    \n    my $start = time();\n    my $sorted = $self->{strategy}->sort($data);\n    my $end = time();\n    \n    $self->{stats}{last_duration} = $end - $start;\n    $self->{stats}{last_size} = scalar(@$data);\n    \n    return $sorted;\n}\n\nsub get_stats {\n    my $self = shift;\n    return { %{$self->{stats}} };\n}\n\n# Strategy with closures\npackage TextFormatter;\nuse strict;\nuse warnings;\n\nsub new {\n    my ($class, $format_strategy) = @_;\n    return bless {\n        formatter => $format_strategy || sub { $_[0] },\n    }, $class;\n}\n\nsub format {\n    my ($self, $text) = @_;\n    return $self->{formatter}->($text);\n}\n\nsub set_formatter {\n    my ($self, $formatter) = @_;\n    $self->{formatter} = $formatter;\n}\n\n# Predefined formatters\nour %FORMATTERS = (\n    uppercase => sub { uc($_[0]) },\n    lowercase => sub { lc($_[0]) },\n    title_case => sub {\n        my $text = shift;\n        $text =~ s/\\b(\\w)/\\u$1/g;\n        return $text;\n    },\n    reverse => sub { scalar reverse $_[0] },\n    remove_spaces => sub {\n        my $text = shift;\n        $text =~ s/\\s+//g;\n        return $text;\n    },\n    markdown_bold => sub { \"**$_[0]**\" },\n    html_bold => sub { \"<b>$_[0]</b>\" },\n);\n\n# Usage\nmy @data = (64, 34, 25, 12, 22, 11, 90);\n\n# Using different sort strategies\nmy $processor = DataProcessor->new(BubbleSortStrategy->new());\nmy $sorted1 = $processor->process(\\@data);\nprint \"Bubble sort: @$sorted1\\n\";\nprint \"Time: $processor->{stats}{last_duration}\\n\\n\";\n\n$processor->set_strategy(QuickSortStrategy->new());\nmy $sorted2 = $processor->process(\\@data);\nprint \"Quick sort: @$sorted2\\n\";\nprint \"Time: $processor->{stats}{last_duration}\\n\\n\";\n\n# Text formatting strategies\nmy $formatter = TextFormatter->new($TextFormatter::FORMATTERS{uppercase});\nprint $formatter->format(\"hello world\"), \"\\n\";\n\n$formatter->set_formatter($TextFormatter::FORMATTERS{title_case});\nprint $formatter->format(\"hello world from perl\"), \"\\n\";\n\n# Custom formatter\n$formatter->set_formatter(sub {\n    my $text = shift;\n    $text =~ s/\\b(\\w+)\\b/reverse($1)/ge;\n    return $text;\n});\nprint $formatter->format(\"hello world\"), \"\\n\";"
    },
    "mixin": {
      "description": "Add functionality to classes through role composition without inheritance.",
      "whenToUse": "When you want to share behavior across unrelated classes.",
      "example": "# Using Role::Tiny for lightweight mixins\npackage Timestampable;\nuse Role::Tiny;\nuse POSIX qw(strftime);\n\nhas created_at => (\n    is      => 'ro',\n    default => sub { time() },\n);\n\nhas updated_at => (\n    is      => 'rw',\n    default => sub { time() },\n);\n\nsub touch {\n    my $self = shift;\n    $self->updated_at(time());\n}\n\nsub age {\n    my $self = shift;\n    return time() - $self->created_at;\n}\n\nsub formatted_created_at {\n    my ($self, $format) = @_;\n    $format ||= '%Y-%m-%d %H:%M:%S';\n    return strftime($format, localtime($self->created_at));\n}\n\n# Another mixin\npackage Serializable;\nuse Role::Tiny;\nuse JSON;\n\nrequires 'to_hash';  # Classes must implement this\n\nsub to_json {\n    my $self = shift;\n    return encode_json($self->to_hash());\n}\n\nsub from_json {\n    my ($class, $json) = @_;\n    my $data = decode_json($json);\n    return $class->new(%$data);\n}\n\n# Validation mixin\npackage Validatable;\nuse Role::Tiny;\n\nhas errors => (\n    is      => 'ro',\n    default => sub { [] },\n);\n\nsub add_error {\n    my ($self, $field, $message) = @_;\n    push @{$self->errors}, {\n        field   => $field,\n        message => $message,\n    };\n}\n\nsub clear_errors {\n    my $self = shift;\n    @{$self->errors} = ();\n}\n\nsub is_valid {\n    my $self = shift;\n    $self->clear_errors();\n    $self->validate();\n    return @{$self->errors} == 0;\n}\n\nsub error_messages {\n    my $self = shift;\n    return map { \"$_->{field}: $_->{message}\" } @{$self->errors};\n}\n\nrequires 'validate';  # Must be implemented\n\n# Using mixins in a class\npackage User;\nuse Moo;  # or Mouse, or Moose\nwith 'Timestampable', 'Serializable', 'Validatable';\n\nhas name => (\n    is       => 'rw',\n    required => 1,\n);\n\nhas email => (\n    is       => 'rw',\n    required => 1,\n);\n\nhas age => (\n    is      => 'rw',\n    default => 0,\n);\n\n# Required by Serializable\nsub to_hash {\n    my $self = shift;\n    return {\n        name       => $self->name,\n        email      => $self->email,\n        age        => $self->age,\n        created_at => $self->created_at,\n        updated_at => $self->updated_at,\n    };\n}\n\n# Required by Validatable\nsub validate {\n    my $self = shift;\n    \n    if (!$self->name || length($self->name) < 2) {\n        $self->add_error('name', 'must be at least 2 characters');\n    }\n    \n    if (!$self->email || $self->email !~ /^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$/) {\n        $self->add_error('email', 'invalid email format');\n    }\n    \n    if ($self->age < 0 || $self->age > 150) {\n        $self->add_error('age', 'must be between 0 and 150');\n    }\n}\n\n# Traditional Perl mixin using @ISA manipulation\npackage Cacheable;\nuse strict;\nuse warnings;\nuse Digest::MD5 qw(md5_hex);\n\nour %CACHE;\n\nsub cache_key {\n    my ($self, @args) = @_;\n    return md5_hex(ref($self) . ':' . join(':', @args));\n}\n\nsub cache_get {\n    my ($self, $key) = @_;\n    return $CACHE{$key};\n}\n\nsub cache_set {\n    my ($self, $key, $value, $ttl) = @_;\n    $CACHE{$key} = {\n        value   => $value,\n        expires => $ttl ? time() + $ttl : 0,\n    };\n}\n\nsub with_cache {\n    my ($self, $method, $ttl, @args) = @_;\n    \n    my $key = $self->cache_key($method, @args);\n    my $cached = $self->cache_get($key);\n    \n    if ($cached && ($cached->{expires} == 0 || $cached->{expires} > time())) {\n        return $cached->{value};\n    }\n    \n    my $result = $self->$method(@args);\n    $self->cache_set($key, $result, $ttl);\n    \n    return $result;\n}\n\n# Import mixin methods\nsub import {\n    my $class = shift;\n    my $caller = caller;\n    \n    no strict 'refs';\n    *{\"${caller}::cache_key\"} = \\&cache_key;\n    *{\"${caller}::cache_get\"} = \\&cache_get;\n    *{\"${caller}::cache_set\"} = \\&cache_set;\n    *{\"${caller}::with_cache\"} = \\&with_cache;\n}\n\n# Usage\nmy $user = User->new(\n    name  => 'John Doe',\n    email => 'john@example.com',\n    age   => 30,\n);\n\n# From Timestampable\nprint \"Created: \", $user->formatted_created_at(), \"\\n\";\nsleep 2;\n$user->touch();\nprint \"Age: \", $user->age(), \" seconds\\n\";\n\n# From Serializable\nmy $json = $user->to_json();\nprint \"JSON: $json\\n\";\nmy $restored = User->from_json($json);\n\n# From Validatable\nif ($user->is_valid()) {\n    print \"User is valid\\n\";\n} else {\n    print \"Errors: \", join(\", \", $user->error_messages()), \"\\n\";\n}"
    },
    "lazy_loading": {
      "description": "Defer initialization of an object until it's actually needed.",
      "whenToUse": "For expensive operations or resources that might not be used.",
      "example": "package LazyLoader;\nuse strict;\nuse warnings;\n\n# Generic lazy loading\nsub lazy {\n    my ($generator) = @_;\n    \n    my $value;\n    my $computed = 0;\n    \n    return sub {\n        unless ($computed) {\n            $value = $generator->();\n            $computed = 1;\n        }\n        return $value;\n    };\n}\n\n# Lazy attribute implementation\npackage LazyAttributes;\nuse strict;\nuse warnings;\n\nsub new {\n    my $class = shift;\n    return bless {}, $class;\n}\n\nsub lazy_attr {\n    my ($class, $name, $builder) = @_;\n    \n    no strict 'refs';\n    \n    # Getter/setter method\n    *{\"${class}::${name}\"} = sub {\n        my $self = shift;\n        \n        if (@_) {\n            # Setter\n            $self->{\"_${name}\"} = shift;\n            $self->{\"_${name}_loaded\"} = 1;\n        } else {\n            # Getter with lazy loading\n            unless ($self->{\"_${name}_loaded\"}) {\n                $self->{\"_${name}\"} = $builder->($self);\n                $self->{\"_${name}_loaded\"} = 1;\n            }\n        }\n        \n        return $self->{\"_${name}\"};\n    };\n    \n    # Predicate method\n    *{\"${class}::has_${name}\"} = sub {\n        my $self = shift;\n        return $self->{\"_${name}_loaded\"} ? 1 : 0;\n    };\n    \n    # Clearer method\n    *{\"${class}::clear_${name}\"} = sub {\n        my $self = shift;\n        delete $self->{\"_${name}\"};\n        delete $self->{\"_${name}_loaded\"};\n    };\n}\n\n# Example class using lazy attributes\npackage Database;\nuse strict;\nuse warnings;\nuse base 'LazyAttributes';\nuse DBI;\n\n__PACKAGE__->lazy_attr('connection', sub {\n    my $self = shift;\n    print \"Establishing database connection...\\n\";\n    \n    return DBI->connect(\n        $self->{dsn},\n        $self->{username},\n        $self->{password},\n        { RaiseError => 1, AutoCommit => 1 }\n    );\n});\n\n__PACKAGE__->lazy_attr('schema_info', sub {\n    my $self = shift;\n    print \"Loading schema information...\\n\";\n    \n    my $dbh = $self->connection();\n    my $tables = $dbh->selectall_arrayref(\n        \"SELECT table_name FROM information_schema.tables WHERE table_schema = ?\",\n        { Slice => {} },\n        $self->{database}\n    );\n    \n    return { tables => $tables };\n});\n\nsub new {\n    my ($class, %args) = @_;\n    my $self = $class->SUPER::new();\n    \n    $self->{dsn} = $args{dsn} || die \"DSN required\";\n    $self->{username} = $args{username};\n    $self->{password} = $args{password};\n    $self->{database} = $args{database};\n    \n    return $self;\n}\n\nsub query {\n    my ($self, $sql, @params) = @_;\n    return $self->connection()->selectall_arrayref($sql, { Slice => {} }, @params);\n}\n\n# Lazy loading with caching\npackage DataService;\nuse strict;\nuse warnings;\nuse LWP::UserAgent;\nuse JSON;\n\nsub new {\n    my ($class, %args) = @_;\n    return bless {\n        base_url => $args{base_url},\n        ua       => LWP::UserAgent->new(),\n        cache    => {},\n    }, $class;\n}\n\nsub lazy_fetch {\n    my ($self, $endpoint) = @_;\n    \n    # Return cached if available\n    return $self->{cache}{$endpoint} if exists $self->{cache}{$endpoint};\n    \n    # Create lazy loader\n    my $loader = LazyLoader::lazy(sub {\n        print \"Fetching $endpoint...\\n\";\n        \n        my $response = $self->{ua}->get($self->{base_url} . $endpoint);\n        die \"Failed to fetch $endpoint: \" . $response->status_line\n            unless $response->is_success;\n        \n        return decode_json($response->content);\n    });\n    \n    # Cache the lazy loader\n    $self->{cache}{$endpoint} = $loader;\n    \n    return $loader;\n}\n\n# Proxy pattern for lazy loading\npackage LazyProxy;\nuse strict;\nuse warnings;\n\nsub new {\n    my ($class, $target_class, @args) = @_;\n    \n    return bless {\n        target_class => $target_class,\n        args         => \\@args,\n        instance     => undef,\n    }, $class;\n}\n\nsub _get_instance {\n    my $self = shift;\n    \n    unless ($self->{instance}) {\n        print \"Creating instance of $self->{target_class}...\\n\";\n        my $class = $self->{target_class};\n        eval \"require $class\" or die $@;\n        $self->{instance} = $class->new(@{$self->{args}});\n    }\n    \n    return $self->{instance};\n}\n\nsub AUTOLOAD {\n    my $self = shift;\n    my $method = our $AUTOLOAD;\n    $method =~ s/.*:://;\n    \n    return if $method eq 'DESTROY';\n    \n    my $instance = $self->_get_instance();\n    return $instance->$method(@_);\n}\n\n# Usage examples\n\n# Basic lazy loading\nmy $expensive_data = LazyLoader::lazy(sub {\n    print \"Computing expensive data...\\n\";\n    sleep 2;  # Simulate expensive operation\n    return { result => 'expensive computation' };\n});\n\nprint \"Lazy loader created\\n\";\nprint \"First access: \", $expensive_data->()->{result}, \"\\n\";\nprint \"Second access: \", $expensive_data->()->{result}, \"\\n\";\n\n# Database with lazy connection\nmy $db = Database->new(\n    dsn      => 'DBI:mysql:database=test;host=localhost',\n    username => 'user',\n    password => 'pass',\n    database => 'test',\n);\n\nprint \"Database object created\\n\";\nprint \"Has connection? \", $db->has_connection() ? 'yes' : 'no', \"\\n\";\n\n# Connection is established only when needed\nmy $results = $db->query(\"SELECT * FROM users LIMIT 5\");\n\n# Lazy proxy\nmy $proxy = LazyProxy->new('ExpensiveClass', foo => 'bar');\nprint \"Proxy created\\n\";\n# ExpensiveClass is loaded and instantiated only on first method call\n$proxy->do_something();"
    }
  }
}