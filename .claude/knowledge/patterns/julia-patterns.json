{
  "language": "julia",
  "patterns": {
    "multiple_dispatch": {
      "description": "Multiple dispatch allows functions to have different implementations based on the types of all arguments, enabling elegant and performant polymorphism",
      "whenToUse": "Use as the primary mechanism for polymorphism, when implementing generic algorithms, creating extensible APIs, or building type-specific optimizations",
      "example": "# Basic multiple dispatch\nfunction area(shape)\n    error(\"area not implemented for $(typeof(shape))\")\nend\n\n# Specific implementations for different types\narea(r::Rectangle) = r.width * r.height\narea(c::Circle) = Ï€ * c.radius^2\narea(t::Triangle) = 0.5 * t.base * t.height\n\n# Multiple dispatch on multiple arguments\nfunction combine(x::Number, y::Number)\n    return x + y\nend\n\nfunction combine(x::String, y::String)\n    return x * y  # String concatenation in Julia\nend\n\nfunction combine(x::Vector, y::Vector)\n    return vcat(x, y)\nend\n\n# Type parameters and constraints\nfunction dot_product(v1::Vector{T}, v2::Vector{T}) where T<:Number\n    length(v1) == length(v2) || throw(DimensionMismatch(\"vectors must have same length\"))\n    return sum(v1 .* v2)\nend\n\n# Diagonal dispatch for special cases\nfunction process(x::T, y::T) where T\n    println(\"Processing two values of the same type: $T\")\n    return x, y\nend\n\nfunction process(x::Integer, y::Integer)\n    println(\"Special handling for integers\")\n    return x + y\nend\n\n# Varargs and optional arguments\nfunction aggregate(op::Function, x::Number, rest::Number...)\n    result = x\n    for val in rest\n        result = op(result, val)\n    end\n    return result\nend\n\n# Method ambiguity resolution\nfunction priority_dispatch(x::Integer, y::Real)\n    return \"Integer-Real\"\nend\n\nfunction priority_dispatch(x::Real, y::Integer)\n    return \"Real-Integer\"\nend\n\n# Need to resolve ambiguity for (Integer, Integer)\nfunction priority_dispatch(x::Integer, y::Integer)\n    return \"Integer-Integer\"\nend\n\n# Dynamic dispatch with type stability\nfunction type_stable_dispatch(data::Vector)\n    # Compiler can optimize when return type is predictable\n    s = zero(eltype(data))  # Type-stable initialization\n    for x in data\n        s += process_element(x)  # Dispatches based on element type\n    end\n    return s\nend\n\nprocess_element(x::Float64) = x\nprocess_element(x::Int) = float(x)\nprocess_element(x::Complex) = real(x)"
    },
    "parametric_types": {
      "description": "Parametric types allow creating generic data structures and functions that work with different types while maintaining type safety and performance",
      "whenToUse": "Use when building generic containers, implementing algorithms that work across types, creating type-safe abstractions, or optimizing performance with type specialization",
      "example": "# Parametric composite types\nstruct Point{T<:Real}\n    x::T\n    y::T\nend\n\n# Parametric with multiple parameters\nstruct Matrix2D{T<:Number, S<:AbstractStorage}\n    data::S\n    rows::Int\n    cols::Int\n    \n    function Matrix2D{T,S}(data::S, rows::Int, cols::Int) where {T<:Number, S<:AbstractStorage}\n        length(data) == rows * cols || throw(ArgumentError(\"Data size mismatch\"))\n        new{T,S}(data, rows, cols)\n    end\nend\n\n# Parametric abstract types\nabstract type AbstractContainer{T} end\n\nstruct Vector{T} <: AbstractContainer{T}\n    data::Array{T,1}\nend\n\nstruct SparseVector{T} <: AbstractContainer{T}\n    indices::Vector{Int}\n    values::Vector{T}\n    length::Int\nend\n\n# Type parameters in functions\nfunction zero_array(::Type{T}, dims...) where T\n    return zeros(T, dims...)\nend\n\n# Constrained type parameters\nfunction safe_divide(x::T, y::T) where T<:AbstractFloat\n    y == zero(T) && throw(DivideError())\n    return x / y\nend\n\n# Multiple type parameters with relationships\nfunction convert_array(::Type{Array{T,N}}, a::Array{S,N}) where {T,S,N}\n    return T[convert(T, x) for x in a]\nend\n\n# UnionAll types\nconst VecOrMat{T} = Union{Vector{T}, Matrix{T}}\n\nfunction sum_elements(x::VecOrMat{T}) where T<:Number\n    return sum(x)\nend\n\n# Parametric methods with trait-like behavior\nstruct GPU end\nstruct CPU end\n\nfunction compute(::Type{GPU}, data::Array{T}) where T\n    println(\"GPU computation for $(T)\")\n    # GPU-specific implementation\nend\n\nfunction compute(::Type{CPU}, data::Array{T}) where T\n    println(\"CPU computation for $(T)\")\n    # CPU-specific implementation\nend\n\n# Variance and type bounds\nstruct Container{T}\n    value::T\nend\n\n# Covariant-like behavior through methods\nBase.convert(::Type{Container{T}}, c::Container{S}) where {T,S<:T} = Container{T}(convert(T, c.value))\n\n# Type-stable constructors\nstruct OptimalArray{T,N}\n    data::Array{T,N}\n    \n    # Inner constructor ensures type stability\n    function OptimalArray(data::Array{T,N}) where {T,N}\n        new{T,N}(data)\n    end\nend\n\n# Parametric type aliases\nconst Point2D = Point{Float64}\nconst IntVector = Vector{Int}"
    },
    "metaprogramming": {
      "description": "Metaprogramming in Julia allows code generation and transformation at parse time or compile time, enabling powerful abstractions and domain-specific languages",
      "whenToUse": "Use when eliminating boilerplate code, creating DSLs, generating optimized code for specific cases, or building macro-based APIs",
      "example": "# Basic macro for timing\nmacro timed(ex)\n    quote\n        local t0 = time()\n        local val = $(esc(ex))\n        local t1 = time()\n        println(\"Elapsed time: \", t1-t0, \" seconds\")\n        val\n    end\nend\n\n# Using the macro\n# @timed begin\n#     sleep(1)\n#     42\n# end\n\n# Code generation with eval\nfor op in (:+, :-, :*, :/)\n    @eval begin\n        function vectorized_op(a::Vector{T}, b::Vector{T}, ::typeof($op)) where T\n            return [$op(a[i], b[i]) for i in 1:length(a)]\n        end\n    end\nend\n\n# Macro for creating getters/setters\nmacro define_property(name, T)\n    field = Symbol(\"_\", name)\n    getter = name\n    setter = Symbol(\"set_\", name, \"!\")\n    \n    quote\n        $field::$T\n        \n        function $(esc(getter))(obj)\n            return obj.$field\n        end\n        \n        function $(esc(setter))(obj, value::$T)\n            obj.$field = value\n            return obj\n        end\n    end\nend\n\n# Expression manipulation\nfunction optimize_expression(ex::Expr)\n    if ex.head == :call && ex.args[1] == :* && ex.args[3] == 2\n        # Replace x * 2 with x + x\n        return :( $(ex.args[2]) + $(ex.args[2]) )\n    end\n    \n    # Recursively process sub-expressions\n    return Expr(ex.head, [optimize_expression(arg) for arg in ex.args]...)\nend\n\noptimize_expression(x) = x  # Base case for non-expressions\n\n# Generated functions for compile-time computation\n@generated function static_unroll(f::F, ::Val{N}) where {F,N}\n    exprs = [:(f($i)) for i in 1:N]\n    return quote\n        $(exprs...)\n        nothing\n    end\nend\n\n# Staged programming with generated functions\n@generated function efficient_dot(x::NTuple{N,T}, y::NTuple{N,T}) where {N,T}\n    terms = [:(x[$i] * y[$i]) for i in 1:N]\n    return :(+($(terms...)))\nend\n\n# Macro for pattern matching\nmacro match(expr, cases...)\n    result = :(error(\"No matching case\"))\n    \n    for case in reverse(cases)\n        pattern, action = case.args[1], case.args[2]\n        condition = pattern_to_condition(expr, pattern)\n        result = :(if $condition\n            $action\n        else\n            $result\n        end)\n    end\n    \n    return esc(result)\nend\n\n# String interpolation in macros\nmacro sql(query)\n    # Parse SQL-like syntax into Julia code\n    return quote\n        # Implementation would parse the SQL string\n        println(\"Executing SQL: \", $(string(query)))\n    end\nend\n\n# Symbol manipulation\nmacro create_constants(prefix, values...)\n    assignments = []\n    for (i, val) in enumerate(values)\n        name = Symbol(prefix, \"_\", i)\n        push!(assignments, :( const $(esc(name)) = $val ))\n    end\n    return quote\n        $(assignments...)\n    end\nend"
    },
    "traits_pattern": {
      "description": "Traits in Julia are a pattern for grouping types by behavior rather than inheritance, enabling flexible and extensible interfaces",
      "whenToUse": "Use when you need to define behavior across unrelated types, implement interface-like contracts, or enable generic programming based on capabilities",
      "example": "# Holy trait pattern\nabstract type IteratorSize end\nstruct HasLength <: IteratorSize end\nstruct HasShape <: IteratorSize end\nstruct IsInfinite <: IteratorSize end\nstruct SizeUnknown <: IteratorSize end\n\n# Trait function\nIteratorSize(::Type) = SizeUnknown()\nIteratorSize(::Type{<:Array}) = HasShape()\nIteratorSize(::Type{<:AbstractRange}) = HasLength()\n\n# Dispatch on traits\nfunction my_collect(itr)\n    _collect(IteratorSize(typeof(itr)), itr)\nend\n\nfunction _collect(::HasLength, itr)\n    n = length(itr)\n    arr = Vector{eltype(itr)}(undef, n)\n    for (i, x) in enumerate(itr)\n        arr[i] = x\n    end\n    return arr\nend\n\nfunction _collect(::SizeUnknown, itr)\n    arr = eltype(itr)[]\n    for x in itr\n        push!(arr, x)\n    end\n    return arr\nend\n\n# Trait-based dispatch for algorithms\nabstract type IndexStyle end\nstruct IndexLinear <: IndexStyle end\nstruct IndexCartesian <: IndexStyle end\n\nIndexStyle(::Type) = IndexCartesian()\nIndexStyle(::Type{<:Array}) = IndexLinear()\nIndexStyle(::Type{<:AbstractRange}) = IndexLinear()\n\nfunction efficient_sum(A::AbstractArray)\n    _sum(IndexStyle(typeof(A)), A)\nend\n\nfunction _sum(::IndexLinear, A)\n    s = zero(eltype(A))\n    for i in eachindex(A)\n        s += A[i]\n    end\n    return s\nend\n\nfunction _sum(::IndexCartesian, A)\n    s = zero(eltype(A))\n    for I in CartesianIndices(A)\n        s += A[I]\n    end\n    return s\nend\n\n# Trait for numeric types\nstruct IsNumeric end\nstruct NotNumeric end\n\nNumericTrait(::Type{<:Number}) = IsNumeric()\nNumericTrait(::Type) = NotNumeric()\n\nfunction safe_mean(collection)\n    _mean(NumericTrait(eltype(collection)), collection)\nend\n\nfunction _mean(::IsNumeric, collection)\n    return sum(collection) / length(collection)\nend\n\nfunction _mean(::NotNumeric, collection)\n    error(\"Cannot compute mean of non-numeric type $(eltype(collection))\")\nend\n\n# Composition of traits\nstruct SupportsArithmetic end\nstruct NoArithmetic end\n\nArithmeticTrait(T::Type) = method_exists(+, (T, T)) ? SupportsArithmetic() : NoArithmetic()\n\n# Advanced trait with type parameters\nabstract type StorageOrder end\nstruct RowMajor <: StorageOrder end\nstruct ColumnMajor <: StorageOrder end\n\nStorageOrder(::Type{<:Array}) = ColumnMajor()\n\nfunction optimize_iteration(A::AbstractMatrix, f::Function)\n    _iterate(StorageOrder(typeof(A)), A, f)\nend\n\nfunction _iterate(::ColumnMajor, A, f)\n    for j in 1:size(A, 2)\n        for i in 1:size(A, 1)\n            f(A[i, j])\n        end\n    end\nend\n\nfunction _iterate(::RowMajor, A, f)\n    for i in 1:size(A, 1)\n        for j in 1:size(A, 2)\n            f(A[i, j])\n        end\n    end\nend"
    },
    "type_stability": {
      "description": "Type stability ensures functions return consistent types for given input types, enabling Julia's compiler to generate efficient code",
      "whenToUse": "Use when optimizing performance-critical code, building libraries, ensuring predictable behavior, or eliminating runtime type checks",
      "example": "# Type unstable function (bad)\nfunction unstable_parse(s::String)\n    if occursin(\".\", s)\n        return parse(Float64, s)  # Returns Float64\n    else\n        return parse(Int, s)      # Returns Int\n    end\nend\n\n# Type stable alternatives\n# Option 1: Always return the same type\nfunction stable_parse_float(s::String)\n    return parse(Float64, s)\nend\n\n# Option 2: Use Union types when necessary\nfunction stable_parse_union(s::String)::Union{Int,Float64}\n    if occursin(\".\", s)\n        return parse(Float64, s)\n    else\n        return parse(Int, s)\n    end\nend\n\n# Option 3: Parameterize by output type\nfunction stable_parse(::Type{T}, s::String) where T<:Number\n    return parse(T, s)\nend\n\n# Type stability with containers\nfunction type_stable_accumulate(data::Vector{T}) where T\n    # Use zero(T) to ensure type stability\n    total = zero(T)\n    count = 0\n    \n    for value in data\n        total += value\n        count += 1\n    end\n    \n    # Ensure we return the same type\n    return count > 0 ? total / T(count) : zero(T)\nend\n\n# Avoiding type instability in conditionals\nfunction stable_default(x::Union{T,Nothing}, default::T) where T\n    return x === nothing ? default : x\nend\n\n# Type stable error handling\nstruct Result{T,E}\n    value::Union{T,Nothing}\n    error::Union{E,Nothing}\n    is_ok::Bool\n    \n    Result{T,E}(value::T) where {T,E} = new{T,E}(value, nothing, true)\n    Result{T,E}(error::E) where {T,E} = new{T,E}(nothing, error, false)\nend\n\nfunction safe_divide(x::T, y::T) where T<:AbstractFloat\n    if y == zero(T)\n        return Result{T,String}(\"Division by zero\")\n    else\n        return Result{T,String}(x / y)\n    end\nend\n\n# Type assertions for performance\nfunction optimized_sum(arr::Vector)\n    s = 0.0\n    for x in arr\n        # Type assertion helps compiler\n        s += x::Float64\n    end\n    return s\nend\n\n# Function barriers for type stability\nfunction process_data(data)\n    # Type unstable part\n    processed = prepare_data(data)\n    \n    # Call type-stable inner function\n    return _process_stable(processed)\nend\n\nfunction _process_stable(data::Vector{Float64})\n    # Now everything is type stable\n    return sum(data) / length(data)\nend\n\n# Maintaining type stability with missing values\nfunction handle_missing(data::Vector{Union{T,Missing}}) where T\n    total = zero(T)\n    count = 0\n    \n    for value in data\n        if !ismissing(value)\n            total += value\n            count += 1\n        end\n    end\n    \n    return count > 0 ? total / count : missing\nend"
    },
    "composition_pattern": {
      "description": "Composition in Julia favors combining behaviors through field embedding and delegation rather than inheritance, promoting flexible and modular design",
      "whenToUse": "Use when building complex types from simpler ones, avoiding deep inheritance hierarchies, implementing has-a relationships, or creating modular interfaces",
      "example": "# Composition through fields\nstruct Engine\n    horsepower::Int\n    cylinders::Int\nend\n\nstruct Wheels\n    count::Int\n    size::Float64\nend\n\nstruct Car\n    engine::Engine\n    wheels::Wheels\n    model::String\nend\n\n# Delegation pattern\nfunction start(engine::Engine)\n    println(\"Starting $(engine.cylinders)-cylinder engine with $(engine.horsepower) HP\")\nend\n\n# Delegate to composed object\nstart(car::Car) = start(car.engine)\n\n# Mixin-like behavior with multiple composition\nmutable struct Position\n    x::Float64\n    y::Float64\nend\n\nmutable struct Velocity\n    vx::Float64\n    vy::Float64\nend\n\nmutable struct Sprite\n    image::String\n    width::Int\n    height::Int\nend\n\n# Compose multiple behaviors\nmutable struct GameObject\n    position::Position\n    velocity::Velocity\n    sprite::Sprite\n    active::Bool\nend\n\n# Define operations on components\nmove!(pos::Position, vel::Velocity, dt::Float64) = begin\n    pos.x += vel.vx * dt\n    pos.y += vel.vy * dt\nend\n\n# Delegate to components\nmove!(obj::GameObject, dt::Float64) = move!(obj.position, obj.velocity, dt)\n\n# Interface-like composition\nabstract type Component end\n\nstruct Transform <: Component\n    position::Vector{Float64}\n    rotation::Float64\n    scale::Float64\nend\n\nstruct Renderer <: Component\n    mesh::String\n    material::String\nend\n\nstruct Entity\n    id::Int\n    components::Dict{DataType, Component}\nend\n\n# Add/get components\nfunction add_component!(entity::Entity, component::T) where T<:Component\n    entity.components[T] = component\nend\n\nfunction get_component(entity::Entity, ::Type{T}) where T<:Component\n    return get(entity.components, T, nothing)\nend\n\n# Functional composition\nstruct Pipeline{T<:Tuple}\n    functions::T\nend\n\nPipeline(fs...) = Pipeline(fs)\n\nfunction (pipe::Pipeline)(x)\n    result = x\n    for f in pipe.functions\n        result = f(result)\n    end\n    return result\nend\n\n# Usage\nprocess = Pipeline(\n    x -> x .^ 2,\n    x -> x .+ 1,\n    x -> sqrt.(x)\n)\n\n# Trait-based composition\nstruct Drawable end\nstruct Updatable end\nstruct Collidable end\n\n# Types can have multiple traits\ntraits(::Type{GameObject}) = (Drawable(), Updatable(), Collidable())\n\n# Forward method calls to composed fields\nBase.getindex(car::Car, key::Symbol) = begin\n    if key == :horsepower\n        return car.engine.horsepower\n    elseif key == :wheel_count\n        return car.wheels.count\n    else\n        error(\"Unknown property: $key\")\n    end\nend"
    },
    "performance_patterns": {
      "description": "Performance patterns in Julia leverage type specialization, vectorization, and memory layout optimization to achieve C-like performance",
      "whenToUse": "Use when optimizing hot paths, processing large datasets, minimizing allocations, or achieving maximum computational efficiency",
      "example": "# Preallocate buffers to avoid allocations\nfunction efficient_matrix_multiply!(C::Matrix{T}, A::Matrix{T}, B::Matrix{T}) where T\n    m, n = size(A)\n    n2, p = size(B)\n    \n    @assert n == n2 \"Matrix dimensions must match\"\n    @assert size(C) == (m, p) \"Output matrix has wrong size\"\n    \n    # Use @inbounds to skip bounds checking in hot loop\n    @inbounds for j in 1:p\n        for i in 1:m\n            Cij = zero(T)\n            for k in 1:n\n                Cij += A[i,k] * B[k,j]\n            end\n            C[i,j] = Cij\n        end\n    end\n    return C\nend\n\n# Memory layout optimization\nstruct ColumnMajorMatrix{T}\n    data::Vector{T}\n    rows::Int\n    cols::Int\nend\n\n# Access pattern optimized for Julia's column-major layout\nfunction column_major_sum(mat::Matrix{T}) where T\n    total = zero(T)\n    @inbounds for j in 1:size(mat, 2)\n        for i in 1:size(mat, 1)\n            total += mat[i, j]  # Column-major access\n        end\n    end\n    return total\nend\n\n# SIMD vectorization\nfunction simd_dot_product(x::Vector{T}, y::Vector{T}) where T\n    @assert length(x) == length(y)\n    s = zero(T)\n    @simd for i in eachindex(x, y)\n        @inbounds s += x[i] * y[i]\n    end\n    return s\nend\n\n# Avoid type instability in hot loops\nfunction stable_accumulate(data::Vector{T}, op::F) where {T, F<:Function}\n    isempty(data) && return zero(T)\n    \n    result = data[1]\n    @inbounds for i in 2:length(data)\n        result = op(result, data[i])\n    end\n    return result\nend\n\n# Use views to avoid copying\nfunction process_chunks(data::Vector{T}, chunk_size::Int) where T\n    results = T[]\n    \n    for i in 1:chunk_size:length(data)\n        chunk_end = min(i + chunk_size - 1, length(data))\n        # Use view instead of data[i:chunk_end] to avoid allocation\n        chunk_view = @view data[i:chunk_end]\n        push!(results, process_chunk(chunk_view))\n    end\n    \n    return results\nend\n\n# In-place operations\nfunction normalize!(v::Vector{T}) where T<:AbstractFloat\n    n = norm(v)\n    if n > 0\n        # Vectorized in-place operation\n        v ./= n\n    end\n    return v\nend\n\n# Cache-friendly algorithms\nfunction tiled_multiply!(C::Matrix{T}, A::Matrix{T}, B::Matrix{T}, tile_size::Int=64) where T\n    m, k = size(A)\n    k2, n = size(B)\n    @assert k == k2\n    \n    # Process in tiles for better cache usage\n    @inbounds for jj in 1:tile_size:n\n        for ii in 1:tile_size:m\n            for kk in 1:tile_size:k\n                # Process tile\n                for j in jj:min(jj+tile_size-1, n)\n                    for i in ii:min(ii+tile_size-1, m)\n                        Cij = C[i,j]\n                        for k in kk:min(kk+tile_size-1, k)\n                            Cij += A[i,k] * B[k,j]\n                        end\n                        C[i,j] = Cij\n                    end\n                end\n            end\n        end\n    end\n    return C\nend\n\n# Benchmark and profile\nusing BenchmarkTools\n\nfunction optimized_function(data)\n    # Use @btime to measure performance\n    # @btime optimized_function($data)\n    \n    # Use type annotations in critical paths\n    result::Float64 = 0.0\n    \n    # Hoist invariants out of loops\n    scaling_factor = 1.0 / length(data)\n    \n    @fastmath @inbounds for x in data\n        result += x * scaling_factor\n    end\n    \n    return result\nend"
    },
    "broadcast_pattern": {
      "description": "Broadcasting (dot syntax) in Julia enables vectorized operations on arrays and scalars with automatic size promotion and fusion for optimal performance",
      "whenToUse": "Use for element-wise operations on arrays, avoiding explicit loops, fusing multiple operations, or writing generic code that works with scalars and arrays",
      "example": "# Basic broadcasting with dot syntax\nfunction array_operations(x::Vector{Float64}, y::Vector{Float64})\n    # Element-wise operations\n    z = x .+ y .* 2.0\n    \n    # Fused broadcast - single loop, no temporaries\n    @. z = sin(x) + cos(y) * exp(-x^2)\n    \n    return z\nend\n\n# Broadcasting with custom functions\nclamp_positive(x) = max(0.0, x)\n\nfunction process_data(data::Matrix{Float64})\n    # Broadcast custom function\n    positive_data = clamp_positive.(data)\n    \n    # Multiple operations fused\n    result = @. log(1 + positive_data) / (1 + exp(-positive_data))\n    \n    return result\nend\n\n# Broadcasting with mixed dimensions\nfunction normalize_columns(matrix::Matrix{T}) where T\n    # Calculate mean and std for each column\n    col_means = mean(matrix, dims=1)  # 1Ã—n matrix\n    col_stds = std(matrix, dims=1)    # 1Ã—n matrix\n    \n    # Broadcast automatically handles dimension expansion\n    normalized = @. (matrix - col_means) / (col_stds + eps(T))\n    \n    return normalized\nend\n\n# Custom broadcasting behavior\nstruct Polynomial{T}\n    coeffs::Vector{T}\nend\n\n# Define broadcasting for custom type\nfunction Base.broadcasted(::typeof(evaluate), p::Polynomial, x)\n    # Horner's method for polynomial evaluation\n    result = zero(x)\n    for i in length(p.coeffs):-1:1\n        result = @. result * x + p.coeffs[i]\n    end\n    return result\nend\n\n# Lazy broadcasting with broadcast styles\nstruct LazyArray{T,N} <: AbstractArray{T,N}\n    f::Function\n    size::NTuple{N,Int}\nend\n\nBase.size(A::LazyArray) = A.size\nBase.getindex(A::LazyArray, I...) = A.f(I...)\n\n# Custom broadcast style\nstruct LazyStyle <: Broadcast.BroadcastStyle end\nBase.BroadcastStyle(::Type{<:LazyArray}) = LazyStyle()\n\n# In-place broadcasting\nfunction update_weights!(weights::Matrix{T}, gradients::Matrix{T}, \n                        learning_rate::T) where T\n    # In-place broadcast update\n    @. weights -= learning_rate * gradients\n    \n    # More complex in-place operation\n    @. weights = clamp(weights - learning_rate * gradients, -1, 1)\n    \n    return weights\nend\n\n# Broadcast with indices\nfunction distance_from_center(shape::Tuple{Int,Int})\n    m, n = shape\n    cx, cy = m/2, n/2\n    \n    # Use CartesianIndices with broadcasting\n    indices = CartesianIndices(shape)\n    distances = map(indices) do idx\n        i, j = Tuple(idx)\n        sqrt((i - cx)^2 + (j - cy)^2)\n    end\n    \n    return distances\nend\n\n# Advanced fusion with multiple arrays\nfunction fused_operations(a::Array{T}, b::Array{T}, c::Array{T}) where T\n    # Single fused loop for multiple operations\n    result = similar(a)\n    @. result = (sin(a) * cos(b) + tan(c)) / (1 + abs(a * b * c))\n    \n    # Conditional broadcasting\n    mask = a .> 0\n    result[mask] .= sqrt.(result[mask])\n    \n    return result\nend\n\n# Broadcasting with structured arrays\nstruct Point3D\n    x::Float64\n    y::Float64\n    z::Float64\nend\n\n# Enable broadcasting for custom struct\nBase.broadcastable(p::Point3D) = Ref(p)\n\n# Define arithmetic operations\nBase.:+(p1::Point3D, p2::Point3D) = Point3D(p1.x+p2.x, p1.y+p2.y, p1.z+p2.z)\nBase.:*(s::Number, p::Point3D) = Point3D(s*p.x, s*p.y, s*p.z)\n\n# Now can use broadcasting\nfunction scale_points(points::Vector{Point3D}, scale::Float64)\n    return scale .* points\nend"
    }
  }
}