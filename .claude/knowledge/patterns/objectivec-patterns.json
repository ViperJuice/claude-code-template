{
  "language": "objectivec",
  "patterns": {
    "singleton": {
      "description": "Ensure a class has only one instance with thread-safe initialization.",
      "whenToUse": "For shared resources, app-wide configuration, or manager classes.",
      "example": "// Modern singleton with dispatch_once\n@interface UserManager : NSObject\n\n+ (instancetype)sharedManager;\n- (void)loginUser:(NSString *)username password:(NSString *)password;\n- (void)logout;\n- (BOOL)isUserLoggedIn;\n@property (nonatomic, readonly) NSString *currentUsername;\n\n@end\n\n@implementation UserManager {\n    NSString *_currentUsername;\n    BOOL _isLoggedIn;\n}\n\n+ (instancetype)sharedManager {\n    static UserManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _isLoggedIn = NO;\n        _currentUsername = nil;\n    }\n    return self;\n}\n\n// Prevent additional instances\n+ (instancetype)allocWithZone:(NSZone *)zone {\n    return [self sharedManager];\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n    return self;\n}\n\n- (void)loginUser:(NSString *)username password:(NSString *)password {\n    // Perform login logic\n    _currentUsername = username;\n    _isLoggedIn = YES;\n    \n    // Post notification\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"UserDidLoginNotification\"\n                                                        object:self\n                                                      userInfo:@{@\"username\": username}];\n}\n\n- (void)logout {\n    _currentUsername = nil;\n    _isLoggedIn = NO;\n    \n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"UserDidLogoutNotification\"\n                                                        object:self];\n}\n\n- (BOOL)isUserLoggedIn {\n    return _isLoggedIn;\n}\n\n- (NSString *)currentUsername {\n    return _currentUsername;\n}\n\n@end\n\n// Alternative: Class cluster singleton\n@interface DatabaseManager : NSObject\n\n+ (instancetype)defaultManager;\n+ (instancetype)managerWithConfiguration:(NSDictionary *)config;\n\n@end\n\n@interface DatabaseManager ()\n@property (nonatomic, strong) NSDictionary *configuration;\n@end\n\n@implementation DatabaseManager\n\nstatic NSMutableDictionary *_instances;\n\n+ (void)initialize {\n    if (self == [DatabaseManager class]) {\n        _instances = [NSMutableDictionary dictionary];\n    }\n}\n\n+ (instancetype)defaultManager {\n    return [self managerWithConfiguration:@{@\"default\": @YES}];\n}\n\n+ (instancetype)managerWithConfiguration:(NSDictionary *)config {\n    NSString *key = config[@\"identifier\"] ?: @\"default\";\n    \n    @synchronized(_instances) {\n        DatabaseManager *instance = _instances[key];\n        if (!instance) {\n            instance = [[self alloc] initWithConfiguration:config];\n            _instances[key] = instance;\n        }\n        return instance;\n    }\n}\n\n- (instancetype)initWithConfiguration:(NSDictionary *)config {\n    self = [super init];\n    if (self) {\n        _configuration = config;\n    }\n    return self;\n}\n\n@end"
    },
    "delegation": {
      "description": "Define one-to-one communication between objects using protocols.",
      "whenToUse": "For callbacks, customizing behavior, and decoupling components.",
      "example": "// Protocol definition\n@protocol ImageDownloaderDelegate <NSObject>\n@required\n- (void)imageDownloader:(ImageDownloader *)downloader didFinishDownloadingImage:(UIImage *)image;\n- (void)imageDownloader:(ImageDownloader *)downloader didFailWithError:(NSError *)error;\n\n@optional\n- (void)imageDownloader:(ImageDownloader *)downloader didUpdateProgress:(CGFloat)progress;\n- (BOOL)imageDownloaderShouldDecodeInBackground:(ImageDownloader *)downloader;\n@end\n\n// Delegating class\n@interface ImageDownloader : NSObject\n\n@property (nonatomic, weak) id<ImageDownloaderDelegate> delegate;\n@property (nonatomic, strong, readonly) NSURL *imageURL;\n\n- (instancetype)initWithURL:(NSURL *)url;\n- (void)startDownload;\n- (void)cancelDownload;\n\n@end\n\n@implementation ImageDownloader {\n    NSURLSessionDataTask *_downloadTask;\n    NSMutableData *_imageData;\n    NSUInteger _expectedSize;\n}\n\n- (instancetype)initWithURL:(NSURL *)url {\n    self = [super init];\n    if (self) {\n        _imageURL = url;\n        _imageData = [NSMutableData data];\n    }\n    return self;\n}\n\n- (void)startDownload {\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]\n                                                          delegate:self\n                                                     delegateQueue:nil];\n    \n    _downloadTask = [session dataTaskWithURL:self.imageURL];\n    [_downloadTask resume];\n}\n\n- (void)cancelDownload {\n    [_downloadTask cancel];\n    _downloadTask = nil;\n    _imageData = nil;\n}\n\n#pragma mark - NSURLSessionDataDelegate\n\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\n    didReceiveResponse:(NSURLResponse *)response\n    completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler {\n    \n    _expectedSize = response.expectedContentLength;\n    completionHandler(NSURLSessionResponseAllow);\n}\n\n- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask\n    didReceiveData:(NSData *)data {\n    \n    [_imageData appendData:data];\n    \n    // Notify delegate of progress if it implements the optional method\n    if ([self.delegate respondsToSelector:@selector(imageDownloader:didUpdateProgress:)]) {\n        CGFloat progress = (CGFloat)_imageData.length / (CGFloat)_expectedSize;\n        \n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.delegate imageDownloader:self didUpdateProgress:progress];\n        });\n    }\n}\n\n- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task\n    didCompleteWithError:(NSError *)error {\n    \n    if (error) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.delegate imageDownloader:self didFailWithError:error];\n        });\n        return;\n    }\n    \n    // Check if delegate wants background decoding\n    BOOL shouldDecodeInBackground = NO;\n    if ([self.delegate respondsToSelector:@selector(imageDownloaderShouldDecodeInBackground:)]) {\n        shouldDecodeInBackground = [self.delegate imageDownloaderShouldDecodeInBackground:self];\n    }\n    \n    void (^decodeBlock)(void) = ^{\n        UIImage *image = [UIImage imageWithData:_imageData];\n        \n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (image) {\n                [self.delegate imageDownloader:self didFinishDownloadingImage:image];\n            } else {\n                NSError *decodeError = [NSError errorWithDomain:@\"ImageDownloaderError\"\n                                                           code:1001\n                                                       userInfo:@{NSLocalizedDescriptionKey: @\"Failed to decode image\"}];\n                [self.delegate imageDownloader:self didFailWithError:decodeError];\n            }\n        });\n    };\n    \n    if (shouldDecodeInBackground) {\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), decodeBlock);\n    } else {\n        decodeBlock();\n    }\n}\n\n@end\n\n// Usage example\n@interface ViewController () <ImageDownloaderDelegate>\n@property (nonatomic, strong) ImageDownloader *downloader;\n@property (nonatomic, weak) IBOutlet UIImageView *imageView;\n@property (nonatomic, weak) IBOutlet UIProgressView *progressView;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSURL *imageURL = [NSURL URLWithString:@\"https://example.com/large-image.jpg\"];\n    self.downloader = [[ImageDownloader alloc] initWithURL:imageURL];\n    self.downloader.delegate = self;\n    [self.downloader startDownload];\n}\n\n#pragma mark - ImageDownloaderDelegate\n\n- (void)imageDownloader:(ImageDownloader *)downloader didFinishDownloadingImage:(UIImage *)image {\n    self.imageView.image = image;\n    self.progressView.hidden = YES;\n}\n\n- (void)imageDownloader:(ImageDownloader *)downloader didFailWithError:(NSError *)error {\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"Download Failed\"\n                                                                   message:error.localizedDescription\n                                                            preferredStyle:UIAlertControllerStyleAlert];\n    [alert addAction:[UIAlertAction actionWithTitle:@\"OK\" style:UIAlertActionStyleDefault handler:nil]];\n    [self presentViewController:alert animated:YES completion:nil];\n}\n\n- (void)imageDownloader:(ImageDownloader *)downloader didUpdateProgress:(CGFloat)progress {\n    self.progressView.progress = progress;\n}\n\n- (BOOL)imageDownloaderShouldDecodeInBackground:(ImageDownloader *)downloader {\n    return YES; // Decode large images in background\n}\n\n@end"
    },
    "observer": {
      "description": "Implement one-to-many communication using notifications and KVO.",
      "whenToUse": "When multiple objects need to be notified of state changes.",
      "example": "// Notification-based Observer\n@interface DataModel : NSObject\n\n@property (nonatomic, strong) NSString *title;\n@property (nonatomic, assign) NSInteger count;\n\n- (void)incrementCount;\n- (void)reset;\n\n@end\n\n// Notification names\nNSString * const DataModelDidChangeNotification = @\"DataModelDidChangeNotification\";\nNSString * const DataModelCountKey = @\"count\";\nNSString * const DataModelTitleKey = @\"title\";\n\n@implementation DataModel\n\n- (void)setTitle:(NSString *)title {\n    if (![_title isEqualToString:title]) {\n        _title = title;\n        [self postChangeNotificationForKey:DataModelTitleKey];\n    }\n}\n\n- (void)incrementCount {\n    self.count++;\n}\n\n- (void)setCount:(NSInteger)count {\n    if (_count != count) {\n        NSInteger oldValue = _count;\n        _count = count;\n        \n        NSDictionary *userInfo = @{\n            @\"oldValue\": @(oldValue),\n            @\"newValue\": @(count),\n            @\"key\": DataModelCountKey\n        };\n        \n        [[NSNotificationCenter defaultCenter] postNotificationName:DataModelDidChangeNotification\n                                                            object:self\n                                                          userInfo:userInfo];\n    }\n}\n\n- (void)reset {\n    _title = @\"\";\n    _count = 0;\n    \n    [[NSNotificationCenter defaultCenter] postNotificationName:DataModelDidChangeNotification\n                                                        object:self\n                                                      userInfo:@{@\"reset\": @YES}];\n}\n\n- (void)postChangeNotificationForKey:(NSString *)key {\n    [[NSNotificationCenter defaultCenter] postNotificationName:DataModelDidChangeNotification\n                                                        object:self\n                                                      userInfo:@{@\"key\": key}];\n}\n\n@end\n\n// KVO-based Observer\n@interface Player : NSObject\n\n@property (nonatomic, strong) NSString *name;\n@property (nonatomic, assign) NSInteger score;\n@property (nonatomic, assign) NSInteger level;\n@property (nonatomic, readonly) NSInteger totalPoints;\n\n@end\n\n@implementation Player\n\n+ (NSSet<NSString *> *)keyPathsForValuesAffectingTotalPoints {\n    return [NSSet setWithObjects:@\"score\", @\"level\", nil];\n}\n\n- (NSInteger)totalPoints {\n    return self.score * self.level;\n}\n\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {\n    if ([key isEqualToString:@\"score\"]) {\n        return NO; // Manual KVO for score\n    }\n    return [super automaticallyNotifiesObserversForKey:key];\n}\n\n- (void)setScore:(NSInteger)score {\n    if (_score != score) {\n        [self willChangeValueForKey:@\"score\"];\n        \n        NSInteger oldScore = _score;\n        _score = score;\n        \n        // Custom logic during change\n        if (score > oldScore && score % 100 == 0) {\n            self.level++; // Auto level up every 100 points\n        }\n        \n        [self didChangeValueForKey:@\"score\"];\n    }\n}\n\n@end\n\n// Observer class\n@interface GameController : NSObject\n\n@property (nonatomic, strong) Player *player;\n@property (nonatomic, strong) DataModel *model;\n\n@end\n\n@implementation GameController {\n    id _notificationObserver;\n}\n\nstatic void *PlayerScoreContext = &PlayerScoreContext;\nstatic void *PlayerLevelContext = &PlayerLevelContext;\nstatic void *PlayerTotalPointsContext = &PlayerTotalPointsContext;\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _player = [[Player alloc] init];\n        _model = [[DataModel alloc] init];\n        \n        [self setupObservers];\n    }\n    return self;\n}\n\n- (void)setupObservers {\n    // KVO\n    [self.player addObserver:self\n                  forKeyPath:@\"score\"\n                     options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld\n                     context:PlayerScoreContext];\n    \n    [self.player addObserver:self\n                  forKeyPath:@\"level\"\n                     options:NSKeyValueObservingOptionNew\n                     context:PlayerLevelContext];\n    \n    [self.player addObserver:self\n                  forKeyPath:@\"totalPoints\"\n                     options:NSKeyValueObservingOptionNew\n                     context:PlayerTotalPointsContext];\n    \n    // Notifications\n    _notificationObserver = [[NSNotificationCenter defaultCenter]\n                             addObserverForName:DataModelDidChangeNotification\n                             object:self.model\n                             queue:[NSOperationQueue mainQueue]\n                             usingBlock:^(NSNotification *note) {\n                                 [self handleModelChange:note];\n                             }];\n}\n\n- (void)observeValueForKeyPath:(NSString *)keyPath\n                      ofObject:(id)object\n                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change\n                       context:(void *)context {\n    \n    if (context == PlayerScoreContext) {\n        NSInteger oldScore = [change[NSKeyValueChangeOldKey] integerValue];\n        NSInteger newScore = [change[NSKeyValueChangeNewKey] integerValue];\n        \n        NSLog(@\"Score changed from %ld to %ld\", (long)oldScore, (long)newScore);\n        \n    } else if (context == PlayerLevelContext) {\n        NSInteger newLevel = [change[NSKeyValueChangeNewKey] integerValue];\n        NSLog(@\"Level up! Now at level %ld\", (long)newLevel);\n        \n    } else if (context == PlayerTotalPointsContext) {\n        NSInteger totalPoints = [change[NSKeyValueChangeNewKey] integerValue];\n        NSLog(@\"Total points: %ld\", (long)totalPoints);\n        \n    } else {\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n    }\n}\n\n- (void)handleModelChange:(NSNotification *)notification {\n    NSDictionary *userInfo = notification.userInfo;\n    \n    if (userInfo[@\"reset\"]) {\n        NSLog(@\"Model was reset\");\n    } else if ([userInfo[@\"key\"] isEqualToString:DataModelCountKey]) {\n        NSLog(@\"Count changed from %@ to %@\", userInfo[@\"oldValue\"], userInfo[@\"newValue\"]);\n    }\n}\n\n- (void)dealloc {\n    // Remove KVO observers\n    [self.player removeObserver:self forKeyPath:@\"score\" context:PlayerScoreContext];\n    [self.player removeObserver:self forKeyPath:@\"level\" context:PlayerLevelContext];\n    [self.player removeObserver:self forKeyPath:@\"totalPoints\" context:PlayerTotalPointsContext];\n    \n    // Remove notification observer\n    [[NSNotificationCenter defaultCenter] removeObserver:_notificationObserver];\n}\n\n@end"
    },
    "category": {
      "description": "Add methods to existing classes without subclassing.",
      "whenToUse": "For extending framework classes or organizing code into logical groups.",
      "example": "// NSString category for validation\n@interface NSString (Validation)\n\n- (BOOL)isValidEmail;\n- (BOOL)isValidPhoneNumber;\n- (BOOL)isNumeric;\n- (BOOL)containsString:(NSString *)string options:(NSStringCompareOptions)options;\n- (NSString *)trimmedString;\n\n@end\n\n@implementation NSString (Validation)\n\n- (BOOL)isValidEmail {\n    NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\";\n    NSPredicate *emailPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex];\n    return [emailPredicate evaluateWithObject:self];\n}\n\n- (BOOL)isValidPhoneNumber {\n    NSString *phoneRegex = @\"^[\\\\+]?[(]?[0-9]{3}[)]?[-\\\\s\\\\.]?[(]?[0-9]{3}[)]?[-\\\\s\\\\.]?[0-9]{4,6}$\";\n    NSPredicate *phonePredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", phoneRegex];\n    return [phonePredicate evaluateWithObject:self];\n}\n\n- (BOOL)isNumeric {\n    NSCharacterSet *nonNumericSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];\n    return [self rangeOfCharacterFromSet:nonNumericSet].location == NSNotFound;\n}\n\n- (BOOL)containsString:(NSString *)string options:(NSStringCompareOptions)options {\n    return [self rangeOfString:string options:options].location != NSNotFound;\n}\n\n- (NSString *)trimmedString {\n    return [self stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];\n}\n\n@end\n\n// UIView category for animations\n@interface UIView (Animation)\n\n- (void)fadeIn:(NSTimeInterval)duration completion:(void (^)(BOOL finished))completion;\n- (void)fadeOut:(NSTimeInterval)duration completion:(void (^)(BOOL finished))completion;\n- (void)shake;\n- (void)pulse;\n- (void)addShadowWithColor:(UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius opacity:(CGFloat)opacity;\n\n@end\n\n@implementation UIView (Animation)\n\n- (void)fadeIn:(NSTimeInterval)duration completion:(void (^)(BOOL finished))completion {\n    self.alpha = 0.0;\n    self.hidden = NO;\n    \n    [UIView animateWithDuration:duration\n                          delay:0.0\n                        options:UIViewAnimationOptionCurveEaseIn\n                     animations:^{\n                         self.alpha = 1.0;\n                     }\n                     completion:completion];\n}\n\n- (void)fadeOut:(NSTimeInterval)duration completion:(void (^)(BOOL finished))completion {\n    [UIView animateWithDuration:duration\n                          delay:0.0\n                        options:UIViewAnimationOptionCurveEaseOut\n                     animations:^{\n                         self.alpha = 0.0;\n                     }\n                     completion:^(BOOL finished) {\n                         if (finished) {\n                             self.hidden = YES;\n                             self.alpha = 1.0; // Reset alpha\n                         }\n                         if (completion) {\n                             completion(finished);\n                         }\n                     }];\n}\n\n- (void)shake {\n    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@\"transform.translation.x\"];\n    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];\n    animation.duration = 0.6;\n    animation.values = @[@(-20), @(20), @(-20), @(20), @(-10), @(10), @(-5), @(5), @(0)];\n    [self.layer addAnimation:animation forKey:@\"shake\"];\n}\n\n- (void)pulse {\n    [UIView animateWithDuration:0.2\n                          delay:0.0\n                        options:UIViewAnimationOptionCurveEaseInOut\n                     animations:^{\n                         self.transform = CGAffineTransformMakeScale(1.1, 1.1);\n                     }\n                     completion:^(BOOL finished) {\n                         [UIView animateWithDuration:0.2\n                                               delay:0.0\n                                             options:UIViewAnimationOptionCurveEaseInOut\n                                          animations:^{\n                                              self.transform = CGAffineTransformIdentity;\n                                          }\n                                          completion:nil];\n                     }];\n}\n\n- (void)addShadowWithColor:(UIColor *)color offset:(CGSize)offset radius:(CGFloat)radius opacity:(CGFloat)opacity {\n    self.layer.shadowColor = color.CGColor;\n    self.layer.shadowOffset = offset;\n    self.layer.shadowRadius = radius;\n    self.layer.shadowOpacity = opacity;\n    self.layer.masksToBounds = NO;\n}\n\n@end\n\n// Class extension (private category)\n@interface MyViewController ()\n\n// Private properties\n@property (nonatomic, strong) NSTimer *updateTimer;\n@property (nonatomic, assign) BOOL isProcessing;\n\n// Private methods\n- (void)setupPrivateUI;\n- (void)startBackgroundTask;\n- (void)handleUpdateTimer:(NSTimer *)timer;\n\n@end\n\n@implementation MyViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [self setupPrivateUI];\n}\n\n- (void)setupPrivateUI {\n    // Private UI setup\n    self.updateTimer = [NSTimer scheduledTimerWithTimeInterval:1.0\n                                                         target:self\n                                                       selector:@selector(handleUpdateTimer:)\n                                                       userInfo:nil\n                                                        repeats:YES];\n}\n\n- (void)handleUpdateTimer:(NSTimer *)timer {\n    if (!self.isProcessing) {\n        [self startBackgroundTask];\n    }\n}\n\n- (void)startBackgroundTask {\n    self.isProcessing = YES;\n    \n    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        // Background work\n        \n        dispatch_async(dispatch_get_main_queue(), ^{\n            self.isProcessing = NO;\n        });\n    });\n}\n\n@end"
    },
    "factory": {
      "description": "Create objects without specifying their exact classes.",
      "whenToUse": "When you need to create different types of objects based on input parameters.",
      "example": "// Abstract factory pattern\n@protocol Vehicle <NSObject>\n@required\n- (void)start;\n- (void)stop;\n- (NSString *)description;\n@property (nonatomic, readonly) NSInteger numberOfWheels;\n@end\n\n// Concrete products\n@interface Car : NSObject <Vehicle>\n@property (nonatomic, strong) NSString *model;\n@end\n\n@implementation Car\n\n- (void)start {\n    NSLog(@\"Car engine started\");\n}\n\n- (void)stop {\n    NSLog(@\"Car engine stopped\");\n}\n\n- (NSInteger)numberOfWheels {\n    return 4;\n}\n\n- (NSString *)description {\n    return [NSString stringWithFormat:@\"Car: %@\", self.model ?: @\"Unknown\"];\n}\n\n@end\n\n@interface Motorcycle : NSObject <Vehicle>\n@property (nonatomic, strong) NSString *brand;\n@end\n\n@implementation Motorcycle\n\n- (void)start {\n    NSLog(@\"Motorcycle engine started\");\n}\n\n- (void)stop {\n    NSLog(@\"Motorcycle engine stopped\");\n}\n\n- (NSInteger)numberOfWheels {\n    return 2;\n}\n\n- (NSString *)description {\n    return [NSString stringWithFormat:@\"Motorcycle: %@\", self.brand ?: @\"Unknown\"];\n}\n\n@end\n\n// Factory class\n@interface VehicleFactory : NSObject\n\n+ (id<Vehicle>)vehicleOfType:(NSString *)type;\n+ (id<Vehicle>)vehicleWithConfiguration:(NSDictionary *)config;\n\n@end\n\n@implementation VehicleFactory\n\n+ (id<Vehicle>)vehicleOfType:(NSString *)type {\n    if ([type isEqualToString:@\"car\"]) {\n        return [[Car alloc] init];\n    } else if ([type isEqualToString:@\"motorcycle\"]) {\n        return [[Motorcycle alloc] init];\n    }\n    return nil;\n}\n\n+ (id<Vehicle>)vehicleWithConfiguration:(NSDictionary *)config {\n    NSString *type = config[@\"type\"];\n    id<Vehicle> vehicle = [self vehicleOfType:type];\n    \n    if ([vehicle isKindOfClass:[Car class]]) {\n        ((Car *)vehicle).model = config[@\"model\"];\n    } else if ([vehicle isKindOfClass:[Motorcycle class]]) {\n        ((Motorcycle *)vehicle).brand = config[@\"brand\"];\n    }\n    \n    return vehicle;\n}\n\n@end\n\n// Factory method pattern\n@interface Document : NSObject\n- (void)open;\n- (void)save;\n- (void)close;\n@end\n\n@implementation Document\n- (void)open { NSLog(@\"Opening document\"); }\n- (void)save { NSLog(@\"Saving document\"); }\n- (void)close { NSLog(@\"Closing document\"); }\n@end\n\n@interface TextDocument : Document\n@property (nonatomic, strong) NSString *text;\n@end\n\n@implementation TextDocument\n- (void)open { NSLog(@\"Opening text document\"); }\n- (void)save { NSLog(@\"Saving text document: %@\", self.text); }\n@end\n\n@interface SpreadsheetDocument : Document\n@property (nonatomic, strong) NSArray *data;\n@end\n\n@implementation SpreadsheetDocument\n- (void)open { NSLog(@\"Opening spreadsheet\"); }\n- (void)save { NSLog(@\"Saving spreadsheet with %lu rows\", (unsigned long)self.data.count); }\n@end\n\n// Abstract creator\n@interface Application : NSObject\n- (Document *)createDocument;\n- (void)newDocument;\n- (void)openDocument:(NSString *)path;\n@property (nonatomic, strong) NSMutableArray<Document *> *documents;\n@end\n\n@implementation Application\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _documents = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (Document *)createDocument {\n    // Abstract method - subclasses must override\n    [NSException raise:NSInternalInconsistencyException\n                format:@\"Subclass must implement createDocument\"];\n    return nil;\n}\n\n- (void)newDocument {\n    Document *doc = [self createDocument];\n    [self.documents addObject:doc];\n    [doc open];\n}\n\n- (void)openDocument:(NSString *)path {\n    Document *doc = [self createDocument];\n    // Load from path...\n    [self.documents addObject:doc];\n    [doc open];\n}\n\n@end\n\n// Concrete creators\n@interface TextApplication : Application\n@end\n\n@implementation TextApplication\n\n- (Document *)createDocument {\n    return [[TextDocument alloc] init];\n}\n\n@end\n\n@interface SpreadsheetApplication : Application\n@end\n\n@implementation SpreadsheetApplication\n\n- (Document *)createDocument {\n    return [[SpreadsheetDocument alloc] init];\n}\n\n@end\n\n// Class cluster factory\n@interface Shape : NSObject\n+ (instancetype)shapeWithType:(NSString *)type;\n- (CGFloat)area;\n- (CGFloat)perimeter;\n@end\n\n@interface Shape ()\n@property (nonatomic, strong) NSString *shapeType;\n@end\n\n// Private concrete classes\n@interface Circle : Shape\n@property (nonatomic, assign) CGFloat radius;\n@end\n\n@interface Rectangle : Shape\n@property (nonatomic, assign) CGFloat width;\n@property (nonatomic, assign) CGFloat height;\n@end\n\n@implementation Shape\n\n+ (instancetype)shapeWithType:(NSString *)type {\n    if ([type isEqualToString:@\"circle\"]) {\n        return [[Circle alloc] init];\n    } else if ([type isEqualToString:@\"rectangle\"]) {\n        return [[Rectangle alloc] init];\n    }\n    return nil;\n}\n\n- (CGFloat)area {\n    [NSException raise:NSInternalInconsistencyException\n                format:@\"Subclass must implement area\"];\n    return 0;\n}\n\n- (CGFloat)perimeter {\n    [NSException raise:NSInternalInconsistencyException\n                format:@\"Subclass must implement perimeter\"];\n    return 0;\n}\n\n@end\n\n@implementation Circle\n\n- (CGFloat)area {\n    return M_PI * self.radius * self.radius;\n}\n\n- (CGFloat)perimeter {\n    return 2 * M_PI * self.radius;\n}\n\n@end\n\n@implementation Rectangle\n\n- (CGFloat)area {\n    return self.width * self.height;\n}\n\n- (CGFloat)perimeter {\n    return 2 * (self.width + self.height);\n}\n\n@end"
    },
    "target_action": {
      "description": "Decouple the sender of a message from its receiver using target-action mechanism.",
      "whenToUse": "For UI controls, timers, and gesture recognizers.",
      "example": "// Custom control with target-action\n@interface CustomSlider : UIControl\n\n@property (nonatomic, assign) CGFloat value;\n@property (nonatomic, assign) CGFloat minimumValue;\n@property (nonatomic, assign) CGFloat maximumValue;\n@property (nonatomic, strong) UIColor *trackColor;\n@property (nonatomic, strong) UIColor *thumbColor;\n\n@end\n\n@implementation CustomSlider {\n    UIView *_trackView;\n    UIView *_thumbView;\n    CGFloat _thumbWidth;\n}\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    self = [super initWithFrame:frame];\n    if (self) {\n        [self setupViews];\n        [self setupGestures];\n        \n        // Default values\n        _minimumValue = 0.0;\n        _maximumValue = 1.0;\n        _value = 0.5;\n        _thumbWidth = 30.0;\n        _trackColor = [UIColor lightGrayColor];\n        _thumbColor = [UIColor blueColor];\n    }\n    return self;\n}\n\n- (void)setupViews {\n    // Track\n    _trackView = [[UIView alloc] init];\n    _trackView.backgroundColor = self.trackColor;\n    _trackView.layer.cornerRadius = 2.0;\n    [self addSubview:_trackView];\n    \n    // Thumb\n    _thumbView = [[UIView alloc] init];\n    _thumbView.backgroundColor = self.thumbColor;\n    _thumbView.layer.cornerRadius = _thumbWidth / 2.0;\n    [self addSubview:_thumbView];\n}\n\n- (void)setupGestures {\n    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self\n                                                                           action:@selector(handlePan:)];\n    [self addGestureRecognizer:pan];\n    \n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self\n                                                                           action:@selector(handleTap:)];\n    [self addGestureRecognizer:tap];\n}\n\n- (void)layoutSubviews {\n    [super layoutSubviews];\n    \n    CGFloat trackHeight = 4.0;\n    _trackView.frame = CGRectMake(0,\n                                  (self.bounds.size.height - trackHeight) / 2.0,\n                                  self.bounds.size.width,\n                                  trackHeight);\n    \n    [self updateThumbPosition];\n}\n\n- (void)updateThumbPosition {\n    CGFloat percentage = (self.value - self.minimumValue) / (self.maximumValue - self.minimumValue);\n    CGFloat thumbX = percentage * (self.bounds.size.width - _thumbWidth);\n    \n    _thumbView.frame = CGRectMake(thumbX,\n                                  (self.bounds.size.height - _thumbWidth) / 2.0,\n                                  _thumbWidth,\n                                  _thumbWidth);\n}\n\n- (void)setValue:(CGFloat)value {\n    _value = MAX(self.minimumValue, MIN(self.maximumValue, value));\n    [self updateThumbPosition];\n}\n\n- (void)setValue:(CGFloat)value animated:(BOOL)animated {\n    if (animated) {\n        [UIView animateWithDuration:0.3 animations:^{\n            self.value = value;\n        }];\n    } else {\n        self.value = value;\n    }\n}\n\n- (void)handlePan:(UIPanGestureRecognizer *)gesture {\n    CGPoint location = [gesture locationInView:self];\n    CGFloat percentage = location.x / self.bounds.size.width;\n    \n    CGFloat newValue = self.minimumValue + (percentage * (self.maximumValue - self.minimumValue));\n    self.value = newValue;\n    \n    // Send events\n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n    \n    if (gesture.state == UIGestureRecognizerStateEnded) {\n        [self sendActionsForControlEvents:UIControlEventTouchUpInside];\n    }\n}\n\n- (void)handleTap:(UITapGestureRecognizer *)gesture {\n    CGPoint location = [gesture locationInView:self];\n    CGFloat percentage = location.x / self.bounds.size.width;\n    \n    CGFloat newValue = self.minimumValue + (percentage * (self.maximumValue - self.minimumValue));\n    [self setValue:newValue animated:YES];\n    \n    [self sendActionsForControlEvents:UIControlEventValueChanged];\n}\n\n@end\n\n// Timer with target-action\n@interface CountdownTimer : NSObject\n\n@property (nonatomic, weak) id target;\n@property (nonatomic, assign) SEL action;\n@property (nonatomic, assign) NSTimeInterval duration;\n@property (nonatomic, readonly) NSTimeInterval timeRemaining;\n@property (nonatomic, readonly) BOOL isRunning;\n\n- (void)start;\n- (void)pause;\n- (void)resume;\n- (void)stop;\n\n@end\n\n@implementation CountdownTimer {\n    NSTimer *_timer;\n    NSTimeInterval _startTime;\n    NSTimeInterval _pausedTime;\n}\n\n- (void)start {\n    if (_isRunning) {\n        return;\n    }\n    \n    _isRunning = YES;\n    _startTime = [NSDate timeIntervalSinceReferenceDate];\n    _timeRemaining = self.duration;\n    \n    _timer = [NSTimer scheduledTimerWithTimeInterval:0.1\n                                             target:self\n                                           selector:@selector(timerTick:)\n                                           userInfo:nil\n                                            repeats:YES];\n}\n\n- (void)timerTick:(NSTimer *)timer {\n    NSTimeInterval elapsed = [NSDate timeIntervalSinceReferenceDate] - _startTime;\n    _timeRemaining = MAX(0, self.duration - elapsed);\n    \n    // Call target-action\n    if (self.target && self.action) {\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Warc-performSelector-leaks\"\n        [self.target performSelector:self.action withObject:self];\n#pragma clang diagnostic pop\n    }\n    \n    if (_timeRemaining == 0) {\n        [self stop];\n        \n        // Send completion notification\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"CountdownTimerDidFinish\"\n                                                            object:self];\n    }\n}\n\n- (void)pause {\n    if (!_isRunning || !_timer) {\n        return;\n    }\n    \n    _pausedTime = [NSDate timeIntervalSinceReferenceDate];\n    [_timer invalidate];\n    _timer = nil;\n}\n\n- (void)resume {\n    if (_isRunning && !_timer) {\n        NSTimeInterval pauseDuration = [NSDate timeIntervalSinceReferenceDate] - _pausedTime;\n        _startTime += pauseDuration;\n        \n        _timer = [NSTimer scheduledTimerWithTimeInterval:0.1\n                                                 target:self\n                                               selector:@selector(timerTick:)\n                                               userInfo:nil\n                                                repeats:YES];\n    }\n}\n\n- (void)stop {\n    _isRunning = NO;\n    [_timer invalidate];\n    _timer = nil;\n    _timeRemaining = 0;\n}\n\n- (void)dealloc {\n    [_timer invalidate];\n}\n\n@end\n\n// Usage example\n@interface ViewController ()\n@property (nonatomic, strong) CustomSlider *slider;\n@property (nonatomic, strong) CountdownTimer *timer;\n@property (nonatomic, weak) IBOutlet UILabel *timerLabel;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // Custom slider\n    self.slider = [[CustomSlider alloc] initWithFrame:CGRectMake(50, 100, 220, 40)];\n    [self.slider addTarget:self\n                    action:@selector(sliderValueChanged:)\n          forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:self.slider];\n    \n    // Timer\n    self.timer = [[CountdownTimer alloc] init];\n    self.timer.duration = 60.0; // 1 minute\n    self.timer.target = self;\n    self.timer.action = @selector(updateTimerDisplay:);\n    [self.timer start];\n}\n\n- (void)sliderValueChanged:(CustomSlider *)slider {\n    NSLog(@\"Slider value: %.2f\", slider.value);\n}\n\n- (void)updateTimerDisplay:(CountdownTimer *)timer {\n    NSInteger minutes = (NSInteger)timer.timeRemaining / 60;\n    NSInteger seconds = (NSInteger)timer.timeRemaining % 60;\n    self.timerLabel.text = [NSString stringWithFormat:@\"%02ld:%02ld\", (long)minutes, (long)seconds];\n}\n\n@end"
    },
    "block_callback": {
      "description": "Use blocks for callbacks and completion handlers.",
      "whenToUse": "For asynchronous operations, animations, and simple callbacks.",
      "example": "// Network manager with block callbacks\ntypedef void (^NetworkCompletionBlock)(id responseObject, NSError *error);\ntypedef void (^NetworkProgressBlock)(NSProgress *progress);\n\n@interface NetworkManager : NSObject\n\n+ (instancetype)sharedManager;\n\n- (NSURLSessionDataTask *)GET:(NSString *)URLString\n                    parameters:(NSDictionary *)parameters\n                    completion:(NetworkCompletionBlock)completion;\n\n- (NSURLSessionDownloadTask *)downloadFileFromURL:(NSURL *)URL\n                                          progress:(NetworkProgressBlock)progressBlock\n                                        completion:(void (^)(NSURL *filePath, NSError *error))completion;\n\n- (void)uploadData:(NSData *)data\n            toURL:(NSString *)URLString\n         progress:(NetworkProgressBlock)progressBlock\n       completion:(NetworkCompletionBlock)completion;\n\n@end\n\n@implementation NetworkManager\n\n+ (instancetype)sharedManager {\n    static NetworkManager *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}\n\n- (NSURLSessionDataTask *)GET:(NSString *)URLString\n                    parameters:(NSDictionary *)parameters\n                    completion:(NetworkCompletionBlock)completion {\n    \n    // Build URL with parameters\n    NSURLComponents *components = [NSURLComponents componentsWithString:URLString];\n    NSMutableArray *queryItems = [NSMutableArray array];\n    \n    [parameters enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {\n        [queryItems addObject:[NSURLQueryItem queryItemWithName:key value:[obj description]]];\n    }];\n    \n    components.queryItems = queryItems;\n    \n    NSURLRequest *request = [NSURLRequest requestWithURL:components.URL];\n    NSURLSession *session = [NSURLSession sharedSession];\n    \n    NSURLSessionDataTask *task = [session dataTaskWithRequest:request\n                                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (error) {\n                if (completion) {\n                    completion(nil, error);\n                }\n                return;\n            }\n            \n            NSError *jsonError;\n            id responseObject = [NSJSONSerialization JSONObjectWithData:data\n                                                               options:0\n                                                                 error:&jsonError];\n            if (completion) {\n                completion(responseObject, jsonError);\n            }\n        });\n    }];\n    \n    [task resume];\n    return task;\n}\n\n- (NSURLSessionDownloadTask *)downloadFileFromURL:(NSURL *)URL\n                                          progress:(NetworkProgressBlock)progressBlock\n                                        completion:(void (^)(NSURL *filePath, NSError *error))completion {\n    \n    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]\n                                                          delegate:self\n                                                     delegateQueue:[NSOperationQueue mainQueue]];\n    \n    NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithURL:URL\n                                                        completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {\n        if (error) {\n            if (completion) {\n                completion(nil, error);\n            }\n            return;\n        }\n        \n        // Move file to permanent location\n        NSFileManager *fileManager = [NSFileManager defaultManager];\n        NSURL *documentsURL = [fileManager URLsForDirectory:NSDocumentDirectory\n                                                  inDomains:NSUserDomainMask].firstObject;\n        NSURL *destinationURL = [documentsURL URLByAppendingPathComponent:response.suggestedFilename];\n        \n        NSError *moveError;\n        [fileManager moveItemAtURL:location toURL:destinationURL error:&moveError];\n        \n        if (completion) {\n            completion(moveError ? nil : destinationURL, moveError);\n        }\n    }];\n    \n    // Store progress block for delegate callback\n    objc_setAssociatedObject(downloadTask, @\"progressBlock\", progressBlock, OBJC_ASSOCIATION_COPY);\n    \n    [downloadTask resume];\n    return downloadTask;\n}\n\n@end\n\n// Animation utility with blocks\n@interface UIView (BlockAnimations)\n\n+ (void)animateWithDuration:(NSTimeInterval)duration\n                      delay:(NSTimeInterval)delay\n                    options:(UIViewAnimationOptions)options\n                 animations:(void (^)(void))animations\n                 completion:(void (^)(BOOL finished))completion;\n\n- (void)animateConstraintChanges:(void (^)(void))changes\n                        duration:(NSTimeInterval)duration\n                      completion:(void (^)(BOOL finished))completion;\n\n@end\n\n@implementation UIView (BlockAnimations)\n\n- (void)animateConstraintChanges:(void (^)(void))changes\n                        duration:(NSTimeInterval)duration\n                      completion:(void (^)(BOOL finished))completion {\n    \n    if (changes) {\n        changes();\n    }\n    \n    [UIView animateWithDuration:duration\n                          delay:0\n                        options:UIViewAnimationOptionCurveEaseInOut\n                     animations:^{\n                         [self.superview layoutIfNeeded];\n                     }\n                     completion:completion];\n}\n\n@end\n\n// Alert helper with blocks\n@interface UIAlertController (Blocks)\n\n+ (void)showAlertWithTitle:(NSString *)title\n                   message:(NSString *)message\n                   actions:(NSArray<NSString *> *)actions\n                    inViewController:(UIViewController *)viewController\n                completion:(void (^)(NSInteger buttonIndex))completion;\n\n+ (void)showActionSheetWithTitle:(NSString *)title\n                         message:(NSString *)message\n                         actions:(NSArray<NSString *> *)actions\n               cancelButtonTitle:(NSString *)cancelTitle\n          destructiveButtonTitle:(NSString *)destructiveTitle\n                  inViewController:(UIViewController *)viewController\n                      completion:(void (^)(NSInteger buttonIndex))completion;\n\n@end\n\n@implementation UIAlertController (Blocks)\n\n+ (void)showAlertWithTitle:(NSString *)title\n                   message:(NSString *)message\n                   actions:(NSArray<NSString *> *)actions\n            inViewController:(UIViewController *)viewController\n                completion:(void (^)(NSInteger buttonIndex))completion {\n    \n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:title\n                                                                   message:message\n                                                            preferredStyle:UIAlertControllerStyleAlert];\n    \n    [actions enumerateObjectsUsingBlock:^(NSString *actionTitle, NSUInteger idx, BOOL *stop) {\n        UIAlertAction *action = [UIAlertAction actionWithTitle:actionTitle\n                                                         style:UIAlertActionStyleDefault\n                                                       handler:^(UIAlertAction *action) {\n                                                           if (completion) {\n                                                               completion(idx);\n                                                           }\n                                                       }];\n        [alert addAction:action];\n    }];\n    \n    [viewController presentViewController:alert animated:YES completion:nil];\n}\n\n@end\n\n// Custom enumeration with blocks\n@interface NSArray (BlockEnumeration)\n\n- (void)enumerateObjectsWithProgress:(void (^)(id obj, NSUInteger idx, CGFloat progress))block;\n- (NSArray *)mapWithBlock:(id (^)(id obj, NSUInteger idx))block;\n- (NSArray *)filterWithBlock:(BOOL (^)(id obj, NSUInteger idx))block;\n- (id)reduceWithInitialValue:(id)initial block:(id (^)(id accumulator, id obj))block;\n\n@end\n\n@implementation NSArray (BlockEnumeration)\n\n- (void)enumerateObjectsWithProgress:(void (^)(id obj, NSUInteger idx, CGFloat progress))block {\n    NSUInteger count = self.count;\n    \n    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n        CGFloat progress = count > 0 ? (CGFloat)(idx + 1) / count : 1.0;\n        if (block) {\n            block(obj, idx, progress);\n        }\n    }];\n}\n\n- (NSArray *)mapWithBlock:(id (^)(id obj, NSUInteger idx))block {\n    NSMutableArray *result = [NSMutableArray arrayWithCapacity:self.count];\n    \n    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n        id mapped = block ? block(obj, idx) : nil;\n        if (mapped) {\n            [result addObject:mapped];\n        }\n    }];\n    \n    return [result copy];\n}\n\n- (NSArray *)filterWithBlock:(BOOL (^)(id obj, NSUInteger idx))block {\n    NSMutableArray *result = [NSMutableArray array];\n    \n    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n        if (block && block(obj, idx)) {\n            [result addObject:obj];\n        }\n    }];\n    \n    return [result copy];\n}\n\n- (id)reduceWithInitialValue:(id)initial block:(id (^)(id accumulator, id obj))block {\n    __block id result = initial;\n    \n    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {\n        if (block) {\n            result = block(result, obj);\n        }\n    }];\n    \n    return result;\n}\n\n@end"
    },
    "chain_of_responsibility": {
      "description": "Pass requests along a chain of handlers until one handles it.",
      "whenToUse": "For event handling, validation chains, or processing pipelines.",
      "example": "// Abstract handler\n@interface EventHandler : NSObject\n\n@property (nonatomic, strong) EventHandler *nextHandler;\n\n- (void)setNext:(EventHandler *)handler;\n- (BOOL)handleEvent:(UIEvent *)event;\n\n@end\n\n@implementation EventHandler\n\n- (void)setNext:(EventHandler *)handler {\n    self.nextHandler = handler;\n}\n\n- (BOOL)handleEvent:(UIEvent *)event {\n    // Base implementation - pass to next handler\n    if (self.nextHandler) {\n        return [self.nextHandler handleEvent:event];\n    }\n    return NO;\n}\n\n@end\n\n// Concrete handlers\n@interface TouchHandler : EventHandler\n@end\n\n@implementation TouchHandler\n\n- (BOOL)handleEvent:(UIEvent *)event {\n    if (event.type == UIEventTypeTouches) {\n        NSLog(@\"TouchHandler: Processing touch event\");\n        \n        UITouch *touch = [event.allTouches anyObject];\n        CGPoint location = [touch locationInView:touch.view];\n        NSLog(@\"Touch at location: %@\", NSStringFromCGPoint(location));\n        \n        return YES;\n    }\n    \n    return [super handleEvent:event];\n}\n\n@end\n\n@interface MotionHandler : EventHandler\n@end\n\n@implementation MotionHandler\n\n- (BOOL)handleEvent:(UIEvent *)event {\n    if (event.type == UIEventTypeMotion) {\n        NSLog(@\"MotionHandler: Processing motion event\");\n        \n        if (event.subtype == UIEventSubtypeMotionShake) {\n            NSLog(@\"Device was shaken\");\n        }\n        \n        return YES;\n    }\n    \n    return [super handleEvent:event];\n}\n\n@end\n\n@interface RemoteControlHandler : EventHandler\n@end\n\n@implementation RemoteControlHandler\n\n- (BOOL)handleEvent:(UIEvent *)event {\n    if (event.type == UIEventTypeRemoteControl) {\n        NSLog(@\"RemoteControlHandler: Processing remote control event\");\n        \n        switch (event.subtype) {\n            case UIEventSubtypeRemoteControlPlay:\n                NSLog(@\"Play button pressed\");\n                break;\n            case UIEventSubtypeRemoteControlPause:\n                NSLog(@\"Pause button pressed\");\n                break;\n            default:\n                break;\n        }\n        \n        return YES;\n    }\n    \n    return [super handleEvent:event];\n}\n\n@end\n\n// Validation chain\n@protocol Validator <NSObject>\n- (BOOL)validate:(id)input error:(NSError **)error;\n@end\n\n@interface ValidationChain : NSObject <Validator>\n\n- (void)addValidator:(id<Validator>)validator;\n- (BOOL)validate:(id)input error:(NSError **)error;\n\n@end\n\n@implementation ValidationChain {\n    NSMutableArray<id<Validator>> *_validators;\n}\n\n- (instancetype)init {\n    self = [super init];\n    if (self) {\n        _validators = [NSMutableArray array];\n    }\n    return self;\n}\n\n- (void)addValidator:(id<Validator>)validator {\n    [_validators addObject:validator];\n}\n\n- (BOOL)validate:(id)input error:(NSError **)error {\n    for (id<Validator> validator in _validators) {\n        NSError *validationError = nil;\n        \n        if (![validator validate:input error:&validationError]) {\n            if (error) {\n                *error = validationError;\n            }\n            return NO;\n        }\n    }\n    \n    return YES;\n}\n\n@end\n\n// Concrete validators\n@interface RequiredFieldValidator : NSObject <Validator>\n@property (nonatomic, strong) NSString *fieldName;\n@end\n\n@implementation RequiredFieldValidator\n\n- (BOOL)validate:(id)input error:(NSError **)error {\n    if (!input || [input isEqual:[NSNull null]] ||\n        ([input isKindOfClass:[NSString class]] && [input length] == 0)) {\n        \n        if (error) {\n            *error = [NSError errorWithDomain:@\"ValidationError\"\n                                         code:1001\n                                     userInfo:@{\n                NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"%@ is required\", self.fieldName]\n            }];\n        }\n        return NO;\n    }\n    \n    return YES;\n}\n\n@end\n\n@interface EmailValidator : NSObject <Validator>\n@end\n\n@implementation EmailValidator\n\n- (BOOL)validate:(id)input error:(NSError **)error {\n    if (![input isKindOfClass:[NSString class]]) {\n        if (error) {\n            *error = [NSError errorWithDomain:@\"ValidationError\"\n                                         code:1002\n                                     userInfo:@{\n                NSLocalizedDescriptionKey: @\"Email must be a string\"\n            }];\n        }\n        return NO;\n    }\n    \n    NSString *emailRegex = @\"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\";\n    NSPredicate *emailPredicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", emailRegex];\n    \n    if (![emailPredicate evaluateWithObject:input]) {\n        if (error) {\n            *error = [NSError errorWithDomain:@\"ValidationError\"\n                                         code:1003\n                                     userInfo:@{\n                NSLocalizedDescriptionKey: @\"Invalid email format\"\n            }];\n        }\n        return NO;\n    }\n    \n    return YES;\n}\n\n@end\n\n@interface LengthValidator : NSObject <Validator>\n@property (nonatomic, assign) NSUInteger minLength;\n@property (nonatomic, assign) NSUInteger maxLength;\n@end\n\n@implementation LengthValidator\n\n- (BOOL)validate:(id)input error:(NSError **)error {\n    if (![input isKindOfClass:[NSString class]]) {\n        return YES; // Skip if not string\n    }\n    \n    NSUInteger length = [(NSString *)input length];\n    \n    if (length < self.minLength) {\n        if (error) {\n            *error = [NSError errorWithDomain:@\"ValidationError\"\n                                         code:1004\n                                     userInfo:@{\n                NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"Must be at least %lu characters\", (unsigned long)self.minLength]\n            }];\n        }\n        return NO;\n    }\n    \n    if (self.maxLength > 0 && length > self.maxLength) {\n        if (error) {\n            *error = [NSError errorWithDomain:@\"ValidationError\"\n                                         code:1005\n                                     userInfo:@{\n                NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"Must be no more than %lu characters\", (unsigned long)self.maxLength]\n            }];\n        }\n        return NO;\n    }\n    \n    return YES;\n}\n\n@end\n\n// Usage example\n@interface FormViewController : UIViewController\n@property (nonatomic, strong) ValidationChain *emailValidation;\n@property (nonatomic, strong) ValidationChain *passwordValidation;\n@end\n\n@implementation FormViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // Setup email validation chain\n    self.emailValidation = [[ValidationChain alloc] init];\n    \n    RequiredFieldValidator *emailRequired = [[RequiredFieldValidator alloc] init];\n    emailRequired.fieldName = @\"Email\";\n    [self.emailValidation addValidator:emailRequired];\n    \n    [self.emailValidation addValidator:[[EmailValidator alloc] init]];\n    \n    // Setup password validation chain\n    self.passwordValidation = [[ValidationChain alloc] init];\n    \n    RequiredFieldValidator *passwordRequired = [[RequiredFieldValidator alloc] init];\n    passwordRequired.fieldName = @\"Password\";\n    [self.passwordValidation addValidator:passwordRequired];\n    \n    LengthValidator *passwordLength = [[LengthValidator alloc] init];\n    passwordLength.minLength = 8;\n    passwordLength.maxLength = 50;\n    [self.passwordValidation addValidator:passwordLength];\n}\n\n- (BOOL)validateForm:(NSDictionary *)formData {\n    NSError *error = nil;\n    \n    // Validate email\n    if (![self.emailValidation validate:formData[@\"email\"] error:&error]) {\n        [self showError:error];\n        return NO;\n    }\n    \n    // Validate password\n    if (![self.passwordValidation validate:formData[@\"password\"] error:&error]) {\n        [self showError:error];\n        return NO;\n    }\n    \n    return YES;\n}\n\n- (void)showError:(NSError *)error {\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"Validation Error\"\n                                                                   message:error.localizedDescription\n                                                            preferredStyle:UIAlertControllerStyleAlert];\n    [alert addAction:[UIAlertAction actionWithTitle:@\"OK\" style:UIAlertActionStyleDefault handler:nil]];\n    [self presentViewController:alert animated:YES completion:nil];\n}\n\n@end"
    }
  }
}